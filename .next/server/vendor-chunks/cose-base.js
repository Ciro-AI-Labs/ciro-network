/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cose-base";
exports.ids = ["vendor-chunks/cose-base"];
exports.modules = {

/***/ "(ssr)/./node_modules/cose-base/cose-base.js":
/*!*********************************************!*\
  !*** ./node_modules/cose-base/cose-base.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! layout-base */ \"(ssr)/./node_modules/layout-base/layout-base.js\"));\n    else {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_675__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_675__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_675__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_675__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_675__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_675__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_675__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_675__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_675__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_675__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_675__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_675__(__nested_webpack_require_675__.s = 7);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_3688__) {\n            \"use strict\";\n            var FDLayoutConstants = __nested_webpack_require_3688__(0).FDLayoutConstants;\n            function CoSEConstants() {}\n            //CoSEConstants inherits static props in FDLayoutConstants\n            for(var prop in FDLayoutConstants){\n                CoSEConstants[prop] = FDLayoutConstants[prop];\n            }\n            CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n            CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n            CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n            CoSEConstants.TILE = true;\n            CoSEConstants.TILING_PADDING_VERTICAL = 10;\n            CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n            CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n            module1.exports = CoSEConstants;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __nested_webpack_require_4694__) {\n            \"use strict\";\n            var FDLayoutEdge = __nested_webpack_require_4694__(0).FDLayoutEdge;\n            function CoSEEdge(source, target, vEdge) {\n                FDLayoutEdge.call(this, source, target, vEdge);\n            }\n            CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n            for(var prop in FDLayoutEdge){\n                CoSEEdge[prop] = FDLayoutEdge[prop];\n            }\n            module1.exports = CoSEEdge;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_5233__) {\n            \"use strict\";\n            var LGraph = __nested_webpack_require_5233__(0).LGraph;\n            function CoSEGraph(parent, graphMgr, vGraph) {\n                LGraph.call(this, parent, graphMgr, vGraph);\n            }\n            CoSEGraph.prototype = Object.create(LGraph.prototype);\n            for(var prop in LGraph){\n                CoSEGraph[prop] = LGraph[prop];\n            }\n            module1.exports = CoSEGraph;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_5746__) {\n            \"use strict\";\n            var LGraphManager = __nested_webpack_require_5746__(0).LGraphManager;\n            function CoSEGraphManager(layout) {\n                LGraphManager.call(this, layout);\n            }\n            CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n            for(var prop in LGraphManager){\n                CoSEGraphManager[prop] = LGraphManager[prop];\n            }\n            module1.exports = CoSEGraphManager;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_6293__) {\n            \"use strict\";\n            var FDLayoutNode = __nested_webpack_require_6293__(0).FDLayoutNode;\n            var IMath = __nested_webpack_require_6293__(0).IMath;\n            function CoSENode(gm, loc, size, vNode) {\n                FDLayoutNode.call(this, gm, loc, size, vNode);\n            }\n            CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n            for(var prop in FDLayoutNode){\n                CoSENode[prop] = FDLayoutNode[prop];\n            }\n            CoSENode.prototype.move = function() {\n                var layout = this.graphManager.getLayout();\n                this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n                this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n                if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n                }\n                if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n                }\n                // a simple node, just move it\n                if (this.child == null) {\n                    this.moveBy(this.displacementX, this.displacementY);\n                } else if (this.child.getNodes().length == 0) {\n                    this.moveBy(this.displacementX, this.displacementY);\n                } else {\n                    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n                }\n                layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n                this.springForceX = 0;\n                this.springForceY = 0;\n                this.repulsionForceX = 0;\n                this.repulsionForceY = 0;\n                this.gravitationForceX = 0;\n                this.gravitationForceY = 0;\n                this.displacementX = 0;\n                this.displacementY = 0;\n            };\n            CoSENode.prototype.propogateDisplacementToChildren = function(dX, dY) {\n                var nodes = this.getChild().getNodes();\n                var node;\n                for(var i = 0; i < nodes.length; i++){\n                    node = nodes[i];\n                    if (node.getChild() == null) {\n                        node.moveBy(dX, dY);\n                        node.displacementX += dX;\n                        node.displacementY += dY;\n                    } else {\n                        node.propogateDisplacementToChildren(dX, dY);\n                    }\n                }\n            };\n            CoSENode.prototype.setPred1 = function(pred11) {\n                this.pred1 = pred11;\n            };\n            CoSENode.prototype.getPred1 = function() {\n                return pred1;\n            };\n            CoSENode.prototype.getPred2 = function() {\n                return pred2;\n            };\n            CoSENode.prototype.setNext = function(next1) {\n                this.next = next1;\n            };\n            CoSENode.prototype.getNext = function() {\n                return next;\n            };\n            CoSENode.prototype.setProcessed = function(processed1) {\n                this.processed = processed1;\n            };\n            CoSENode.prototype.isProcessed = function() {\n                return processed;\n            };\n            module1.exports = CoSENode;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_10041__) {\n            \"use strict\";\n            var FDLayout = __nested_webpack_require_10041__(0).FDLayout;\n            var CoSEGraphManager = __nested_webpack_require_10041__(4);\n            var CoSEGraph = __nested_webpack_require_10041__(3);\n            var CoSENode = __nested_webpack_require_10041__(5);\n            var CoSEEdge = __nested_webpack_require_10041__(2);\n            var CoSEConstants = __nested_webpack_require_10041__(1);\n            var FDLayoutConstants = __nested_webpack_require_10041__(0).FDLayoutConstants;\n            var LayoutConstants = __nested_webpack_require_10041__(0).LayoutConstants;\n            var Point = __nested_webpack_require_10041__(0).Point;\n            var PointD = __nested_webpack_require_10041__(0).PointD;\n            var Layout = __nested_webpack_require_10041__(0).Layout;\n            var Integer = __nested_webpack_require_10041__(0).Integer;\n            var IGeometry = __nested_webpack_require_10041__(0).IGeometry;\n            var LGraph = __nested_webpack_require_10041__(0).LGraph;\n            var Transform = __nested_webpack_require_10041__(0).Transform;\n            function CoSELayout() {\n                FDLayout.call(this);\n                this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n            }\n            CoSELayout.prototype = Object.create(FDLayout.prototype);\n            for(var prop in FDLayout){\n                CoSELayout[prop] = FDLayout[prop];\n            }\n            CoSELayout.prototype.newGraphManager = function() {\n                var gm = new CoSEGraphManager(this);\n                this.graphManager = gm;\n                return gm;\n            };\n            CoSELayout.prototype.newGraph = function(vGraph) {\n                return new CoSEGraph(null, this.graphManager, vGraph);\n            };\n            CoSELayout.prototype.newNode = function(vNode) {\n                return new CoSENode(this.graphManager, vNode);\n            };\n            CoSELayout.prototype.newEdge = function(vEdge) {\n                return new CoSEEdge(null, null, vEdge);\n            };\n            CoSELayout.prototype.initParameters = function() {\n                FDLayout.prototype.initParameters.call(this, arguments);\n                if (!this.isSubLayout) {\n                    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n                        this.idealEdgeLength = 10;\n                    } else {\n                        this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n                    }\n                    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n                    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n                    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                    // variables for tree reduction support\n                    this.prunedNodesAll = [];\n                    this.growTreeIterations = 0;\n                    this.afterGrowthIterations = 0;\n                    this.isTreeGrowing = false;\n                    this.isGrowthFinished = false;\n                    // variables for cooling\n                    this.coolingCycle = 0;\n                    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n                    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n                    this.coolingAdjuster = 1;\n                }\n            };\n            CoSELayout.prototype.layout = function() {\n                var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                if (createBendsAsNeeded) {\n                    this.createBendpoints();\n                    this.graphManager.resetAllEdges();\n                }\n                this.level = 0;\n                return this.classicLayout();\n            };\n            CoSELayout.prototype.classicLayout = function() {\n                this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n                this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n                this.calcNoOfChildrenForAllNodes();\n                this.graphManager.calcLowestCommonAncestors();\n                this.graphManager.calcInclusionTreeDepths();\n                this.graphManager.getRoot().calcEstimatedSize();\n                this.calcIdealEdgeLengths();\n                if (!this.incremental) {\n                    var forest = this.getFlatForest();\n                    // The graph associated with this layout is flat and a forest\n                    if (forest.length > 0) {\n                        this.positionNodesRadially(forest);\n                    } else {\n                        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n                        this.reduceTrees();\n                        // Update nodes that gravity will be applied\n                        this.graphManager.resetAllNodesToApplyGravitation();\n                        var allNodes = new Set(this.getAllNodes());\n                        var intersection = this.nodesWithGravity.filter(function(x) {\n                            return allNodes.has(x);\n                        });\n                        this.graphManager.setAllNodesToApplyGravitation(intersection);\n                        this.positionNodesRandomly();\n                    }\n                } else {\n                    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n                        // Reduce the trees in incremental mode if only this constant is set to true \n                        this.reduceTrees();\n                        // Update nodes that gravity will be applied\n                        this.graphManager.resetAllNodesToApplyGravitation();\n                        var allNodes = new Set(this.getAllNodes());\n                        var intersection = this.nodesWithGravity.filter(function(x) {\n                            return allNodes.has(x);\n                        });\n                        this.graphManager.setAllNodesToApplyGravitation(intersection);\n                    }\n                }\n                this.initSpringEmbedder();\n                this.runSpringEmbedder();\n                return true;\n            };\n            CoSELayout.prototype.tick = function() {\n                this.totalIterations++;\n                if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n                    if (this.prunedNodesAll.length > 0) {\n                        this.isTreeGrowing = true;\n                    } else {\n                        return true;\n                    }\n                }\n                if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n                    if (this.isConverged()) {\n                        if (this.prunedNodesAll.length > 0) {\n                            this.isTreeGrowing = true;\n                        } else {\n                            return true;\n                        }\n                    }\n                    this.coolingCycle++;\n                    if (this.layoutQuality == 0) {\n                        // quality - \"draft\"\n                        this.coolingAdjuster = this.coolingCycle;\n                    } else if (this.layoutQuality == 1) {\n                        // quality - \"default\"\n                        this.coolingAdjuster = this.coolingCycle / 3;\n                    }\n                    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n                    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n                    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n                }\n                // Operations while tree is growing again \n                if (this.isTreeGrowing) {\n                    if (this.growTreeIterations % 10 == 0) {\n                        if (this.prunedNodesAll.length > 0) {\n                            this.graphManager.updateBounds();\n                            this.updateGrid();\n                            this.growTree(this.prunedNodesAll);\n                            // Update nodes that gravity will be applied\n                            this.graphManager.resetAllNodesToApplyGravitation();\n                            var allNodes = new Set(this.getAllNodes());\n                            var intersection = this.nodesWithGravity.filter(function(x) {\n                                return allNodes.has(x);\n                            });\n                            this.graphManager.setAllNodesToApplyGravitation(intersection);\n                            this.graphManager.updateBounds();\n                            this.updateGrid();\n                            this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                        } else {\n                            this.isTreeGrowing = false;\n                            this.isGrowthFinished = true;\n                        }\n                    }\n                    this.growTreeIterations++;\n                }\n                // Operations after growth is finished\n                if (this.isGrowthFinished) {\n                    if (this.isConverged()) {\n                        return true;\n                    }\n                    if (this.afterGrowthIterations % 10 == 0) {\n                        this.graphManager.updateBounds();\n                        this.updateGrid();\n                    }\n                    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n                    this.afterGrowthIterations++;\n                }\n                var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n                var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n                this.totalDisplacement = 0;\n                this.graphManager.updateBounds();\n                this.calcSpringForces();\n                this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                this.calcGravitationalForces();\n                this.moveNodes();\n                this.animate();\n                return false; // Layout is not ended yet return false\n            };\n            CoSELayout.prototype.getPositionsData = function() {\n                var allNodes = this.graphManager.getAllNodes();\n                var pData = {};\n                for(var i = 0; i < allNodes.length; i++){\n                    var rect = allNodes[i].rect;\n                    var id = allNodes[i].id;\n                    pData[id] = {\n                        id: id,\n                        x: rect.getCenterX(),\n                        y: rect.getCenterY(),\n                        w: rect.width,\n                        h: rect.height\n                    };\n                }\n                return pData;\n            };\n            CoSELayout.prototype.runSpringEmbedder = function() {\n                this.initialAnimationPeriod = 25;\n                this.animationPeriod = this.initialAnimationPeriod;\n                var layoutEnded = false;\n                // If aminate option is 'during' signal that layout is supposed to start iterating\n                if (FDLayoutConstants.ANIMATE === \"during\") {\n                    this.emit(\"layoutstarted\");\n                } else {\n                    // If aminate option is 'during' tick() function will be called on index.js\n                    while(!layoutEnded){\n                        layoutEnded = this.tick();\n                    }\n                    this.graphManager.updateBounds();\n                }\n            };\n            CoSELayout.prototype.calculateNodesToApplyGravitationTo = function() {\n                var nodeList = [];\n                var graph;\n                var graphs = this.graphManager.getGraphs();\n                var size = graphs.length;\n                var i;\n                for(i = 0; i < size; i++){\n                    graph = graphs[i];\n                    graph.updateConnected();\n                    if (!graph.isConnected) {\n                        nodeList = nodeList.concat(graph.getNodes());\n                    }\n                }\n                return nodeList;\n            };\n            CoSELayout.prototype.createBendpoints = function() {\n                var edges = [];\n                edges = edges.concat(this.graphManager.getAllEdges());\n                var visited = new Set();\n                var i;\n                for(i = 0; i < edges.length; i++){\n                    var edge = edges[i];\n                    if (!visited.has(edge)) {\n                        var source = edge.getSource();\n                        var target = edge.getTarget();\n                        if (source == target) {\n                            edge.getBendpoints().push(new PointD());\n                            edge.getBendpoints().push(new PointD());\n                            this.createDummyNodesForBendpoints(edge);\n                            visited.add(edge);\n                        } else {\n                            var edgeList = [];\n                            edgeList = edgeList.concat(source.getEdgeListToNode(target));\n                            edgeList = edgeList.concat(target.getEdgeListToNode(source));\n                            if (!visited.has(edgeList[0])) {\n                                if (edgeList.length > 1) {\n                                    var k;\n                                    for(k = 0; k < edgeList.length; k++){\n                                        var multiEdge = edgeList[k];\n                                        multiEdge.getBendpoints().push(new PointD());\n                                        this.createDummyNodesForBendpoints(multiEdge);\n                                    }\n                                }\n                                edgeList.forEach(function(edge) {\n                                    visited.add(edge);\n                                });\n                            }\n                        }\n                    }\n                    if (visited.size == edges.length) {\n                        break;\n                    }\n                }\n            };\n            CoSELayout.prototype.positionNodesRadially = function(forest) {\n                // We tile the trees to a grid row by row; first tree starts at (0,0)\n                var currentStartingPoint = new Point(0, 0);\n                var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n                var height = 0;\n                var currentY = 0;\n                var currentX = 0;\n                var point = new PointD(0, 0);\n                for(var i = 0; i < forest.length; i++){\n                    if (i % numberOfColumns == 0) {\n                        // Start of a new row, make the x coordinate 0, increment the\n                        // y coordinate with the max height of the previous row\n                        currentX = 0;\n                        currentY = height;\n                        if (i != 0) {\n                            currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n                        }\n                        height = 0;\n                    }\n                    var tree = forest[i];\n                    // Find the center of the tree\n                    var centerNode = Layout.findCenterOfTree(tree);\n                    // Set the staring point of the next tree\n                    currentStartingPoint.x = currentX;\n                    currentStartingPoint.y = currentY;\n                    // Do a radial layout starting with the center\n                    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n                    if (point.y > height) {\n                        height = Math.floor(point.y);\n                    }\n                    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n                }\n                this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n            };\n            CoSELayout.radialLayout = function(tree, centerNode, startingPoint) {\n                var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n                CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n                var bounds = LGraph.calculateBounds(tree);\n                var transform = new Transform();\n                transform.setDeviceOrgX(bounds.getMinX());\n                transform.setDeviceOrgY(bounds.getMinY());\n                transform.setWorldOrgX(startingPoint.x);\n                transform.setWorldOrgY(startingPoint.y);\n                for(var i = 0; i < tree.length; i++){\n                    var node = tree[i];\n                    node.transform(transform);\n                }\n                var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n                return transform.inverseTransformPoint(bottomRight);\n            };\n            CoSELayout.branchRadialLayout = function(node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n                // First, position this node by finding its angle.\n                var halfInterval = (endAngle - startAngle + 1) / 2;\n                if (halfInterval < 0) {\n                    halfInterval += 180;\n                }\n                var nodeAngle = (halfInterval + startAngle) % 360;\n                var teta = nodeAngle * IGeometry.TWO_PI / 360;\n                // Make polar to java cordinate conversion.\n                var cos_teta = Math.cos(teta);\n                var x_ = distance * Math.cos(teta);\n                var y_ = distance * Math.sin(teta);\n                node.setCenter(x_, y_);\n                // Traverse all neighbors of this node and recursively call this\n                // function.\n                var neighborEdges = [];\n                neighborEdges = neighborEdges.concat(node.getEdges());\n                var childCount = neighborEdges.length;\n                if (parentOfNode != null) {\n                    childCount--;\n                }\n                var branchCount = 0;\n                var incEdgesCount = neighborEdges.length;\n                var startIndex;\n                var edges = node.getEdgesBetween(parentOfNode);\n                // If there are multiple edges, prune them until there remains only one\n                // edge.\n                while(edges.length > 1){\n                    //neighborEdges.remove(edges.remove(0));\n                    var temp = edges[0];\n                    edges.splice(0, 1);\n                    var index = neighborEdges.indexOf(temp);\n                    if (index >= 0) {\n                        neighborEdges.splice(index, 1);\n                    }\n                    incEdgesCount--;\n                    childCount--;\n                }\n                if (parentOfNode != null) {\n                    //assert edges.length == 1;\n                    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n                } else {\n                    startIndex = 0;\n                }\n                var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n                for(var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount){\n                    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n                    // Don't back traverse to root node in current tree.\n                    if (currentNeighbor == parentOfNode) {\n                        continue;\n                    }\n                    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n                    var childEndAngle = (childStartAngle + stepAngle) % 360;\n                    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n                    branchCount++;\n                }\n            };\n            CoSELayout.maxDiagonalInTree = function(tree) {\n                var maxDiagonal = Integer.MIN_VALUE;\n                for(var i = 0; i < tree.length; i++){\n                    var node = tree[i];\n                    var diagonal = node.getDiagonal();\n                    if (diagonal > maxDiagonal) {\n                        maxDiagonal = diagonal;\n                    }\n                }\n                return maxDiagonal;\n            };\n            CoSELayout.prototype.calcRepulsionRange = function() {\n                // formula is 2 x (level + 1) x idealEdgeLength\n                return 2 * (this.level + 1) * this.idealEdgeLength;\n            };\n            // Tiling methods\n            // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n            CoSELayout.prototype.groupZeroDegreeMembers = function() {\n                var self = this;\n                // array of [parent_id x oneDegreeNode_id]\n                var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n                this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n                this.idToDummyNode = {}; // A map of id to dummy node \n                var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n                var allNodes = this.graphManager.getAllNodes();\n                // Fill zero degree list\n                for(var i = 0; i < allNodes.length; i++){\n                    var node = allNodes[i];\n                    var parent = node.getParent();\n                    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n                    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n                        zeroDegree.push(node);\n                    }\n                }\n                // Create a map of parent node and its zero degree members\n                for(var i = 0; i < zeroDegree.length; i++){\n                    var node = zeroDegree[i]; // Zero degree node itself\n                    var p_id = node.getParent().id; // Parent id\n                    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n                    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n                }\n                // If there are at least two nodes at a level, create a dummy compound for them\n                Object.keys(tempMemberGroups).forEach(function(p_id) {\n                    if (tempMemberGroups[p_id].length > 1) {\n                        var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n                        self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n                        var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n                        // Create a dummy compound with calculated id\n                        var dummyCompound = new CoSENode(self.graphManager);\n                        dummyCompound.id = dummyCompoundId;\n                        dummyCompound.paddingLeft = parent.paddingLeft || 0;\n                        dummyCompound.paddingRight = parent.paddingRight || 0;\n                        dummyCompound.paddingBottom = parent.paddingBottom || 0;\n                        dummyCompound.paddingTop = parent.paddingTop || 0;\n                        self.idToDummyNode[dummyCompoundId] = dummyCompound;\n                        var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n                        var parentGraph = parent.getChild();\n                        // Add dummy compound to parent the graph\n                        parentGraph.add(dummyCompound);\n                        // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n                        for(var i = 0; i < tempMemberGroups[p_id].length; i++){\n                            var node = tempMemberGroups[p_id][i];\n                            parentGraph.remove(node);\n                            dummyParentGraph.add(node);\n                        }\n                    }\n                });\n            };\n            CoSELayout.prototype.clearCompounds = function() {\n                var childGraphMap = {};\n                var idToNode = {};\n                // Get compound ordering by finding the inner one first\n                this.performDFSOnCompounds();\n                for(var i = 0; i < this.compoundOrder.length; i++){\n                    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n                    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n                    // Remove children of compounds\n                    this.graphManager.remove(this.compoundOrder[i].getChild());\n                    this.compoundOrder[i].child = null;\n                }\n                this.graphManager.resetAllNodes();\n                // Tile the removed children\n                this.tileCompoundMembers(childGraphMap, idToNode);\n            };\n            CoSELayout.prototype.clearZeroDegreeMembers = function() {\n                var self = this;\n                var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n                Object.keys(this.memberGroups).forEach(function(id) {\n                    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n                    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                    // Set the width and height of the dummy compound as calculated\n                    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n                    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n                });\n            };\n            CoSELayout.prototype.repopulateCompounds = function() {\n                for(var i = this.compoundOrder.length - 1; i >= 0; i--){\n                    var lCompoundNode = this.compoundOrder[i];\n                    var id = lCompoundNode.id;\n                    var horizontalMargin = lCompoundNode.paddingLeft;\n                    var verticalMargin = lCompoundNode.paddingTop;\n                    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n                }\n            };\n            CoSELayout.prototype.repopulateZeroDegreeMembers = function() {\n                var self = this;\n                var tiledPack = this.tiledZeroDegreePack;\n                Object.keys(tiledPack).forEach(function(id) {\n                    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n                    var horizontalMargin = compoundNode.paddingLeft;\n                    var verticalMargin = compoundNode.paddingTop;\n                    // Adjust the positions of nodes wrt its compound\n                    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n                });\n            };\n            CoSELayout.prototype.getToBeTiled = function(node) {\n                var id = node.id;\n                //firstly check the previous results\n                if (this.toBeTiled[id] != null) {\n                    return this.toBeTiled[id];\n                }\n                //only compound nodes are to be tiled\n                var childGraph = node.getChild();\n                if (childGraph == null) {\n                    this.toBeTiled[id] = false;\n                    return false;\n                }\n                var children = childGraph.getNodes(); // Get the children nodes\n                //a compound node is not to be tiled if all of its compound children are not to be tiled\n                for(var i = 0; i < children.length; i++){\n                    var theChild = children[i];\n                    if (this.getNodeDegree(theChild) > 0) {\n                        this.toBeTiled[id] = false;\n                        return false;\n                    }\n                    //pass the children not having the compound structure\n                    if (theChild.getChild() == null) {\n                        this.toBeTiled[theChild.id] = false;\n                        continue;\n                    }\n                    if (!this.getToBeTiled(theChild)) {\n                        this.toBeTiled[id] = false;\n                        return false;\n                    }\n                }\n                this.toBeTiled[id] = true;\n                return true;\n            };\n            // Get degree of a node depending of its edges and independent of its children\n            CoSELayout.prototype.getNodeDegree = function(node) {\n                var id = node.id;\n                var edges = node.getEdges();\n                var degree = 0;\n                // For the edges connected\n                for(var i = 0; i < edges.length; i++){\n                    var edge = edges[i];\n                    if (edge.getSource().id !== edge.getTarget().id) {\n                        degree = degree + 1;\n                    }\n                }\n                return degree;\n            };\n            // Get degree of a node with its children\n            CoSELayout.prototype.getNodeDegreeWithChildren = function(node) {\n                var degree = this.getNodeDegree(node);\n                if (node.getChild() == null) {\n                    return degree;\n                }\n                var children = node.getChild().getNodes();\n                for(var i = 0; i < children.length; i++){\n                    var child = children[i];\n                    degree += this.getNodeDegreeWithChildren(child);\n                }\n                return degree;\n            };\n            CoSELayout.prototype.performDFSOnCompounds = function() {\n                this.compoundOrder = [];\n                this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n            };\n            CoSELayout.prototype.fillCompexOrderByDFS = function(children) {\n                for(var i = 0; i < children.length; i++){\n                    var child = children[i];\n                    if (child.getChild() != null) {\n                        this.fillCompexOrderByDFS(child.getChild().getNodes());\n                    }\n                    if (this.getToBeTiled(child)) {\n                        this.compoundOrder.push(child);\n                    }\n                }\n            };\n            /**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/ CoSELayout.prototype.adjustLocations = function(organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n                x += compoundHorizontalMargin;\n                y += compoundVerticalMargin;\n                var left = x;\n                for(var i = 0; i < organization.rows.length; i++){\n                    var row = organization.rows[i];\n                    x = left;\n                    var maxHeight = 0;\n                    for(var j = 0; j < row.length; j++){\n                        var lnode = row[j];\n                        lnode.rect.x = x; // + lnode.rect.width / 2;\n                        lnode.rect.y = y; // + lnode.rect.height / 2;\n                        x += lnode.rect.width + organization.horizontalPadding;\n                        if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n                    }\n                    y += maxHeight + organization.verticalPadding;\n                }\n            };\n            CoSELayout.prototype.tileCompoundMembers = function(childGraphMap, idToNode) {\n                var self = this;\n                this.tiledMemberPack = [];\n                Object.keys(childGraphMap).forEach(function(id) {\n                    // Get the compound node\n                    var compoundNode = idToNode[id];\n                    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                    compoundNode.rect.width = self.tiledMemberPack[id].width;\n                    compoundNode.rect.height = self.tiledMemberPack[id].height;\n                });\n            };\n            CoSELayout.prototype.tileNodes = function(nodes, minWidth) {\n                var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n                var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n                var organization = {\n                    rows: [],\n                    rowWidth: [],\n                    rowHeight: [],\n                    width: 0,\n                    height: minWidth,\n                    verticalPadding: verticalPadding,\n                    horizontalPadding: horizontalPadding\n                };\n                // Sort the nodes in ascending order of their areas\n                nodes.sort(function(n1, n2) {\n                    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n                    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n                    return 0;\n                });\n                // Create the organization -> tile members\n                for(var i = 0; i < nodes.length; i++){\n                    var lNode = nodes[i];\n                    if (organization.rows.length == 0) {\n                        this.insertNodeToRow(organization, lNode, 0, minWidth);\n                    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n                        this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n                    } else {\n                        this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n                    }\n                    this.shiftToLastRow(organization);\n                }\n                return organization;\n            };\n            CoSELayout.prototype.insertNodeToRow = function(organization, node, rowIndex, minWidth) {\n                var minCompoundSize = minWidth;\n                // Add new row if needed\n                if (rowIndex == organization.rows.length) {\n                    var secondDimension = [];\n                    organization.rows.push(secondDimension);\n                    organization.rowWidth.push(minCompoundSize);\n                    organization.rowHeight.push(0);\n                }\n                // Update row width\n                var w = organization.rowWidth[rowIndex] + node.rect.width;\n                if (organization.rows[rowIndex].length > 0) {\n                    w += organization.horizontalPadding;\n                }\n                organization.rowWidth[rowIndex] = w;\n                // Update compound width\n                if (organization.width < w) {\n                    organization.width = w;\n                }\n                // Update height\n                var h = node.rect.height;\n                if (rowIndex > 0) h += organization.verticalPadding;\n                var extraHeight = 0;\n                if (h > organization.rowHeight[rowIndex]) {\n                    extraHeight = organization.rowHeight[rowIndex];\n                    organization.rowHeight[rowIndex] = h;\n                    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n                }\n                organization.height += extraHeight;\n                // Insert node\n                organization.rows[rowIndex].push(node);\n            };\n            //Scans the rows of an organization and returns the one with the min width\n            CoSELayout.prototype.getShortestRowIndex = function(organization) {\n                var r = -1;\n                var min = Number.MAX_VALUE;\n                for(var i = 0; i < organization.rows.length; i++){\n                    if (organization.rowWidth[i] < min) {\n                        r = i;\n                        min = organization.rowWidth[i];\n                    }\n                }\n                return r;\n            };\n            //Scans the rows of an organization and returns the one with the max width\n            CoSELayout.prototype.getLongestRowIndex = function(organization) {\n                var r = -1;\n                var max = Number.MIN_VALUE;\n                for(var i = 0; i < organization.rows.length; i++){\n                    if (organization.rowWidth[i] > max) {\n                        r = i;\n                        max = organization.rowWidth[i];\n                    }\n                }\n                return r;\n            };\n            /**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/ CoSELayout.prototype.canAddHorizontal = function(organization, extraWidth, extraHeight) {\n                var sri = this.getShortestRowIndex(organization);\n                if (sri < 0) {\n                    return true;\n                }\n                var min = organization.rowWidth[sri];\n                if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n                var hDiff = 0;\n                // Adding to an existing row\n                if (organization.rowHeight[sri] < extraHeight) {\n                    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n                }\n                var add_to_row_ratio;\n                if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n                    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n                } else {\n                    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n                }\n                // Adding a new row for this node\n                hDiff = extraHeight + organization.verticalPadding;\n                var add_new_row_ratio;\n                if (organization.width < extraWidth) {\n                    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n                } else {\n                    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n                }\n                if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n                if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n                return add_to_row_ratio < add_new_row_ratio;\n            };\n            //If moving the last node from the longest row and adding it to the last\n            //row makes the bounding box smaller, do it.\n            CoSELayout.prototype.shiftToLastRow = function(organization) {\n                var longest = this.getLongestRowIndex(organization);\n                var last = organization.rowWidth.length - 1;\n                var row = organization.rows[longest];\n                var node = row[row.length - 1];\n                var diff = node.width + organization.horizontalPadding;\n                // Check if there is enough space on the last row\n                if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n                    // Remove the last element of the longest row\n                    row.splice(-1, 1);\n                    // Push it to the last row\n                    organization.rows[last].push(node);\n                    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n                    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n                    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n                    // Update heights of the organization\n                    var maxHeight = Number.MIN_VALUE;\n                    for(var i = 0; i < row.length; i++){\n                        if (row[i].height > maxHeight) maxHeight = row[i].height;\n                    }\n                    if (longest > 0) maxHeight += organization.verticalPadding;\n                    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                    organization.rowHeight[longest] = maxHeight;\n                    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n                    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                    organization.height += finalTotal - prevTotal;\n                    this.shiftToLastRow(organization);\n                }\n            };\n            CoSELayout.prototype.tilingPreLayout = function() {\n                if (CoSEConstants.TILE) {\n                    // Find zero degree nodes and create a compound for each level\n                    this.groupZeroDegreeMembers();\n                    // Tile and clear children of each compound\n                    this.clearCompounds();\n                    // Separately tile and clear zero degree nodes for each level\n                    this.clearZeroDegreeMembers();\n                }\n            };\n            CoSELayout.prototype.tilingPostLayout = function() {\n                if (CoSEConstants.TILE) {\n                    this.repopulateZeroDegreeMembers();\n                    this.repopulateCompounds();\n                }\n            };\n            // -----------------------------------------------------------------------------\n            // Section: Tree Reduction methods\n            // -----------------------------------------------------------------------------\n            // Reduce trees \n            CoSELayout.prototype.reduceTrees = function() {\n                var prunedNodesAll = [];\n                var containsLeaf = true;\n                var node;\n                while(containsLeaf){\n                    var allNodes = this.graphManager.getAllNodes();\n                    var prunedNodesInStepTemp = [];\n                    containsLeaf = false;\n                    for(var i = 0; i < allNodes.length; i++){\n                        node = allNodes[i];\n                        if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n                            prunedNodesInStepTemp.push([\n                                node,\n                                node.getEdges()[0],\n                                node.getOwner()\n                            ]);\n                            containsLeaf = true;\n                        }\n                    }\n                    if (containsLeaf == true) {\n                        var prunedNodesInStep = [];\n                        for(var j = 0; j < prunedNodesInStepTemp.length; j++){\n                            if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                                prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                                prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n                            }\n                        }\n                        prunedNodesAll.push(prunedNodesInStep);\n                        this.graphManager.resetAllNodes();\n                        this.graphManager.resetAllEdges();\n                    }\n                }\n                this.prunedNodesAll = prunedNodesAll;\n            };\n            // Grow tree one step \n            CoSELayout.prototype.growTree = function(prunedNodesAll) {\n                var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n                var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n                var nodeData;\n                for(var i = 0; i < prunedNodesInStep.length; i++){\n                    nodeData = prunedNodesInStep[i];\n                    this.findPlaceforPrunedNode(nodeData);\n                    nodeData[2].add(nodeData[0]);\n                    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n                }\n                prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n                this.graphManager.resetAllNodes();\n                this.graphManager.resetAllEdges();\n            };\n            // Find an appropriate position to replace pruned node, this method can be improved\n            CoSELayout.prototype.findPlaceforPrunedNode = function(nodeData) {\n                var gridForPrunedNode;\n                var nodeToConnect;\n                var prunedNode = nodeData[0];\n                if (prunedNode == nodeData[1].source) {\n                    nodeToConnect = nodeData[1].target;\n                } else {\n                    nodeToConnect = nodeData[1].source;\n                }\n                var startGridX = nodeToConnect.startX;\n                var finishGridX = nodeToConnect.finishX;\n                var startGridY = nodeToConnect.startY;\n                var finishGridY = nodeToConnect.finishY;\n                var upNodeCount = 0;\n                var downNodeCount = 0;\n                var rightNodeCount = 0;\n                var leftNodeCount = 0;\n                var controlRegions = [\n                    upNodeCount,\n                    rightNodeCount,\n                    downNodeCount,\n                    leftNodeCount\n                ];\n                if (startGridY > 0) {\n                    for(var i = startGridX; i <= finishGridX; i++){\n                        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n                    }\n                }\n                if (finishGridX < this.grid.length - 1) {\n                    for(var i = startGridY; i <= finishGridY; i++){\n                        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n                    }\n                }\n                if (finishGridY < this.grid[0].length - 1) {\n                    for(var i = startGridX; i <= finishGridX; i++){\n                        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n                    }\n                }\n                if (startGridX > 0) {\n                    for(var i = startGridY; i <= finishGridY; i++){\n                        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n                    }\n                }\n                var min = Integer.MAX_VALUE;\n                var minCount;\n                var minIndex;\n                for(var j = 0; j < controlRegions.length; j++){\n                    if (controlRegions[j] < min) {\n                        min = controlRegions[j];\n                        minCount = 1;\n                        minIndex = j;\n                    } else if (controlRegions[j] == min) {\n                        minCount++;\n                    }\n                }\n                if (minCount == 3 && min == 0) {\n                    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n                        gridForPrunedNode = 1;\n                    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 0;\n                    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 3;\n                    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 2;\n                    }\n                } else if (minCount == 2 && min == 0) {\n                    var random = Math.floor(Math.random() * 2);\n                    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n                        ;\n                        if (random == 0) {\n                            gridForPrunedNode = 0;\n                        } else {\n                            gridForPrunedNode = 1;\n                        }\n                    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n                        if (random == 0) {\n                            gridForPrunedNode = 0;\n                        } else {\n                            gridForPrunedNode = 2;\n                        }\n                    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n                        if (random == 0) {\n                            gridForPrunedNode = 0;\n                        } else {\n                            gridForPrunedNode = 3;\n                        }\n                    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n                        if (random == 0) {\n                            gridForPrunedNode = 1;\n                        } else {\n                            gridForPrunedNode = 2;\n                        }\n                    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n                        if (random == 0) {\n                            gridForPrunedNode = 1;\n                        } else {\n                            gridForPrunedNode = 3;\n                        }\n                    } else {\n                        if (random == 0) {\n                            gridForPrunedNode = 2;\n                        } else {\n                            gridForPrunedNode = 3;\n                        }\n                    }\n                } else if (minCount == 4 && min == 0) {\n                    var random = Math.floor(Math.random() * 4);\n                    gridForPrunedNode = random;\n                } else {\n                    gridForPrunedNode = minIndex;\n                }\n                if (gridForPrunedNode == 0) {\n                    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n                } else if (gridForPrunedNode == 1) {\n                    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                } else if (gridForPrunedNode == 2) {\n                    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n                } else {\n                    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                }\n            };\n            module1.exports = CoSELayout;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_61761__) {\n            \"use strict\";\n            var coseBase = {};\n            coseBase.layoutBase = __nested_webpack_require_61761__(0);\n            coseBase.CoSEConstants = __nested_webpack_require_61761__(1);\n            coseBase.CoSEEdge = __nested_webpack_require_61761__(2);\n            coseBase.CoSEGraph = __nested_webpack_require_61761__(3);\n            coseBase.CoSEGraphManager = __nested_webpack_require_61761__(4);\n            coseBase.CoSELayout = __nested_webpack_require_61761__(6);\n            coseBase.CoSENode = __nested_webpack_require_61761__(5);\n            module1.exports = coseBase;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29zZS1iYXNlL2Nvc2UtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdELFFBQVFHLG1CQUFPQSxDQUFDLG9FQUFhO1NBQzFDLEVBSzJDO0FBQ2pELEdBQUcsSUFBSSxFQUFFLFNBQVNHLDZCQUE2QjtJQUMvQyxPQUFnQixNQUFILEdBQUksU0FBU0MsT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsOEJBQW1CQSxDQUFDQyxRQUFRO1lBQy9DLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUFFO2dCQUMxQyxNQUFNLEdBQU0sT0FBT0YsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQ1QsT0FBTztZQUNyRCxNQUFNLEdBQUs7WUFDWCxNQUFNLEdBQUssa0RBQWtEO1lBQzdELE1BQU0sR0FBSyxJQUFJQyxVQUFTTSxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO2dCQUNyRCxNQUFNLEdBQU1DLEdBQUdEO2dCQUNmLE1BQU0sR0FBTUUsR0FBRztnQkFDZixNQUFNLEdBQU1YLFNBQVMsQ0FBQztZQUNYO1lBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLTSxPQUFPLENBQUNHLFNBQVMsQ0FBQ0csSUFBSSxDQUFDWCxRQUFPRCxPQUFPLEVBQUVDLFNBQVFBLFFBQU9ELE9BQU8sRUFBRVEsOEJBQW1CQTtZQUM3RixNQUFNLEdBQ04sTUFBTSxHQUFLLDRCQUE0QjtZQUN2QyxNQUFNLEdBQUtQLFFBQU9VLENBQUMsR0FBRztZQUN0QixNQUFNLEdBQ04sTUFB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UUFBUSxLQUFLLEdBQUdwQixjQUFjbk0sVUFBVTtnQkFDOUssT0FBTyxJQUFJa00scUJBQXFCLEdBQUc7b0JBQ2pDRSxXQUFXM0gsU0FBUyxDQUFDMEgsY0FBY3JNLFVBQVUsSUFBSXFNLGNBQWNuTSxVQUFVLEtBQUttTSxjQUFjbUIsU0FBUyxLQUFLLElBQUlwWSxrQkFBa0JLLG1CQUFtQixHQUFHNlcsV0FBV2tCLFNBQVMsS0FBSztnQkFDakwsT0FBTztvQkFDTGxCLFdBQVczSCxTQUFTLENBQUMwSCxjQUFjck0sVUFBVSxLQUFLcU0sY0FBY29CLFFBQVEsS0FBSyxJQUFJclksa0JBQWtCSyxtQkFBbUIsR0FBRzZXLFdBQVdtQixRQUFRLEtBQUssR0FBR3BCLGNBQWNuTSxVQUFVO2dCQUM5SztZQUNGO1lBRUFoTixRQUFPRCxPQUFPLEdBQUdrSDtRQUVqQixHQUFHLEdBQUc7UUFDTixLQUFLLEdBQ0wsR0FBRyxHQUFJLFNBQVNqSCxPQUFNLEVBQUVELFFBQU8sRUFBRVEsZ0NBQW1CO1lBRXBEO1lBR0EsSUFBSWlhLFdBQVcsQ0FBQztZQUVoQkEsU0FBU0MsVUFBVSxHQUFHbGEsZ0NBQW1CQSxDQUFDO1lBQzFDaWEsU0FBU3JZLGFBQWEsR0FBRzVCLGdDQUFtQkEsQ0FBQztZQUM3Q2lhLFNBQVMxWCxRQUFRLEdBQUd2QyxnQ0FBbUJBLENBQUM7WUFDeENpYSxTQUFTcFgsU0FBUyxHQUFHN0MsZ0NBQW1CQSxDQUFDO1lBQ3pDaWEsU0FBUy9XLGdCQUFnQixHQUFHbEQsZ0NBQW1CQSxDQUFDO1lBQ2hEaWEsU0FBU3ZULFVBQVUsR0FBRzFHLGdDQUFtQkEsQ0FBQztZQUMxQ2lhLFNBQVMzVyxRQUFRLEdBQUd0RCxnQ0FBbUJBLENBQUM7WUFFeENQLFFBQU9ELE9BQU8sR0FBR3lhO1FBRWpCLEdBQUcsR0FBRztLQUNJO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXJvLW5ldHdvcmstd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzP2Y4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibGF5b3V0LWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsYXlvdXQtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJsYXlvdXRCYXNlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNyk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Q29uc3RhbnRzO1xuXG5mdW5jdGlvbiBDb1NFQ29uc3RhbnRzKCkge31cblxuLy9Db1NFQ29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBGRExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dENvbnN0YW50cykge1xuICBDb1NFQ29uc3RhbnRzW3Byb3BdID0gRkRMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkNvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfTVVMVElfTEVWRUxfU0NBTElORyA9IGZhbHNlO1xuQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTiA9IDYwO1xuQ29TRUNvbnN0YW50cy5USUxFID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IDEwO1xuQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IGZhbHNlOyAvLyBtYWtlIHRoaXMgdHJ1ZSB3aGVuIGNvc2UgaXMgdXNlZCBpbmNyZW1lbnRhbGx5IGFzIGEgcGFydCBvZiBvdGhlciBub24taW5jcmVtZW50YWwgbGF5b3V0XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUNvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGRExheW91dEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0RWRnZTtcblxuZnVuY3Rpb24gQ29TRUVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIEZETGF5b3V0RWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG59XG5cbkNvU0VFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXRFZGdlLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0RWRnZSkge1xuICBDb1NFRWRnZVtwcm9wXSA9IEZETGF5b3V0RWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFRWRnZTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxHcmFwaDtcblxuZnVuY3Rpb24gQ29TRUdyYXBoKHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCkge1xuICBMR3JhcGguY2FsbCh0aGlzLCBwYXJlbnQsIGdyYXBoTWdyLCB2R3JhcGgpO1xufVxuXG5Db1NFR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGgucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoKSB7XG4gIENvU0VHcmFwaFtwcm9wXSA9IExHcmFwaFtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGg7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTEdyYXBoTWFuYWdlcjtcblxuZnVuY3Rpb24gQ29TRUdyYXBoTWFuYWdlcihsYXlvdXQpIHtcbiAgTEdyYXBoTWFuYWdlci5jYWxsKHRoaXMsIGxheW91dCk7XG59XG5cbkNvU0VHcmFwaE1hbmFnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhNYW5hZ2VyLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE1hbmFnZXIpIHtcbiAgQ29TRUdyYXBoTWFuYWdlcltwcm9wXSA9IExHcmFwaE1hbmFnZXJbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUdyYXBoTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGRExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Tm9kZTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuSU1hdGg7XG5cbmZ1bmN0aW9uIENvU0VOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZS5jYWxsKHRoaXMsIGdtLCBsb2MsIHNpemUsIHZOb2RlKTtcbn1cblxuQ29TRU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGRExheW91dE5vZGUucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXROb2RlKSB7XG4gIENvU0VOb2RlW3Byb3BdID0gRkRMYXlvdXROb2RlW3Byb3BdO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxheW91dCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldExheW91dCgpO1xuICB0aGlzLmRpc3BsYWNlbWVudFggPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5ub09mQ2hpbGRyZW47XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WCkgPiBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRYID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCAqIElNYXRoLnNpZ24odGhpcy5kaXNwbGFjZW1lbnRYKTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFkpID4gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WSA9IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQgKiBJTWF0aC5zaWduKHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cblxuICAvLyBhIHNpbXBsZSBub2RlLCBqdXN0IG1vdmUgaXRcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIHRoaXMubW92ZUJ5KHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuICAvLyBhbiBlbXB0eSBjb21wb3VuZCBub2RlLCBhZ2FpbiBqdXN0IG1vdmUgaXRcbiAgZWxzZSBpZiAodGhpcy5jaGlsZC5nZXROb2RlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aGlzLm1vdmVCeSh0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gICAgfVxuICAgIC8vIG5vbi1lbXB0eSBjb21wb3VuZCBub2RlLCBwcm9wb2dhdGUgbW92ZW1lbnQgdG8gY2hpbGRyZW4gYXMgd2VsbFxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4odGhpcy5kaXNwbGFjZW1lbnRYLCB0aGlzLmRpc3BsYWNlbWVudFkpO1xuICAgICAgfVxuXG4gIGxheW91dC50b3RhbERpc3BsYWNlbWVudCArPSBNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpICsgTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKTtcblxuICB0aGlzLnNwcmluZ0ZvcmNlWCA9IDA7XG4gIHRoaXMuc3ByaW5nRm9yY2VZID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVggPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVggPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuID0gZnVuY3Rpb24gKGRYLCBkWSkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgdmFyIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlLm1vdmVCeShkWCwgZFkpO1xuICAgICAgbm9kZS5kaXNwbGFjZW1lbnRYICs9IGRYO1xuICAgICAgbm9kZS5kaXNwbGFjZW1lbnRZICs9IGRZO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4oZFgsIGRZKTtcbiAgICB9XG4gIH1cbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5zZXRQcmVkMSA9IGZ1bmN0aW9uIChwcmVkMSkge1xuICB0aGlzLnByZWQxID0gcHJlZDE7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0UHJlZDEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQyO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLm5leHQgPSBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByb2Nlc3NlZCA9IGZ1bmN0aW9uIChwcm9jZXNzZWQpIHtcbiAgdGhpcy5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuaXNQcm9jZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcm9jZXNzZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VOb2RlO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEZETGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5GRExheW91dDtcbnZhciBDb1NFR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBDb1NFR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDb1NFRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Q29uc3RhbnRzO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTGF5b3V0Q29uc3RhbnRzO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Qb2ludDtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLlBvaW50RDtcbnZhciBMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxheW91dDtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5JbnRlZ2VyO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuSUdlb21ldHJ5O1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTEdyYXBoO1xudmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuVHJhbnNmb3JtO1xuXG5mdW5jdGlvbiBDb1NFTGF5b3V0KCkge1xuICBGRExheW91dC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudG9CZVRpbGVkID0ge307IC8vIE1lbW9yaXplIGlmIGEgbm9kZSBpcyB0byBiZSB0aWxlZCBvciBpcyB0aWxlZFxufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dCkge1xuICBDb1NFTGF5b3V0W3Byb3BdID0gRkRMYXlvdXRbcHJvcF07XG59XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IENvU0VHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IENvU0VHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld05vZGUgPSBmdW5jdGlvbiAodk5vZGUpIHtcbiAgcmV0dXJuIG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlciwgdk5vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IENvU0VFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICBpZiAoQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIDwgMTApIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cblxuICAgIHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiA9IENvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIO1xuICAgIHRoaXMucmVwdWxzaW9uQ29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSDtcbiAgICB0aGlzLmdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSDtcbiAgICB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIO1xuICAgIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgICB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdHJlZSByZWR1Y3Rpb24gc3VwcG9ydFxuICAgIHRoaXMucHJ1bmVkTm9kZXNBbGwgPSBbXTtcbiAgICB0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgLy8gdmFyaWFibGVzIGZvciBjb29saW5nXG4gICAgdGhpcy5jb29saW5nQ3ljbGUgPSAwO1xuICAgIHRoaXMubWF4Q29vbGluZ0N5Y2xlID0gdGhpcy5tYXhJdGVyYXRpb25zIC8gRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EO1xuICAgIHRoaXMuZmluYWxUZW1wZXJhdHVyZSA9IEZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCAvIHRoaXMubWF4SXRlcmF0aW9ucztcbiAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IDE7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICBpZiAoY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50cygpO1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWwgPSAwO1xuICByZXR1cm4gdGhpcy5jbGFzc2ljTGF5b3V0KCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGFzc2ljTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5vZGVzV2l0aEdyYXZpdHkgPSB0aGlzLmNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8oKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24odGhpcy5ub2Rlc1dpdGhHcmF2aXR5KTtcbiAgdGhpcy5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjSW5jbHVzaW9uVHJlZURlcHRocygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgdGhpcy5jYWxjSWRlYWxFZGdlTGVuZ3RocygpO1xuXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHZhciBmb3Jlc3QgPSB0aGlzLmdldEZsYXRGb3Jlc3QoKTtcblxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgZmxhdCBhbmQgYSBmb3Jlc3RcbiAgICBpZiAoZm9yZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhZGlhbGx5KGZvcmVzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgbm90IGZsYXQgb3IgYSBmb3Jlc3RcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVkdWNlIHRoZSB0cmVlcyB3aGVuIGluY3JlbWVudGFsIG1vZGUgaXMgbm90IGVuYWJsZWQgYW5kIGdyYXBoIGlzIG5vdCBhIGZvcmVzdCBcbiAgICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gYWxsTm9kZXMuaGFzKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSgpO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIGluIGluY3JlbWVudGFsIG1vZGUgaWYgb25seSB0aGlzIGNvbnN0YW50IGlzIHNldCB0byB0cnVlIFxuICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5pbml0U3ByaW5nRW1iZWRkZXIoKTtcbiAgdGhpcy5ydW5TcHJpbmdFbWJlZGRlcigpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMrKztcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPT09IHRoaXMubWF4SXRlcmF0aW9ucyAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgPT0gMCAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5pc0NvbnZlcmdlZCgpKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvb2xpbmdDeWNsZSsrO1xuXG4gICAgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAwKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkcmFmdFwiXG4gICAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IHRoaXMuY29vbGluZ0N5Y2xlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXlvdXRRdWFsaXR5ID09IDEpIHtcbiAgICAgIC8vIHF1YWxpdHkgLSBcImRlZmF1bHRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZSAvIDM7XG4gICAgfVxuXG4gICAgLy8gY29vbGluZyBzY2hlZHVsZSBpcyBiYXNlZCBvbiBodHRwOi8vd3d3LmJ0bHVrZS5jb20vc2ltYW5mMS5odG1sIC0+IGNvb2xpbmcgc2NoZWR1bGUgM1xuICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSBNYXRoLnBvdyh0aGlzLmNvb2xpbmdDeWNsZSwgTWF0aC5sb2coMTAwICogKHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSB0aGlzLmZpbmFsVGVtcGVyYXR1cmUpKSAvIE1hdGgubG9nKHRoaXMubWF4Q29vbGluZ0N5Y2xlKSkgLyAxMDAgKiB0aGlzLmNvb2xpbmdBZGp1c3RlciwgdGhpcy5maW5hbFRlbXBlcmF0dXJlKTtcbiAgICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IE1hdGguY2VpbCh0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgKiBNYXRoLnNxcnQodGhpcy5jb29saW5nRmFjdG9yKSk7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyB3aGlsZSB0cmVlIGlzIGdyb3dpbmcgYWdhaW4gXG4gIGlmICh0aGlzLmlzVHJlZUdyb3dpbmcpIHtcbiAgICBpZiAodGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgdGhpcy5ncm93VHJlZSh0aGlzLnBydW5lZE5vZGVzQWxsKTtcbiAgICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgICB2YXIgYWxsTm9kZXMgPSBuZXcgU2V0KHRoaXMuZ2V0QWxsTm9kZXMoKSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG5cbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zKys7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyBhZnRlciBncm93dGggaXMgZmluaXNoZWRcbiAgaWYgKHRoaXMuaXNHcm93dGhGaW5pc2hlZCkge1xuICAgIGlmICh0aGlzLmlzQ29udmVyZ2VkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cbiAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMICogKCgxMDAgLSB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucykgLyAxMDApO1xuICAgIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zKys7XG4gIH1cblxuICB2YXIgZ3JpZFVwZGF0ZUFsbG93ZWQgPSAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQ7XG4gIHZhciBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlID0gdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAxICYmIHRoaXMuaXNUcmVlR3Jvd2luZyB8fCB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyAlIDEwID09IDEgJiYgdGhpcy5pc0dyb3d0aEZpbmlzaGVkO1xuXG4gIHRoaXMudG90YWxEaXNwbGFjZW1lbnQgPSAwO1xuICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgdGhpcy5jYWxjU3ByaW5nRm9yY2VzKCk7XG4gIHRoaXMuY2FsY1JlcHVsc2lvbkZvcmNlcyhncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSk7XG4gIHRoaXMuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMoKTtcbiAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgdGhpcy5hbmltYXRlKCk7XG5cbiAgcmV0dXJuIGZhbHNlOyAvLyBMYXlvdXQgaXMgbm90IGVuZGVkIHlldCByZXR1cm4gZmFsc2Vcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFBvc2l0aW9uc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG4gIHZhciBwRGF0YSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlY3QgPSBhbGxOb2Rlc1tpXS5yZWN0O1xuICAgIHZhciBpZCA9IGFsbE5vZGVzW2ldLmlkO1xuICAgIHBEYXRhW2lkXSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHg6IHJlY3QuZ2V0Q2VudGVyWCgpLFxuICAgICAgeTogcmVjdC5nZXRDZW50ZXJZKCksXG4gICAgICB3OiByZWN0LndpZHRoLFxuICAgICAgaDogcmVjdC5oZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHBEYXRhO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucnVuU3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW5pdGlhbEFuaW1hdGlvblBlcmlvZCA9IDI1O1xuICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IHRoaXMuaW5pdGlhbEFuaW1hdGlvblBlcmlvZDtcbiAgdmFyIGxheW91dEVuZGVkID0gZmFsc2U7XG5cbiAgLy8gSWYgYW1pbmF0ZSBvcHRpb24gaXMgJ2R1cmluZycgc2lnbmFsIHRoYXQgbGF5b3V0IGlzIHN1cHBvc2VkIHRvIHN0YXJ0IGl0ZXJhdGluZ1xuICBpZiAoRkRMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9PT0gJ2R1cmluZycpIHtcbiAgICB0aGlzLmVtaXQoJ2xheW91dHN0YXJ0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbWluYXRlIG9wdGlvbiBpcyAnZHVyaW5nJyB0aWNrKCkgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gaW5kZXguanNcbiAgICB3aGlsZSAoIWxheW91dEVuZGVkKSB7XG4gICAgICBsYXlvdXRFbmRlZCA9IHRoaXMudGljaygpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvblRvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgdmFyIGdyYXBoO1xuXG4gIHZhciBncmFwaHMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRHcmFwaHMoKTtcbiAgdmFyIHNpemUgPSBncmFwaHMubGVuZ3RoO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGdyYXBoID0gZ3JhcGhzW2ldO1xuXG4gICAgZ3JhcGgudXBkYXRlQ29ubmVjdGVkKCk7XG5cbiAgICBpZiAoIWdyYXBoLmlzQ29ubmVjdGVkKSB7XG4gICAgICBub2RlTGlzdCA9IG5vZGVMaXN0LmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZUxpc3Q7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgZWRnZXMgPSBlZGdlcy5jb25jYXQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKSk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZSkpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdmFyIHRhcmdldCA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgIGlmIChzb3VyY2UgPT0gdGFyZ2V0KSB7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgZWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKGVkZ2UpO1xuICAgICAgICB2aXNpdGVkLmFkZChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuXG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHNvdXJjZS5nZXRFZGdlTGlzdFRvTm9kZSh0YXJnZXQpKTtcbiAgICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQodGFyZ2V0LmdldEVkZ2VMaXN0VG9Ob2RlKHNvdXJjZSkpO1xuXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZUxpc3RbMF0pKSB7XG4gICAgICAgICAgaWYgKGVkZ2VMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVkZ2VMaXN0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIHZhciBtdWx0aUVkZ2UgPSBlZGdlTGlzdFtrXTtcbiAgICAgICAgICAgICAgbXVsdGlFZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgICAgICAgIHRoaXMuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMobXVsdGlFZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRnZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZC5zaXplID09IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFkaWFsbHkgPSBmdW5jdGlvbiAoZm9yZXN0KSB7XG4gIC8vIFdlIHRpbGUgdGhlIHRyZWVzIHRvIGEgZ3JpZCByb3cgYnkgcm93OyBmaXJzdCB0cmVlIHN0YXJ0cyBhdCAoMCwwKVxuICB2YXIgY3VycmVudFN0YXJ0aW5nUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gIHZhciBudW1iZXJPZkNvbHVtbnMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGZvcmVzdC5sZW5ndGgpKTtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBjdXJyZW50WSA9IDA7XG4gIHZhciBjdXJyZW50WCA9IDA7XG4gIHZhciBwb2ludCA9IG5ldyBQb2ludEQoMCwgMCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSAlIG51bWJlck9mQ29sdW1ucyA9PSAwKSB7XG4gICAgICAvLyBTdGFydCBvZiBhIG5ldyByb3csIG1ha2UgdGhlIHggY29vcmRpbmF0ZSAwLCBpbmNyZW1lbnQgdGhlXG4gICAgICAvLyB5IGNvb3JkaW5hdGUgd2l0aCB0aGUgbWF4IGhlaWdodCBvZiB0aGUgcHJldmlvdXMgcm93XG4gICAgICBjdXJyZW50WCA9IDA7XG4gICAgICBjdXJyZW50WSA9IGhlaWdodDtcblxuICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICBjdXJyZW50WSArPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT047XG4gICAgICB9XG5cbiAgICAgIGhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHRyZWUgPSBmb3Jlc3RbaV07XG5cbiAgICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHRyZWVcbiAgICB2YXIgY2VudGVyTm9kZSA9IExheW91dC5maW5kQ2VudGVyT2ZUcmVlKHRyZWUpO1xuXG4gICAgLy8gU2V0IHRoZSBzdGFyaW5nIHBvaW50IG9mIHRoZSBuZXh0IHRyZWVcbiAgICBjdXJyZW50U3RhcnRpbmdQb2ludC54ID0gY3VycmVudFg7XG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueSA9IGN1cnJlbnRZO1xuXG4gICAgLy8gRG8gYSByYWRpYWwgbGF5b3V0IHN0YXJ0aW5nIHdpdGggdGhlIGNlbnRlclxuICAgIHBvaW50ID0gQ29TRUxheW91dC5yYWRpYWxMYXlvdXQodHJlZSwgY2VudGVyTm9kZSwgY3VycmVudFN0YXJ0aW5nUG9pbnQpO1xuXG4gICAgaWYgKHBvaW50LnkgPiBoZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IocG9pbnQueSk7XG4gICAgfVxuXG4gICAgY3VycmVudFggPSBNYXRoLmZsb29yKHBvaW50LnggKyBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04pO1xuICB9XG5cbiAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RChMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggLSBwb2ludC54IC8gMiwgTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZIC0gcG9pbnQueSAvIDIpKTtcbn07XG5cbkNvU0VMYXlvdXQucmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKHRyZWUsIGNlbnRlck5vZGUsIHN0YXJ0aW5nUG9pbnQpIHtcbiAgdmFyIHJhZGlhbFNlcCA9IE1hdGgubWF4KHRoaXMubWF4RGlhZ29uYWxJblRyZWUodHJlZSksIENvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTik7XG4gIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGNlbnRlck5vZGUsIG51bGwsIDAsIDM1OSwgMCwgcmFkaWFsU2VwKTtcbiAgdmFyIGJvdW5kcyA9IExHcmFwaC5jYWxjdWxhdGVCb3VuZHModHJlZSk7XG5cbiAgdmFyIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgdHJhbnNmb3JtLnNldERldmljZU9yZ1goYm91bmRzLmdldE1pblgoKSk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdZKGJvdW5kcy5nZXRNaW5ZKCkpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdYKHN0YXJ0aW5nUG9pbnQueCk7XG4gIHRyYW5zZm9ybS5zZXRXb3JsZE9yZ1koc3RhcnRpbmdQb2ludC55KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XG4gICAgbm9kZS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZhciBib3R0b21SaWdodCA9IG5ldyBQb2ludEQoYm91bmRzLmdldE1heFgoKSwgYm91bmRzLmdldE1heFkoKSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybS5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoYm90dG9tUmlnaHQpO1xufTtcblxuQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50T2ZOb2RlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlzdGFuY2UsIHJhZGlhbFNlcGFyYXRpb24pIHtcbiAgLy8gRmlyc3QsIHBvc2l0aW9uIHRoaXMgbm9kZSBieSBmaW5kaW5nIGl0cyBhbmdsZS5cbiAgdmFyIGhhbGZJbnRlcnZhbCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgKyAxKSAvIDI7XG5cbiAgaWYgKGhhbGZJbnRlcnZhbCA8IDApIHtcbiAgICBoYWxmSW50ZXJ2YWwgKz0gMTgwO1xuICB9XG5cbiAgdmFyIG5vZGVBbmdsZSA9IChoYWxmSW50ZXJ2YWwgKyBzdGFydEFuZ2xlKSAlIDM2MDtcbiAgdmFyIHRldGEgPSBub2RlQW5nbGUgKiBJR2VvbWV0cnkuVFdPX1BJIC8gMzYwO1xuXG4gIC8vIE1ha2UgcG9sYXIgdG8gamF2YSBjb3JkaW5hdGUgY29udmVyc2lvbi5cbiAgdmFyIGNvc190ZXRhID0gTWF0aC5jb3ModGV0YSk7XG4gIHZhciB4XyA9IGRpc3RhbmNlICogTWF0aC5jb3ModGV0YSk7XG4gIHZhciB5XyA9IGRpc3RhbmNlICogTWF0aC5zaW4odGV0YSk7XG5cbiAgbm9kZS5zZXRDZW50ZXIoeF8sIHlfKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzXG4gIC8vIGZ1bmN0aW9uLlxuICB2YXIgbmVpZ2hib3JFZGdlcyA9IFtdO1xuICBuZWlnaGJvckVkZ2VzID0gbmVpZ2hib3JFZGdlcy5jb25jYXQobm9kZS5nZXRFZGdlcygpKTtcbiAgdmFyIGNoaWxkQ291bnQgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICB2YXIgYnJhbmNoQ291bnQgPSAwO1xuXG4gIHZhciBpbmNFZGdlc0NvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG4gIHZhciBzdGFydEluZGV4O1xuXG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHBhcmVudE9mTm9kZSk7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGVkZ2VzLCBwcnVuZSB0aGVtIHVudGlsIHRoZXJlIHJlbWFpbnMgb25seSBvbmVcbiAgLy8gZWRnZS5cbiAgd2hpbGUgKGVkZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAvL25laWdoYm9yRWRnZXMucmVtb3ZlKGVkZ2VzLnJlbW92ZSgwKSk7XG4gICAgdmFyIHRlbXAgPSBlZGdlc1swXTtcbiAgICBlZGdlcy5zcGxpY2UoMCwgMSk7XG4gICAgdmFyIGluZGV4ID0gbmVpZ2hib3JFZGdlcy5pbmRleE9mKHRlbXApO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBuZWlnaGJvckVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGluY0VkZ2VzQ291bnQtLTtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICAvL2Fzc2VydCBlZGdlcy5sZW5ndGggPT0gMTtcbiAgICBzdGFydEluZGV4ID0gKG5laWdoYm9yRWRnZXMuaW5kZXhPZihlZGdlc1swXSkgKyAxKSAlIGluY0VkZ2VzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRJbmRleCA9IDA7XG4gIH1cblxuICB2YXIgc3RlcEFuZ2xlID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIGNoaWxkQ291bnQ7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGJyYW5jaENvdW50ICE9IGNoaWxkQ291bnQ7IGkgPSArK2kgJSBpbmNFZGdlc0NvdW50KSB7XG4gICAgdmFyIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZXNbaV0uZ2V0T3RoZXJFbmQobm9kZSk7XG5cbiAgICAvLyBEb24ndCBiYWNrIHRyYXZlcnNlIHRvIHJvb3Qgbm9kZSBpbiBjdXJyZW50IHRyZWUuXG4gICAgaWYgKGN1cnJlbnROZWlnaGJvciA9PSBwYXJlbnRPZk5vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0YXJ0QW5nbGUgPSAoc3RhcnRBbmdsZSArIGJyYW5jaENvdW50ICogc3RlcEFuZ2xlKSAlIDM2MDtcbiAgICB2YXIgY2hpbGRFbmRBbmdsZSA9IChjaGlsZFN0YXJ0QW5nbGUgKyBzdGVwQW5nbGUpICUgMzYwO1xuXG4gICAgQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQoY3VycmVudE5laWdoYm9yLCBub2RlLCBjaGlsZFN0YXJ0QW5nbGUsIGNoaWxkRW5kQW5nbGUsIGRpc3RhbmNlICsgcmFkaWFsU2VwYXJhdGlvbiwgcmFkaWFsU2VwYXJhdGlvbik7XG5cbiAgICBicmFuY2hDb3VudCsrO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0Lm1heERpYWdvbmFsSW5UcmVlID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgdmFyIG1heERpYWdvbmFsID0gSW50ZWdlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIHZhciBkaWFnb25hbCA9IG5vZGUuZ2V0RGlhZ29uYWwoKTtcblxuICAgIGlmIChkaWFnb25hbCA+IG1heERpYWdvbmFsKSB7XG4gICAgICBtYXhEaWFnb25hbCA9IGRpYWdvbmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhEaWFnb25hbDtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZm9ybXVsYSBpcyAyIHggKGxldmVsICsgMSkgeCBpZGVhbEVkZ2VMZW5ndGhcbiAgcmV0dXJuIDIgKiAodGhpcy5sZXZlbCArIDEpICogdGhpcy5pZGVhbEVkZ2VMZW5ndGg7XG59O1xuXG4vLyBUaWxpbmcgbWV0aG9kc1xuXG4vLyBHcm91cCB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZCwgY3JlYXRlIGR1bW15IHBhcmVudHMgd2hlcmUgbmVlZGVkIGFuZCBmaWxsIG1lbWJlckdyb3VwcyBieSB0aGVpciBkdW1tcCBwYXJlbnQgaWQnc1xuQ29TRUxheW91dC5wcm90b3R5cGUuZ3JvdXBaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBhcnJheSBvZiBbcGFyZW50X2lkIHggb25lRGVncmVlTm9kZV9pZF1cbiAgdmFyIHRlbXBNZW1iZXJHcm91cHMgPSB7fTsgLy8gQSB0ZW1wb3JhcnkgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICB0aGlzLm1lbWJlckdyb3VwcyA9IHt9OyAvLyBBIG1hcCBvZiBkdW1teSBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHRoaXMuaWRUb0R1bW15Tm9kZSA9IHt9OyAvLyBBIG1hcCBvZiBpZCB0byBkdW1teSBub2RlIFxuXG4gIHZhciB6ZXJvRGVncmVlID0gW107IC8vIExpc3Qgb2YgemVybyBkZWdyZWUgbm9kZXMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gRmlsbCB6ZXJvIGRlZ3JlZSBsaXN0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIC8vIElmIGEgbm9kZSBoYXMgemVybyBkZWdyZWUgYW5kIGl0cyBwYXJlbnQgaXMgbm90IHRvIGJlIHRpbGVkIGlmIGV4aXN0cyBhZGQgdGhhdCBub2RlIHRvIHplcm9EZWdyZXMgbGlzdFxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4obm9kZSkgPT09IDAgJiYgKHBhcmVudC5pZCA9PSB1bmRlZmluZWQgfHwgIXRoaXMuZ2V0VG9CZVRpbGVkKHBhcmVudCkpKSB7XG4gICAgICB6ZXJvRGVncmVlLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHplcm9EZWdyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHplcm9EZWdyZWVbaV07IC8vIFplcm8gZGVncmVlIG5vZGUgaXRzZWxmXG4gICAgdmFyIHBfaWQgPSBub2RlLmdldFBhcmVudCgpLmlkOyAvLyBQYXJlbnQgaWRcblxuICAgIGlmICh0eXBlb2YgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IFtdO1xuXG4gICAgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0uY29uY2F0KG5vZGUpOyAvLyBQdXNoIG5vZGUgdG8gdGhlIGxpc3QgYmVsb25ncyB0byBpdHMgcGFyZW50IGluIHRlbXBNZW1iZXJHcm91cHNcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhdCBsZWFzdCB0d28gbm9kZXMgYXQgYSBsZXZlbCwgY3JlYXRlIGEgZHVtbXkgY29tcG91bmQgZm9yIHRoZW1cbiAgT2JqZWN0LmtleXModGVtcE1lbWJlckdyb3VwcykuZm9yRWFjaChmdW5jdGlvbiAocF9pZCkge1xuICAgIGlmICh0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBkdW1teUNvbXBvdW5kSWQgPSBcIkR1bW15Q29tcG91bmRfXCIgKyBwX2lkOyAvLyBUaGUgaWQgb2YgZHVtbXkgY29tcG91bmQgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIHNvb25cbiAgICAgIHNlbGYubWVtYmVyR3JvdXBzW2R1bW15Q29tcG91bmRJZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdOyAvLyBBZGQgZHVtbXkgY29tcG91bmQgdG8gbWVtYmVyR3JvdXBzXG5cbiAgICAgIHZhciBwYXJlbnQgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdWzBdLmdldFBhcmVudCgpOyAvLyBUaGUgcGFyZW50IG9mIHplcm8gZGVncmVlIG5vZGVzIHdpbGwgYmUgdGhlIHBhcmVudCBvZiBuZXcgZHVtbXkgY29tcG91bmRcblxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgY29tcG91bmQgd2l0aCBjYWxjdWxhdGVkIGlkXG4gICAgICB2YXIgZHVtbXlDb21wb3VuZCA9IG5ldyBDb1NFTm9kZShzZWxmLmdyYXBoTWFuYWdlcik7XG4gICAgICBkdW1teUNvbXBvdW5kLmlkID0gZHVtbXlDb21wb3VuZElkO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nTGVmdCA9IHBhcmVudC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nUmlnaHQgPSBwYXJlbnQucGFkZGluZ1JpZ2h0IHx8IDA7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdCb3R0b20gPSBwYXJlbnQucGFkZGluZ0JvdHRvbSB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nVG9wID0gcGFyZW50LnBhZGRpbmdUb3AgfHwgMDtcblxuICAgICAgc2VsZi5pZFRvRHVtbXlOb2RlW2R1bW15Q29tcG91bmRJZF0gPSBkdW1teUNvbXBvdW5kO1xuXG4gICAgICB2YXIgZHVtbXlQYXJlbnRHcmFwaCA9IHNlbGYuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKHNlbGYubmV3R3JhcGgoKSwgZHVtbXlDb21wb3VuZCk7XG4gICAgICB2YXIgcGFyZW50R3JhcGggPSBwYXJlbnQuZ2V0Q2hpbGQoKTtcblxuICAgICAgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIHBhcmVudCB0aGUgZ3JhcGhcbiAgICAgIHBhcmVudEdyYXBoLmFkZChkdW1teUNvbXBvdW5kKTtcblxuICAgICAgLy8gRm9yIGVhY2ggemVybyBkZWdyZWUgbm9kZSBpbiB0aGlzIGxldmVsIHJlbW92ZSBpdCBmcm9tIGl0cyBwYXJlbnQgZ3JhcGggYW5kIGFkZCBpdCB0byB0aGUgZ3JhcGggb2YgZHVtbXkgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdW2ldO1xuXG4gICAgICAgIHBhcmVudEdyYXBoLnJlbW92ZShub2RlKTtcbiAgICAgICAgZHVtbXlQYXJlbnRHcmFwaC5hZGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsZWFyQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGRHcmFwaE1hcCA9IHt9O1xuICB2YXIgaWRUb05vZGUgPSB7fTtcblxuICAvLyBHZXQgY29tcG91bmQgb3JkZXJpbmcgYnkgZmluZGluZyB0aGUgaW5uZXIgb25lIGZpcnN0XG4gIHRoaXMucGVyZm9ybURGU09uQ29tcG91bmRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoOyBpKyspIHtcblxuICAgIGlkVG9Ob2RlW3RoaXMuY29tcG91bmRPcmRlcltpXS5pZF0gPSB0aGlzLmNvbXBvdW5kT3JkZXJbaV07XG4gICAgY2hpbGRHcmFwaE1hcFt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gW10uY29uY2F0KHRoaXMuY29tcG91bmRPcmRlcltpXS5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuXG4gICAgLy8gUmVtb3ZlIGNoaWxkcmVuIG9mIGNvbXBvdW5kc1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZSh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKSk7XG4gICAgdGhpcy5jb21wb3VuZE9yZGVyW2ldLmNoaWxkID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcblxuICAvLyBUaWxlIHRoZSByZW1vdmVkIGNoaWxkcmVuXG4gIHRoaXMudGlsZUNvbXBvdW5kTWVtYmVycyhjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhclplcm9EZWdyZWVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aWxlZFplcm9EZWdyZWVQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXModGhpcy5tZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmRcblxuICAgIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoc2VsZi5tZW1iZXJHcm91cHNbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIC8vIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZHVtbXkgY29tcG91bmQgYXMgY2FsY3VsYXRlZFxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uaGVpZ2h0O1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVDb21wb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbENvbXBvdW5kTm9kZSA9IHRoaXMuY29tcG91bmRPcmRlcltpXTtcbiAgICB2YXIgaWQgPSBsQ29tcG91bmROb2RlLmlkO1xuICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gbENvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG5cbiAgICB0aGlzLmFkanVzdExvY2F0aW9ucyh0aGlzLnRpbGVkTWVtYmVyUGFja1tpZF0sIGxDb21wb3VuZE5vZGUucmVjdC54LCBsQ29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4pO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRpbGVkUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjaztcblxuICBPYmplY3Qua2V5cyh0aWxlZFBhY2spLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmQgYnkgaXRzIGlkXG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQ7XG4gICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gY29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyB3cnQgaXRzIGNvbXBvdW5kXG4gICAgc2VsZi5hZGp1c3RMb2NhdGlvbnModGlsZWRQYWNrW2lkXSwgY29tcG91bmROb2RlLnJlY3QueCwgY29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4pO1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFRvQmVUaWxlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIC8vZmlyc3RseSBjaGVjayB0aGUgcHJldmlvdXMgcmVzdWx0c1xuICBpZiAodGhpcy50b0JlVGlsZWRbaWRdICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b0JlVGlsZWRbaWRdO1xuICB9XG5cbiAgLy9vbmx5IGNvbXBvdW5kIG5vZGVzIGFyZSB0byBiZSB0aWxlZFxuICB2YXIgY2hpbGRHcmFwaCA9IG5vZGUuZ2V0Q2hpbGQoKTtcbiAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IGNoaWxkR3JhcGguZ2V0Tm9kZXMoKTsgLy8gR2V0IHRoZSBjaGlsZHJlbiBub2Rlc1xuXG4gIC8vYSBjb21wb3VuZCBub2RlIGlzIG5vdCB0byBiZSB0aWxlZCBpZiBhbGwgb2YgaXRzIGNvbXBvdW5kIGNoaWxkcmVuIGFyZSBub3QgdG8gYmUgdGlsZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHRoaXMuZ2V0Tm9kZURlZ3JlZSh0aGVDaGlsZCkgPiAwKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL3Bhc3MgdGhlIGNoaWxkcmVuIG5vdCBoYXZpbmcgdGhlIGNvbXBvdW5kIHN0cnVjdHVyZVxuICAgIGlmICh0aGVDaGlsZC5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW3RoZUNoaWxkLmlkXSA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFRvQmVUaWxlZCh0aGVDaGlsZCkpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB0aGlzLnRvQmVUaWxlZFtpZF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEdldCBkZWdyZWUgb2YgYSBub2RlIGRlcGVuZGluZyBvZiBpdHMgZWRnZXMgYW5kIGluZGVwZW5kZW50IG9mIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXMoKTtcbiAgdmFyIGRlZ3JlZSA9IDA7XG5cbiAgLy8gRm9yIHRoZSBlZGdlcyBjb25uZWN0ZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgaWYgKGVkZ2UuZ2V0U291cmNlKCkuaWQgIT09IGVkZ2UuZ2V0VGFyZ2V0KCkuaWQpIHtcbiAgICAgIGRlZ3JlZSA9IGRlZ3JlZSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWdyZWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSB3aXRoIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBkZWdyZWUgPSB0aGlzLmdldE5vZGVEZWdyZWUobm9kZSk7XG4gIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBkZWdyZWUgKz0gdGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucGVyZm9ybURGU09uQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbXBvdW5kT3JkZXIgPSBbXTtcbiAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maWxsQ29tcGV4T3JkZXJCeURGUyA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyhjaGlsZC5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRUb0JlVGlsZWQoY2hpbGQpKSB7XG4gICAgICB0aGlzLmNvbXBvdW5kT3JkZXIucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgcGxhY2VzIGVhY2ggemVybyBkZWdyZWUgbWVtYmVyIHdydCBnaXZlbiAoeCx5KSBjb29yZGluYXRlcyAodG9wIGxlZnQpLlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmFkanVzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIHgsIHksIGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbiwgY29tcG91bmRWZXJ0aWNhbE1hcmdpbikge1xuICB4ICs9IGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbjtcbiAgeSArPSBjb21wb3VuZFZlcnRpY2FsTWFyZ2luO1xuXG4gIHZhciBsZWZ0ID0geDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IG9yZ2FuaXphdGlvbi5yb3dzW2ldO1xuICAgIHggPSBsZWZ0O1xuICAgIHZhciBtYXhIZWlnaHQgPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBsbm9kZSA9IHJvd1tqXTtcblxuICAgICAgbG5vZGUucmVjdC54ID0geDsgLy8gKyBsbm9kZS5yZWN0LndpZHRoIC8gMjtcbiAgICAgIGxub2RlLnJlY3QueSA9IHk7IC8vICsgbG5vZGUucmVjdC5oZWlnaHQgLyAyO1xuXG4gICAgICB4ICs9IGxub2RlLnJlY3Qud2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgIGlmIChsbm9kZS5yZWN0LmhlaWdodCA+IG1heEhlaWdodCkgbWF4SGVpZ2h0ID0gbG5vZGUucmVjdC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgeSArPSBtYXhIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxlQ29tcG91bmRNZW1iZXJzID0gZnVuY3Rpb24gKGNoaWxkR3JhcGhNYXAsIGlkVG9Ob2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy50aWxlZE1lbWJlclBhY2sgPSBbXTtcblxuICBPYmplY3Qua2V5cyhjaGlsZEdyYXBoTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIC8vIEdldCB0aGUgY29tcG91bmQgbm9kZVxuICAgIHZhciBjb21wb3VuZE5vZGUgPSBpZFRvTm9kZVtpZF07XG5cbiAgICBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0gPSBzZWxmLnRpbGVOb2RlcyhjaGlsZEdyYXBoTWFwW2lkXSwgY29tcG91bmROb2RlLnBhZGRpbmdMZWZ0ICsgY29tcG91bmROb2RlLnBhZGRpbmdSaWdodCk7XG5cbiAgICBjb21wb3VuZE5vZGUucmVjdC53aWR0aCA9IHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS53aWR0aDtcbiAgICBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQgPSBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uaGVpZ2h0O1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVOb2RlcyA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgpIHtcbiAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUw7XG4gIHZhciBob3Jpem9udGFsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTDtcbiAgdmFyIG9yZ2FuaXphdGlvbiA9IHtcbiAgICByb3dzOiBbXSxcbiAgICByb3dXaWR0aDogW10sXG4gICAgcm93SGVpZ2h0OiBbXSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IG1pbldpZHRoLCAvLyBhc3N1bWUgbWluSGVpZ2h0IGVxdWFscyB0byBtaW5XaWR0aFxuICAgIHZlcnRpY2FsUGFkZGluZzogdmVydGljYWxQYWRkaW5nLFxuICAgIGhvcml6b250YWxQYWRkaW5nOiBob3Jpem9udGFsUGFkZGluZ1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG5vZGVzIGluIGFzY2VuZGluZyBvcmRlciBvZiB0aGVpciBhcmVhc1xuICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChuMSwgbjIpIHtcbiAgICBpZiAobjEucmVjdC53aWR0aCAqIG4xLnJlY3QuaGVpZ2h0ID4gbjIucmVjdC53aWR0aCAqIG4yLnJlY3QuaGVpZ2h0KSByZXR1cm4gLTE7XG4gICAgaWYgKG4xLnJlY3Qud2lkdGggKiBuMS5yZWN0LmhlaWdodCA8IG4yLnJlY3Qud2lkdGggKiBuMi5yZWN0LmhlaWdodCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IHRpbGUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIDAsIG1pbldpZHRoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FuQWRkSG9yaXpvbnRhbChvcmdhbml6YXRpb24sIGxOb2RlLnJlY3Qud2lkdGgsIGxOb2RlLnJlY3QuaGVpZ2h0KSkge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgdGhpcy5nZXRTaG9ydGVzdFJvd0luZGV4KG9yZ2FuaXphdGlvbiksIG1pbldpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoLCBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIG9yZ2FuaXphdGlvbjtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluc2VydE5vZGVUb1JvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIG5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCkge1xuICB2YXIgbWluQ29tcG91bmRTaXplID0gbWluV2lkdGg7XG5cbiAgLy8gQWRkIG5ldyByb3cgaWYgbmVlZGVkXG4gIGlmIChyb3dJbmRleCA9PSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGgpIHtcbiAgICB2YXIgc2Vjb25kRGltZW5zaW9uID0gW107XG5cbiAgICBvcmdhbml6YXRpb24ucm93cy5wdXNoKHNlY29uZERpbWVuc2lvbik7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoLnB1c2gobWluQ29tcG91bmRTaXplKTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0LnB1c2goMCk7XG4gIH1cblxuICAvLyBVcGRhdGUgcm93IHdpZHRoXG4gIHZhciB3ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3Jvd0luZGV4XSArIG5vZGUucmVjdC53aWR0aDtcblxuICBpZiAob3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLmxlbmd0aCA+IDApIHtcbiAgICB3ICs9IG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gPSB3O1xuICAvLyBVcGRhdGUgY29tcG91bmQgd2lkdGhcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IHcpIHtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSB3O1xuICB9XG5cbiAgLy8gVXBkYXRlIGhlaWdodFxuICB2YXIgaCA9IG5vZGUucmVjdC5oZWlnaHQ7XG4gIGlmIChyb3dJbmRleCA+IDApIGggKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICB2YXIgZXh0cmFIZWlnaHQgPSAwO1xuICBpZiAoaCA+IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdKSB7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSA9IGg7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSAtIGV4dHJhSGVpZ2h0O1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBleHRyYUhlaWdodDtcblxuICAvLyBJbnNlcnQgbm9kZVxuICBvcmdhbml6YXRpb24ucm93c1tyb3dJbmRleF0ucHVzaChub2RlKTtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWluIHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRTaG9ydGVzdFJvd0luZGV4ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgciA9IC0xO1xuICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA8IG1pbikge1xuICAgICAgciA9IGk7XG4gICAgICBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLy9TY2FucyB0aGUgcm93cyBvZiBhbiBvcmdhbml6YXRpb24gYW5kIHJldHVybnMgdGhlIG9uZSB3aXRoIHRoZSBtYXggd2lkdGhcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldExvbmdlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1heCA9IE51bWJlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA+IG1heCkge1xuICAgICAgciA9IGk7XG4gICAgICBtYXggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgYWRkaW5nIGV4dHJhIHdpZHRoIHRvIHRoZSBvcmdhbml6YXRpb24gdmlvbGF0ZXNcbiogdGhlIGFzcGVjdCByYXRpbygxKSBvciBub3QuXG4qL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FuQWRkSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIGV4dHJhV2lkdGgsIGV4dHJhSGVpZ2h0KSB7XG5cbiAgdmFyIHNyaSA9IHRoaXMuZ2V0U2hvcnRlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuXG4gIGlmIChzcmkgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbWluID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3NyaV07XG5cbiAgaWYgKG1pbiArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyArIGV4dHJhV2lkdGggPD0gb3JnYW5pemF0aW9uLndpZHRoKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaERpZmYgPSAwO1xuXG4gIC8vIEFkZGluZyB0byBhbiBleGlzdGluZyByb3dcbiAgaWYgKG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbc3JpXSA8IGV4dHJhSGVpZ2h0KSB7XG4gICAgaWYgKHNyaSA+IDApIGhEaWZmID0gZXh0cmFIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nIC0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtzcmldO1xuICB9XG5cbiAgdmFyIGFkZF90b19yb3dfcmF0aW87XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggLSBtaW4gPj0gZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZykge1xuICAgIGFkZF90b19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIChtaW4gKyBleHRyYVdpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBhZGRfdG9fcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBvcmdhbml6YXRpb24ud2lkdGg7XG4gIH1cblxuICAvLyBBZGRpbmcgYSBuZXcgcm93IGZvciB0aGlzIG5vZGVcbiAgaERpZmYgPSBleHRyYUhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG4gIHZhciBhZGRfbmV3X3Jvd19yYXRpbztcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IGV4dHJhV2lkdGgpIHtcbiAgICBhZGRfbmV3X3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gZXh0cmFXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICBhZGRfbmV3X3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gb3JnYW5pemF0aW9uLndpZHRoO1xuICB9XG5cbiAgaWYgKGFkZF9uZXdfcm93X3JhdGlvIDwgMSkgYWRkX25ld19yb3dfcmF0aW8gPSAxIC8gYWRkX25ld19yb3dfcmF0aW87XG5cbiAgaWYgKGFkZF90b19yb3dfcmF0aW8gPCAxKSBhZGRfdG9fcm93X3JhdGlvID0gMSAvIGFkZF90b19yb3dfcmF0aW87XG5cbiAgcmV0dXJuIGFkZF90b19yb3dfcmF0aW8gPCBhZGRfbmV3X3Jvd19yYXRpbztcbn07XG5cbi8vSWYgbW92aW5nIHRoZSBsYXN0IG5vZGUgZnJvbSB0aGUgbG9uZ2VzdCByb3cgYW5kIGFkZGluZyBpdCB0byB0aGUgbGFzdFxuLy9yb3cgbWFrZXMgdGhlIGJvdW5kaW5nIGJveCBzbWFsbGVyLCBkbyBpdC5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnNoaWZ0VG9MYXN0Um93ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgbG9uZ2VzdCA9IHRoaXMuZ2V0TG9uZ2VzdFJvd0luZGV4KG9yZ2FuaXphdGlvbik7XG4gIHZhciBsYXN0ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoLmxlbmd0aCAtIDE7XG4gIHZhciByb3cgPSBvcmdhbml6YXRpb24ucm93c1tsb25nZXN0XTtcbiAgdmFyIG5vZGUgPSByb3dbcm93Lmxlbmd0aCAtIDFdO1xuXG4gIHZhciBkaWZmID0gbm9kZS53aWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcblxuICAvLyBDaGVjayBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2Ugb24gdGhlIGxhc3Qgcm93XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggLSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gPiBkaWZmICYmIGxvbmdlc3QgIT0gbGFzdCkge1xuICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb25nZXN0IHJvd1xuICAgIHJvdy5zcGxpY2UoLTEsIDEpO1xuXG4gICAgLy8gUHVzaCBpdCB0byB0aGUgbGFzdCByb3dcbiAgICBvcmdhbml6YXRpb24ucm93c1tsYXN0XS5wdXNoKG5vZGUpO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xvbmdlc3RdID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xvbmdlc3RdIC0gZGlmZjtcbiAgICBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gKyBkaWZmO1xuICAgIG9yZ2FuaXphdGlvbi53aWR0aCA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpbnN0YW5jZS5nZXRMb25nZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKV07XG5cbiAgICAvLyBVcGRhdGUgaGVpZ2h0cyBvZiB0aGUgb3JnYW5pemF0aW9uXG4gICAgdmFyIG1heEhlaWdodCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyb3dbaV0uaGVpZ2h0ID4gbWF4SGVpZ2h0KSBtYXhIZWlnaHQgPSByb3dbaV0uaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAobG9uZ2VzdCA+IDApIG1heEhlaWdodCArPSBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuXG4gICAgdmFyIHByZXZUb3RhbCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gKyBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSA9IG1heEhlaWdodDtcbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XSA8IG5vZGUuaGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZykgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XSA9IG5vZGUuaGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICAgIHZhciBmaW5hbFRvdGFsID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSArIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF07XG4gICAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBmaW5hbFRvdGFsIC0gcHJldlRvdGFsO1xuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxpbmdQcmVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChDb1NFQ29uc3RhbnRzLlRJTEUpIHtcbiAgICAvLyBGaW5kIHplcm8gZGVncmVlIG5vZGVzIGFuZCBjcmVhdGUgYSBjb21wb3VuZCBmb3IgZWFjaCBsZXZlbFxuICAgIHRoaXMuZ3JvdXBaZXJvRGVncmVlTWVtYmVycygpO1xuICAgIC8vIFRpbGUgYW5kIGNsZWFyIGNoaWxkcmVuIG9mIGVhY2ggY29tcG91bmRcbiAgICB0aGlzLmNsZWFyQ29tcG91bmRzKCk7XG4gICAgLy8gU2VwYXJhdGVseSB0aWxlIGFuZCBjbGVhciB6ZXJvIGRlZ3JlZSBub2RlcyBmb3IgZWFjaCBsZXZlbFxuICAgIHRoaXMuY2xlYXJaZXJvRGVncmVlTWVtYmVycygpO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxpbmdQb3N0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoQ29TRUNvbnN0YW50cy5USUxFKSB7XG4gICAgdGhpcy5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgICB0aGlzLnJlcG9wdWxhdGVDb21wb3VuZHMoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IFRyZWUgUmVkdWN0aW9uIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZWR1Y2UgdHJlZXMgXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZWR1Y2VUcmVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBydW5lZE5vZGVzQWxsID0gW107XG4gIHZhciBjb250YWluc0xlYWYgPSB0cnVlO1xuICB2YXIgbm9kZTtcblxuICB3aGlsZSAoY29udGFpbnNMZWFmKSB7XG4gICAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wID0gW107XG4gICAgY29udGFpbnNMZWFmID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxICYmICFub2RlLmdldEVkZ2VzKClbMF0uaXNJbnRlckdyYXBoICYmIG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcC5wdXNoKFtub2RlLCBub2RlLmdldEVkZ2VzKClbMF0sIG5vZGUuZ2V0T3duZXIoKV0pO1xuICAgICAgICBjb250YWluc0xlYWYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGFpbnNMZWFmID09IHRydWUpIHtcbiAgICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcnVuZWROb2Rlc0luU3RlcFRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXAucHVzaChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal0pO1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRPd25lcigpLnJlbW92ZShwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcnVuZWROb2Rlc0FsbC5wdXNoKHBydW5lZE5vZGVzSW5TdGVwKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IHBydW5lZE5vZGVzQWxsO1xufTtcblxuLy8gR3JvdyB0cmVlIG9uZSBzdGVwIFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ3Jvd1RyZWUgPSBmdW5jdGlvbiAocHJ1bmVkTm9kZXNBbGwpIHtcbiAgdmFyIGxlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbC5sZW5ndGg7XG4gIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IHBydW5lZE5vZGVzQWxsW2xlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgLSAxXTtcblxuICB2YXIgbm9kZURhdGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJ1bmVkTm9kZXNJblN0ZXAubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlRGF0YSA9IHBydW5lZE5vZGVzSW5TdGVwW2ldO1xuXG4gICAgdGhpcy5maW5kUGxhY2Vmb3JQcnVuZWROb2RlKG5vZGVEYXRhKTtcblxuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVswXSk7XG4gICAgbm9kZURhdGFbMl0uYWRkKG5vZGVEYXRhWzFdLCBub2RlRGF0YVsxXS5zb3VyY2UsIG5vZGVEYXRhWzFdLnRhcmdldCk7XG4gIH1cblxuICBwcnVuZWROb2Rlc0FsbC5zcGxpY2UocHJ1bmVkTm9kZXNBbGwubGVuZ3RoIC0gMSwgMSk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xufTtcblxuLy8gRmluZCBhbiBhcHByb3ByaWF0ZSBwb3NpdGlvbiB0byByZXBsYWNlIHBydW5lZCBub2RlLCB0aGlzIG1ldGhvZCBjYW4gYmUgaW1wcm92ZWRcbkNvU0VMYXlvdXQucHJvdG90eXBlLmZpbmRQbGFjZWZvclBydW5lZE5vZGUgPSBmdW5jdGlvbiAobm9kZURhdGEpIHtcblxuICB2YXIgZ3JpZEZvclBydW5lZE5vZGU7XG4gIHZhciBub2RlVG9Db25uZWN0O1xuICB2YXIgcHJ1bmVkTm9kZSA9IG5vZGVEYXRhWzBdO1xuICBpZiAocHJ1bmVkTm9kZSA9PSBub2RlRGF0YVsxXS5zb3VyY2UpIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0udGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIG5vZGVUb0Nvbm5lY3QgPSBub2RlRGF0YVsxXS5zb3VyY2U7XG4gIH1cbiAgdmFyIHN0YXJ0R3JpZFggPSBub2RlVG9Db25uZWN0LnN0YXJ0WDtcbiAgdmFyIGZpbmlzaEdyaWRYID0gbm9kZVRvQ29ubmVjdC5maW5pc2hYO1xuICB2YXIgc3RhcnRHcmlkWSA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRZO1xuICB2YXIgZmluaXNoR3JpZFkgPSBub2RlVG9Db25uZWN0LmZpbmlzaFk7XG5cbiAgdmFyIHVwTm9kZUNvdW50ID0gMDtcbiAgdmFyIGRvd25Ob2RlQ291bnQgPSAwO1xuICB2YXIgcmlnaHROb2RlQ291bnQgPSAwO1xuICB2YXIgbGVmdE5vZGVDb3VudCA9IDA7XG4gIHZhciBjb250cm9sUmVnaW9ucyA9IFt1cE5vZGVDb3VudCwgcmlnaHROb2RlQ291bnQsIGRvd25Ob2RlQ291bnQsIGxlZnROb2RlQ291bnRdO1xuXG4gIGlmIChzdGFydEdyaWRZID4gMCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgIGNvbnRyb2xSZWdpb25zWzBdICs9IHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZIC0gMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW3N0YXJ0R3JpZFldLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIGlmIChmaW5pc2hHcmlkWCA8IHRoaXMuZ3JpZC5sZW5ndGggLSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgY29udHJvbFJlZ2lvbnNbMV0gKz0gdGhpcy5ncmlkW2ZpbmlzaEdyaWRYICsgMV1baV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ZpbmlzaEdyaWRYXVtpXS5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICBpZiAoZmluaXNoR3JpZFkgPCB0aGlzLmdyaWRbMF0ubGVuZ3RoIC0gMSkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgIGNvbnRyb2xSZWdpb25zWzJdICs9IHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWSArIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWV0ubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0R3JpZFggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgY29udHJvbFJlZ2lvbnNbM10gKz0gdGhpcy5ncmlkW3N0YXJ0R3JpZFggLSAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbc3RhcnRHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgdmFyIG1pbiA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbWluQ291bnQ7XG4gIHZhciBtaW5JbmRleDtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBjb250cm9sUmVnaW9ucy5sZW5ndGg7IGorKykge1xuICAgIGlmIChjb250cm9sUmVnaW9uc1tqXSA8IG1pbikge1xuICAgICAgbWluID0gY29udHJvbFJlZ2lvbnNbal07XG4gICAgICBtaW5Db3VudCA9IDE7XG4gICAgICBtaW5JbmRleCA9IGo7XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1tqXSA9PSBtaW4pIHtcbiAgICAgIG1pbkNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1pbkNvdW50ID09IDMgJiYgbWluID09IDApIHtcbiAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWluQ291bnQgPT0gMiAmJiBtaW4gPT0gMCkge1xuICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKTtcbiAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwKSB7XG4gICAgICA7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChtaW5Db3VudCA9PSA0ICYmIG1pbiA9PSAwKSB7XG4gICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpO1xuICAgIGdyaWRGb3JQcnVuZWROb2RlID0gcmFuZG9tO1xuICB9IGVsc2Uge1xuICAgIGdyaWRGb3JQcnVuZWROb2RlID0gbWluSW5kZXg7XG4gIH1cblxuICBpZiAoZ3JpZEZvclBydW5lZE5vZGUgPT0gMCkge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0SGVpZ2h0KCkgLyAyIC0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAtIHBydW5lZE5vZGUuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAxKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCkgKyBub2RlVG9Db25uZWN0LmdldFdpZHRoKCkgLyAyICsgRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCArIHBydW5lZE5vZGUuZ2V0V2lkdGgoKSAvIDIsIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpKTtcbiAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAyKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCksIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpICsgbm9kZVRvQ29ubmVjdC5nZXRIZWlnaHQoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRIZWlnaHQoKSAvIDIpO1xuICB9IGVsc2Uge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpIC0gbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUxheW91dDtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjb3NlQmFzZSA9IHt9O1xuXG5jb3NlQmFzZS5sYXlvdXRCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmNvc2VCYXNlLkNvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29zZUJhc2UuQ29TRUVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuY29zZUJhc2UuQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmNvc2VCYXNlLkNvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuY29zZUJhc2UuQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5jb3NlQmFzZS5Db1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29zZUJhc2U7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJ2YWx1ZSIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsIm4iLCJfX2VzTW9kdWxlIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJGRExheW91dENvbnN0YW50cyIsIkNvU0VDb25zdGFudHMiLCJwcm9wIiwiREVGQVVMVF9VU0VfTVVMVElfTEVWRUxfU0NBTElORyIsIkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04iLCJERUZBVUxUX0VER0VfTEVOR1RIIiwiREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTiIsIlRJTEUiLCJUSUxJTkdfUEFERElOR19WRVJUSUNBTCIsIlRJTElOR19QQURESU5HX0hPUklaT05UQUwiLCJUUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCIsIkZETGF5b3V0RWRnZSIsIkNvU0VFZGdlIiwic291cmNlIiwidGFyZ2V0IiwidkVkZ2UiLCJjcmVhdGUiLCJMR3JhcGgiLCJDb1NFR3JhcGgiLCJwYXJlbnQiLCJncmFwaE1nciIsInZHcmFwaCIsIkxHcmFwaE1hbmFnZXIiLCJDb1NFR3JhcGhNYW5hZ2VyIiwibGF5b3V0IiwiRkRMYXlvdXROb2RlIiwiSU1hdGgiLCJDb1NFTm9kZSIsImdtIiwibG9jIiwic2l6ZSIsInZOb2RlIiwibW92ZSIsImdyYXBoTWFuYWdlciIsImdldExheW91dCIsImRpc3BsYWNlbWVudFgiLCJjb29saW5nRmFjdG9yIiwic3ByaW5nRm9yY2VYIiwicmVwdWxzaW9uRm9yY2VYIiwiZ3Jhdml0YXRpb25Gb3JjZVgiLCJub09mQ2hpbGRyZW4iLCJkaXNwbGFjZW1lbnRZIiwic3ByaW5nRm9yY2VZIiwicmVwdWxzaW9uRm9yY2VZIiwiZ3Jhdml0YXRpb25Gb3JjZVkiLCJNYXRoIiwiYWJzIiwibWF4Tm9kZURpc3BsYWNlbWVudCIsInNpZ24iLCJjaGlsZCIsIm1vdmVCeSIsImdldE5vZGVzIiwibGVuZ3RoIiwicHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbiIsInRvdGFsRGlzcGxhY2VtZW50IiwiZFgiLCJkWSIsIm5vZGVzIiwiZ2V0Q2hpbGQiLCJub2RlIiwic2V0UHJlZDEiLCJwcmVkMSIsImdldFByZWQxIiwiZ2V0UHJlZDIiLCJwcmVkMiIsInNldE5leHQiLCJuZXh0IiwiZ2V0TmV4dCIsInNldFByb2Nlc3NlZCIsInByb2Nlc3NlZCIsImlzUHJvY2Vzc2VkIiwiRkRMYXlvdXQiLCJMYXlvdXRDb25zdGFudHMiLCJQb2ludCIsIlBvaW50RCIsIkxheW91dCIsIkludGVnZXIiLCJJR2VvbWV0cnkiLCJUcmFuc2Zvcm0iLCJDb1NFTGF5b3V0IiwidG9CZVRpbGVkIiwibmV3R3JhcGhNYW5hZ2VyIiwibmV3R3JhcGgiLCJuZXdOb2RlIiwibmV3RWRnZSIsImluaXRQYXJhbWV0ZXJzIiwiYXJndW1lbnRzIiwiaXNTdWJMYXlvdXQiLCJpZGVhbEVkZ2VMZW5ndGgiLCJ1c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uIiwiREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT04iLCJzcHJpbmdDb25zdGFudCIsIkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIIiwicmVwdWxzaW9uQ29uc3RhbnQiLCJERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSCIsImdyYXZpdHlDb25zdGFudCIsIkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCIsImNvbXBvdW5kR3Jhdml0eUNvbnN0YW50IiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIIiwiZ3Jhdml0eVJhbmdlRmFjdG9yIiwiREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsImNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yIiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsInBydW5lZE5vZGVzQWxsIiwiZ3Jvd1RyZWVJdGVyYXRpb25zIiwiYWZ0ZXJHcm93dGhJdGVyYXRpb25zIiwiaXNUcmVlR3Jvd2luZyIsImlzR3Jvd3RoRmluaXNoZWQiLCJjb29saW5nQ3ljbGUiLCJtYXhDb29saW5nQ3ljbGUiLCJtYXhJdGVyYXRpb25zIiwiQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EIiwiZmluYWxUZW1wZXJhdHVyZSIsImNvb2xpbmdBZGp1c3RlciIsImNyZWF0ZUJlbmRzQXNOZWVkZWQiLCJERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQiLCJjcmVhdGVCZW5kcG9pbnRzIiwicmVzZXRBbGxFZGdlcyIsImxldmVsIiwiY2xhc3NpY0xheW91dCIsIm5vZGVzV2l0aEdyYXZpdHkiLCJjYWxjdWxhdGVOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvblRvIiwic2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24iLCJjYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMiLCJjYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzIiwiY2FsY0luY2x1c2lvblRyZWVEZXB0aHMiLCJnZXRSb290IiwiY2FsY0VzdGltYXRlZFNpemUiLCJjYWxjSWRlYWxFZGdlTGVuZ3RocyIsImluY3JlbWVudGFsIiwiZm9yZXN0IiwiZ2V0RmxhdEZvcmVzdCIsInBvc2l0aW9uTm9kZXNSYWRpYWxseSIsInJlZHVjZVRyZWVzIiwicmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImFsbE5vZGVzIiwiU2V0IiwiZ2V0QWxsTm9kZXMiLCJpbnRlcnNlY3Rpb24iLCJmaWx0ZXIiLCJ4IiwiaGFzIiwicG9zaXRpb25Ob2Rlc1JhbmRvbWx5IiwiaW5pdFNwcmluZ0VtYmVkZGVyIiwicnVuU3ByaW5nRW1iZWRkZXIiLCJ0aWNrIiwidG90YWxJdGVyYXRpb25zIiwiaXNDb252ZXJnZWQiLCJsYXlvdXRRdWFsaXR5IiwibWF4IiwiaW5pdGlhbENvb2xpbmdGYWN0b3IiLCJwb3ciLCJsb2ciLCJhbmltYXRpb25QZXJpb2QiLCJjZWlsIiwiaW5pdGlhbEFuaW1hdGlvblBlcmlvZCIsInNxcnQiLCJ1cGRhdGVCb3VuZHMiLCJ1cGRhdGVHcmlkIiwiZ3Jvd1RyZWUiLCJERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIiwiZ3JpZFVwZGF0ZUFsbG93ZWQiLCJmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlIiwiY2FsY1NwcmluZ0ZvcmNlcyIsImNhbGNSZXB1bHNpb25Gb3JjZXMiLCJjYWxjR3Jhdml0YXRpb25hbEZvcmNlcyIsIm1vdmVOb2RlcyIsImFuaW1hdGUiLCJnZXRQb3NpdGlvbnNEYXRhIiwicERhdGEiLCJyZWN0IiwiaWQiLCJnZXRDZW50ZXJYIiwieSIsImdldENlbnRlclkiLCJ3Iiwid2lkdGgiLCJoIiwiaGVpZ2h0IiwibGF5b3V0RW5kZWQiLCJBTklNQVRFIiwiZW1pdCIsIm5vZGVMaXN0IiwiZ3JhcGgiLCJncmFwaHMiLCJnZXRHcmFwaHMiLCJ1cGRhdGVDb25uZWN0ZWQiLCJpc0Nvbm5lY3RlZCIsImNvbmNhdCIsImVkZ2VzIiwiZ2V0QWxsRWRnZXMiLCJ2aXNpdGVkIiwiZWRnZSIsImdldFNvdXJjZSIsImdldFRhcmdldCIsImdldEJlbmRwb2ludHMiLCJwdXNoIiwiY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMiLCJhZGQiLCJlZGdlTGlzdCIsImdldEVkZ2VMaXN0VG9Ob2RlIiwiayIsIm11bHRpRWRnZSIsImZvckVhY2giLCJjdXJyZW50U3RhcnRpbmdQb2ludCIsIm51bWJlck9mQ29sdW1ucyIsImN1cnJlbnRZIiwiY3VycmVudFgiLCJwb2ludCIsInRyZWUiLCJjZW50ZXJOb2RlIiwiZmluZENlbnRlck9mVHJlZSIsInJhZGlhbExheW91dCIsImZsb29yIiwidHJhbnNmb3JtIiwiV09STERfQ0VOVEVSX1giLCJXT1JMRF9DRU5URVJfWSIsInN0YXJ0aW5nUG9pbnQiLCJyYWRpYWxTZXAiLCJtYXhEaWFnb25hbEluVHJlZSIsImJyYW5jaFJhZGlhbExheW91dCIsImJvdW5kcyIsImNhbGN1bGF0ZUJvdW5kcyIsInNldERldmljZU9yZ1giLCJnZXRNaW5YIiwic2V0RGV2aWNlT3JnWSIsImdldE1pblkiLCJzZXRXb3JsZE9yZ1giLCJzZXRXb3JsZE9yZ1kiLCJib3R0b21SaWdodCIsImdldE1heFgiLCJnZXRNYXhZIiwiaW52ZXJzZVRyYW5zZm9ybVBvaW50IiwicGFyZW50T2ZOb2RlIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiZGlzdGFuY2UiLCJyYWRpYWxTZXBhcmF0aW9uIiwiaGFsZkludGVydmFsIiwibm9kZUFuZ2xlIiwidGV0YSIsIlRXT19QSSIsImNvc190ZXRhIiwiY29zIiwieF8iLCJ5XyIsInNpbiIsInNldENlbnRlciIsIm5laWdoYm9yRWRnZXMiLCJnZXRFZGdlcyIsImNoaWxkQ291bnQiLCJicmFuY2hDb3VudCIsImluY0VkZ2VzQ291bnQiLCJzdGFydEluZGV4IiwiZ2V0RWRnZXNCZXR3ZWVuIiwidGVtcCIsInNwbGljZSIsImluZGV4IiwiaW5kZXhPZiIsInN0ZXBBbmdsZSIsImN1cnJlbnROZWlnaGJvciIsImdldE90aGVyRW5kIiwiY2hpbGRTdGFydEFuZ2xlIiwiY2hpbGRFbmRBbmdsZSIsIm1heERpYWdvbmFsIiwiTUlOX1ZBTFVFIiwiZGlhZ29uYWwiLCJnZXREaWFnb25hbCIsImNhbGNSZXB1bHNpb25SYW5nZSIsImdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMiLCJzZWxmIiwidGVtcE1lbWJlckdyb3VwcyIsIm1lbWJlckdyb3VwcyIsImlkVG9EdW1teU5vZGUiLCJ6ZXJvRGVncmVlIiwiZ2V0UGFyZW50IiwiZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbiIsInVuZGVmaW5lZCIsImdldFRvQmVUaWxlZCIsInBfaWQiLCJrZXlzIiwiZHVtbXlDb21wb3VuZElkIiwiZHVtbXlDb21wb3VuZCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdUb3AiLCJkdW1teVBhcmVudEdyYXBoIiwiZ2V0R3JhcGhNYW5hZ2VyIiwicGFyZW50R3JhcGgiLCJyZW1vdmUiLCJjbGVhckNvbXBvdW5kcyIsImNoaWxkR3JhcGhNYXAiLCJpZFRvTm9kZSIsInBlcmZvcm1ERlNPbkNvbXBvdW5kcyIsImNvbXBvdW5kT3JkZXIiLCJyZXNldEFsbE5vZGVzIiwidGlsZUNvbXBvdW5kTWVtYmVycyIsImNsZWFyWmVyb0RlZ3JlZU1lbWJlcnMiLCJ0aWxlZFplcm9EZWdyZWVQYWNrIiwiY29tcG91bmROb2RlIiwidGlsZU5vZGVzIiwicmVwb3B1bGF0ZUNvbXBvdW5kcyIsImxDb21wb3VuZE5vZGUiLCJob3Jpem9udGFsTWFyZ2luIiwidmVydGljYWxNYXJnaW4iLCJhZGp1c3RMb2NhdGlvbnMiLCJ0aWxlZE1lbWJlclBhY2siLCJyZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMiLCJ0aWxlZFBhY2siLCJjaGlsZEdyYXBoIiwiY2hpbGRyZW4iLCJ0aGVDaGlsZCIsImdldE5vZGVEZWdyZWUiLCJkZWdyZWUiLCJmaWxsQ29tcGV4T3JkZXJCeURGUyIsIm9yZ2FuaXphdGlvbiIsImNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbiIsImNvbXBvdW5kVmVydGljYWxNYXJnaW4iLCJsZWZ0Iiwicm93cyIsInJvdyIsIm1heEhlaWdodCIsImoiLCJsbm9kZSIsImhvcml6b250YWxQYWRkaW5nIiwidmVydGljYWxQYWRkaW5nIiwibWluV2lkdGgiLCJyb3dXaWR0aCIsInJvd0hlaWdodCIsInNvcnQiLCJuMSIsIm4yIiwibE5vZGUiLCJpbnNlcnROb2RlVG9Sb3ciLCJjYW5BZGRIb3Jpem9udGFsIiwiZ2V0U2hvcnRlc3RSb3dJbmRleCIsInNoaWZ0VG9MYXN0Um93Iiwicm93SW5kZXgiLCJtaW5Db21wb3VuZFNpemUiLCJzZWNvbmREaW1lbnNpb24iLCJleHRyYUhlaWdodCIsInIiLCJtaW4iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJnZXRMb25nZXN0Um93SW5kZXgiLCJleHRyYVdpZHRoIiwic3JpIiwiaERpZmYiLCJhZGRfdG9fcm93X3JhdGlvIiwiYWRkX25ld19yb3dfcmF0aW8iLCJsb25nZXN0IiwibGFzdCIsImRpZmYiLCJpbnN0YW5jZSIsInByZXZUb3RhbCIsImZpbmFsVG90YWwiLCJ0aWxpbmdQcmVMYXlvdXQiLCJ0aWxpbmdQb3N0TGF5b3V0IiwiY29udGFpbnNMZWFmIiwicHJ1bmVkTm9kZXNJblN0ZXBUZW1wIiwiaXNJbnRlckdyYXBoIiwiZ2V0T3duZXIiLCJwcnVuZWROb2Rlc0luU3RlcCIsImxlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAiLCJub2RlRGF0YSIsImZpbmRQbGFjZWZvclBydW5lZE5vZGUiLCJncmlkRm9yUHJ1bmVkTm9kZSIsIm5vZGVUb0Nvbm5lY3QiLCJwcnVuZWROb2RlIiwic3RhcnRHcmlkWCIsInN0YXJ0WCIsImZpbmlzaEdyaWRYIiwiZmluaXNoWCIsInN0YXJ0R3JpZFkiLCJzdGFydFkiLCJmaW5pc2hHcmlkWSIsImZpbmlzaFkiLCJ1cE5vZGVDb3VudCIsImRvd25Ob2RlQ291bnQiLCJyaWdodE5vZGVDb3VudCIsImxlZnROb2RlQ291bnQiLCJjb250cm9sUmVnaW9ucyIsImdyaWQiLCJtaW5Db3VudCIsIm1pbkluZGV4IiwicmFuZG9tIiwiZ2V0SGVpZ2h0IiwiZ2V0V2lkdGgiLCJjb3NlQmFzZSIsImxheW91dEJhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cose-base/cose-base.js\n");

/***/ })

};
;