/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape-fcose";
exports.ids = ["vendor-chunks/cytoscape-fcose"];
exports.modules = {

/***/ "(ssr)/./node_modules/cytoscape-fcose/cytoscape-fcose.js":
/*!*********************************************************!*\
  !*** ./node_modules/cytoscape-fcose/cytoscape-fcose.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! cose-base */ \"(ssr)/./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js\"));\n    else {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {\n    return /******/ (()=>{\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = {\n            /***/ 658: /***/ (module1)=>{\n                // Simple, internal Object.assign() polyfill for options objects etc.\n                module1.exports = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {\n                    for(var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        srcs[_key - 1] = arguments[_key];\n                    }\n                    srcs.forEach(function(src) {\n                        Object.keys(src).forEach(function(k) {\n                            return tgt[k] = src[k];\n                        });\n                    });\n                    return tgt;\n                };\n            /***/ },\n            /***/ 548: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_1385__)=>{\n                var _slicedToArray = function() {\n                    function sliceIterator(arr, i) {\n                        var _arr = [];\n                        var _n = true;\n                        var _d = false;\n                        var _e = undefined;\n                        try {\n                            for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                                _arr.push(_s.value);\n                                if (i && _arr.length === i) break;\n                            }\n                        } catch (err) {\n                            _d = true;\n                            _e = err;\n                        } finally{\n                            try {\n                                if (!_n && _i[\"return\"]) _i[\"return\"]();\n                            } finally{\n                                if (_d) throw _e;\n                            }\n                        }\n                        return _arr;\n                    }\n                    return function(arr, i) {\n                        if (Array.isArray(arr)) {\n                            return arr;\n                        } else if (Symbol.iterator in Object(arr)) {\n                            return sliceIterator(arr, i);\n                        } else {\n                            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                        }\n                    };\n                }();\n                /*\n * Auxiliary functions\n */ var LinkedList = __nested_webpack_require_1385__(140).layoutBase.LinkedList;\n                var auxiliary = {};\n                // get the top most nodes\n                auxiliary.getTopMostNodes = function(nodes) {\n                    var nodesMap = {};\n                    for(var i = 0; i < nodes.length; i++){\n                        nodesMap[nodes[i].id()] = true;\n                    }\n                    var roots = nodes.filter(function(ele, i) {\n                        if (typeof ele === \"number\") {\n                            ele = i;\n                        }\n                        var parent = ele.parent()[0];\n                        while(parent != null){\n                            if (nodesMap[parent.id()]) {\n                                return false;\n                            }\n                            parent = parent.parent()[0];\n                        }\n                        return true;\n                    });\n                    return roots;\n                };\n                // find disconnected components and create dummy nodes that connect them\n                auxiliary.connectComponents = function(cy, eles, topMostNodes, dummyNodes) {\n                    var queue = new LinkedList();\n                    var visited = new Set();\n                    var visitedTopMostNodes = [];\n                    var currentNeighbor = void 0;\n                    var minDegreeNode = void 0;\n                    var minDegree = void 0;\n                    var isConnected = false;\n                    var count = 1;\n                    var nodesConnectedToDummy = [];\n                    var components = [];\n                    var _loop = function _loop() {\n                        var cmpt = cy.collection();\n                        components.push(cmpt);\n                        var currentNode = topMostNodes[0];\n                        var childrenOfCurrentNode = cy.collection();\n                        childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n                        visitedTopMostNodes.push(currentNode);\n                        childrenOfCurrentNode.forEach(function(node) {\n                            queue.push(node);\n                            visited.add(node);\n                            cmpt.merge(node);\n                        });\n                        var _loop2 = function _loop2() {\n                            currentNode = queue.shift();\n                            // Traverse all neighbors of this node\n                            var neighborNodes = cy.collection();\n                            currentNode.neighborhood().nodes().forEach(function(node) {\n                                if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n                                    neighborNodes.merge(node);\n                                }\n                            });\n                            for(var i = 0; i < neighborNodes.length; i++){\n                                var neighborNode = neighborNodes[i];\n                                currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n                                if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n                                    var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n                                    childrenOfNeighbor.forEach(function(node) {\n                                        queue.push(node);\n                                        visited.add(node);\n                                        cmpt.merge(node);\n                                        if (topMostNodes.has(node)) {\n                                            visitedTopMostNodes.push(node);\n                                        }\n                                    });\n                                }\n                            }\n                        };\n                        while(queue.length != 0){\n                            _loop2();\n                        }\n                        cmpt.forEach(function(node) {\n                            eles.intersection(node.connectedEdges()).forEach(function(e) {\n                                // connectedEdges() usually cached\n                                if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n                                    // has() is cheap\n                                    cmpt.merge(e);\n                                }\n                            });\n                        });\n                        if (visitedTopMostNodes.length == topMostNodes.length) {\n                            isConnected = true;\n                        }\n                        if (!isConnected || isConnected && count > 1) {\n                            minDegreeNode = visitedTopMostNodes[0];\n                            minDegree = minDegreeNode.connectedEdges().length;\n                            visitedTopMostNodes.forEach(function(node) {\n                                if (node.connectedEdges().length < minDegree) {\n                                    minDegree = node.connectedEdges().length;\n                                    minDegreeNode = node;\n                                }\n                            });\n                            nodesConnectedToDummy.push(minDegreeNode.id());\n                            // TO DO: Check efficiency of this part\n                            var temp = cy.collection();\n                            temp.merge(visitedTopMostNodes[0]);\n                            visitedTopMostNodes.forEach(function(node) {\n                                temp.merge(node);\n                            });\n                            visitedTopMostNodes = [];\n                            topMostNodes = topMostNodes.difference(temp);\n                            count++;\n                        }\n                    };\n                    do {\n                        _loop();\n                    }while (!isConnected);\n                    if (dummyNodes) {\n                        if (nodesConnectedToDummy.length > 0) {\n                            dummyNodes.set(\"dummy\" + (dummyNodes.size + 1), nodesConnectedToDummy);\n                        }\n                    }\n                    return components;\n                };\n                // relocates componentResult to originalCenter if there is no fixedNodeConstraint\n                auxiliary.relocateComponent = function(originalCenter, componentResult, options) {\n                    if (!options.fixedNodeConstraint) {\n                        var minXCoord = Number.POSITIVE_INFINITY;\n                        var maxXCoord = Number.NEGATIVE_INFINITY;\n                        var minYCoord = Number.POSITIVE_INFINITY;\n                        var maxYCoord = Number.NEGATIVE_INFINITY;\n                        if (options.quality == \"draft\") {\n                            // calculate current bounding box\n                            var _iteratorNormalCompletion = true;\n                            var _didIteratorError = false;\n                            var _iteratorError = undefined;\n                            try {\n                                for(var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                                    var _ref = _step.value;\n                                    var _ref2 = _slicedToArray(_ref, 2);\n                                    var key = _ref2[0];\n                                    var value = _ref2[1];\n                                    var cyNode = options.cy.getElementById(key);\n                                    if (cyNode) {\n                                        var nodeBB = cyNode.boundingBox();\n                                        var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n                                        var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n                                        var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n                                        var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n                                        if (leftX < minXCoord) minXCoord = leftX;\n                                        if (rightX > maxXCoord) maxXCoord = rightX;\n                                        if (topY < minYCoord) minYCoord = topY;\n                                        if (bottomY > maxYCoord) maxYCoord = bottomY;\n                                    }\n                                }\n                            // find difference between current and original center\n                            } catch (err) {\n                                _didIteratorError = true;\n                                _iteratorError = err;\n                            } finally{\n                                try {\n                                    if (!_iteratorNormalCompletion && _iterator.return) {\n                                        _iterator.return();\n                                    }\n                                } finally{\n                                    if (_didIteratorError) {\n                                        throw _iteratorError;\n                                    }\n                                }\n                            }\n                            var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n                            var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n                            // move component to original center\n                            componentResult.xCoords = componentResult.xCoords.map(function(x) {\n                                return x + diffOnX;\n                            });\n                            componentResult.yCoords = componentResult.yCoords.map(function(y) {\n                                return y + diffOnY;\n                            });\n                        } else {\n                            // calculate current bounding box\n                            Object.keys(componentResult).forEach(function(item) {\n                                var node = componentResult[item];\n                                var leftX = node.getRect().x;\n                                var rightX = node.getRect().x + node.getRect().width;\n                                var topY = node.getRect().y;\n                                var bottomY = node.getRect().y + node.getRect().height;\n                                if (leftX < minXCoord) minXCoord = leftX;\n                                if (rightX > maxXCoord) maxXCoord = rightX;\n                                if (topY < minYCoord) minYCoord = topY;\n                                if (bottomY > maxYCoord) maxYCoord = bottomY;\n                            });\n                            // find difference between current and original center\n                            var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n                            var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n                            // move component to original center\n                            Object.keys(componentResult).forEach(function(item) {\n                                var node = componentResult[item];\n                                node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n                            });\n                        }\n                    }\n                };\n                auxiliary.calcBoundingBox = function(parentNode, xCoords, yCoords, nodeIndexes) {\n                    // calculate bounds\n                    var left = Number.MAX_SAFE_INTEGER;\n                    var right = Number.MIN_SAFE_INTEGER;\n                    var top = Number.MAX_SAFE_INTEGER;\n                    var bottom = Number.MIN_SAFE_INTEGER;\n                    var nodeLeft = void 0;\n                    var nodeRight = void 0;\n                    var nodeTop = void 0;\n                    var nodeBottom = void 0;\n                    var nodes = parentNode.descendants().not(\":parent\");\n                    var s = nodes.length;\n                    for(var i = 0; i < s; i++){\n                        var node = nodes[i];\n                        nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n                        nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n                        nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n                        nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n                        if (left > nodeLeft) {\n                            left = nodeLeft;\n                        }\n                        if (right < nodeRight) {\n                            right = nodeRight;\n                        }\n                        if (top > nodeTop) {\n                            top = nodeTop;\n                        }\n                        if (bottom < nodeBottom) {\n                            bottom = nodeBottom;\n                        }\n                    }\n                    var boundingBox = {};\n                    boundingBox.topLeftX = left;\n                    boundingBox.topLeftY = top;\n                    boundingBox.width = right - left;\n                    boundingBox.height = bottom - top;\n                    return boundingBox;\n                };\n                // This function finds and returns parent nodes whose all children are hidden\n                auxiliary.calcParentsWithoutChildren = function(cy, eles) {\n                    var parentsWithoutChildren = cy.collection();\n                    eles.nodes(\":parent\").forEach(function(parent) {\n                        var check = false;\n                        parent.children().forEach(function(child) {\n                            if (child.css(\"display\") != \"none\") {\n                                check = true;\n                            }\n                        });\n                        if (!check) {\n                            parentsWithoutChildren.merge(parent);\n                        }\n                    });\n                    return parentsWithoutChildren;\n                };\n                module1.exports = auxiliary;\n            /***/ },\n            /***/ 816: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_17389__)=>{\n                /**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/ var aux = __nested_webpack_require_17389__(548);\n                var CoSELayout = __nested_webpack_require_17389__(140).CoSELayout;\n                var CoSENode = __nested_webpack_require_17389__(140).CoSENode;\n                var PointD = __nested_webpack_require_17389__(140).layoutBase.PointD;\n                var DimensionD = __nested_webpack_require_17389__(140).layoutBase.DimensionD;\n                var LayoutConstants = __nested_webpack_require_17389__(140).layoutBase.LayoutConstants;\n                var FDLayoutConstants = __nested_webpack_require_17389__(140).layoutBase.FDLayoutConstants;\n                var CoSEConstants = __nested_webpack_require_17389__(140).CoSEConstants;\n                // main function that cose layout is processed\n                var coseLayout = function coseLayout(options, spectralResult) {\n                    var cy = options.cy;\n                    var eles = options.eles;\n                    var nodes = eles.nodes();\n                    var edges = eles.edges();\n                    var nodeIndexes = void 0;\n                    var xCoords = void 0;\n                    var yCoords = void 0;\n                    var idToLNode = {};\n                    if (options.randomize) {\n                        nodeIndexes = spectralResult[\"nodeIndexes\"];\n                        xCoords = spectralResult[\"xCoords\"];\n                        yCoords = spectralResult[\"yCoords\"];\n                    }\n                    var isFn = function isFn(fn) {\n                        return typeof fn === \"function\";\n                    };\n                    var optFn = function optFn(opt, ele) {\n                        if (isFn(opt)) {\n                            return opt(ele);\n                        } else {\n                            return opt;\n                        }\n                    };\n                    /**** Postprocessing functions ****/ var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n                    // transfer cytoscape nodes to cose nodes\n                    var processChildrenList = function processChildrenList(parent, children, layout, options) {\n                        var size = children.length;\n                        for(var i = 0; i < size; i++){\n                            var theChild = children[i];\n                            var children_of_children = null;\n                            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                                children_of_children = theChild.children();\n                            }\n                            var theNode = void 0;\n                            var dimensions = theChild.layoutDimensions({\n                                nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n                            });\n                            if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                                if (options.randomize) {\n                                    if (!theChild.isParent()) {\n                                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                                    } else {\n                                        var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n                                        if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                                            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n                                        } else {\n                                            // for the parentsWithoutChildren\n                                            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                                        }\n                                    }\n                                } else {\n                                    theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position(\"x\") - dimensions.w / 2, theChild.position(\"y\") - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                                }\n                            } else {\n                                theNode = parent.add(new CoSENode(this.graphManager));\n                            }\n                            // Attach id to the layout node and repulsion value\n                            theNode.id = theChild.data(\"id\");\n                            theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n                            // Attach the paddings of cy node to layout node\n                            theNode.paddingLeft = parseInt(theChild.css(\"padding\"));\n                            theNode.paddingTop = parseInt(theChild.css(\"padding\"));\n                            theNode.paddingRight = parseInt(theChild.css(\"padding\"));\n                            theNode.paddingBottom = parseInt(theChild.css(\"padding\"));\n                            //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n                            //These properties will be used while updating bounds of compounds during iterations or tiling\n                            //and will be used for simple nodes while transferring final positions to cytoscape\n                            if (options.nodeDimensionsIncludeLabels) {\n                                theNode.labelWidth = theChild.boundingBox({\n                                    includeLabels: true,\n                                    includeNodes: false,\n                                    includeOverlays: false\n                                }).w;\n                                theNode.labelHeight = theChild.boundingBox({\n                                    includeLabels: true,\n                                    includeNodes: false,\n                                    includeOverlays: false\n                                }).h;\n                                theNode.labelPosVertical = theChild.css(\"text-valign\");\n                                theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n                            }\n                            // Map the layout node\n                            idToLNode[theChild.data(\"id\")] = theNode;\n                            if (isNaN(theNode.rect.x)) {\n                                theNode.rect.x = 0;\n                            }\n                            if (isNaN(theNode.rect.y)) {\n                                theNode.rect.y = 0;\n                            }\n                            if (children_of_children != null && children_of_children.length > 0) {\n                                var theNewGraph = void 0;\n                                theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                                processChildrenList(theNewGraph, children_of_children, layout, options);\n                            }\n                        }\n                    };\n                    // transfer cytoscape edges to cose edges\n                    var processEdges = function processEdges(layout, gm, edges) {\n                        var idealLengthTotal = 0;\n                        var edgeCount = 0;\n                        for(var i = 0; i < edges.length; i++){\n                            var edge = edges[i];\n                            var sourceNode = idToLNode[edge.data(\"source\")];\n                            var targetNode = idToLNode[edge.data(\"target\")];\n                            if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                                var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n                                e1.id = edge.id();\n                                e1.idealLength = optFn(options.idealEdgeLength, edge);\n                                e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n                                idealLengthTotal += e1.idealLength;\n                                edgeCount++;\n                            }\n                        }\n                        // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n                        // in case there is no edge, use other options\n                        if (options.idealEdgeLength != null) {\n                            if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;\n                            else if (!isFn(options.idealEdgeLength)) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n                            else CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n                            // we need to update these constant values based on the ideal edge length constant\n                            CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n                            CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                        }\n                    };\n                    // transfer cytoscape constraints to cose layout\n                    var processConstraints = function processConstraints(layout, options) {\n                        // get nodes to be fixed\n                        if (options.fixedNodeConstraint) {\n                            layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n                        }\n                        // get nodes to be aligned\n                        if (options.alignmentConstraint) {\n                            layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n                        }\n                        // get nodes to be relatively placed\n                        if (options.relativePlacementConstraint) {\n                            layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n                        }\n                    };\n                    /**** Apply postprocessing ****/ if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n                    if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n                    if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n                    if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n                    if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n                    if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n                    if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n                    if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n                    if (options.quality == \"proof\") LayoutConstants.QUALITY = 2;\n                    else LayoutConstants.QUALITY = 0;\n                    CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n                    CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n                    CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n                    CoSEConstants.TILE = options.tile;\n                    CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === \"function\" ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n                    CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === \"function\" ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n                    CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n                    CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n                    LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n                    // This part is for debug/demo purpose\n                    if (options.step == \"transformed\") {\n                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                        CoSEConstants.ENFORCE_CONSTRAINTS = false;\n                        CoSEConstants.APPLY_LAYOUT = false;\n                    }\n                    if (options.step == \"enforced\") {\n                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                        CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                        CoSEConstants.APPLY_LAYOUT = false;\n                    }\n                    if (options.step == \"cose\") {\n                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                        CoSEConstants.ENFORCE_CONSTRAINTS = false;\n                        CoSEConstants.APPLY_LAYOUT = true;\n                    }\n                    if (options.step == \"all\") {\n                        if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                        else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                        CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                        CoSEConstants.APPLY_LAYOUT = true;\n                    }\n                    if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n                        CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n                    } else {\n                        CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n                    }\n                    var coseLayout = new CoSELayout();\n                    var gm = coseLayout.newGraphManager();\n                    processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n                    processEdges(coseLayout, gm, edges);\n                    processConstraints(coseLayout, options);\n                    coseLayout.runLayout();\n                    return idToLNode;\n                };\n                module1.exports = {\n                    coseLayout: coseLayout\n                };\n            /***/ },\n            /***/ 212: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_33038__)=>{\n                var _createClass = function() {\n                    function defineProperties(target, props) {\n                        for(var i = 0; i < props.length; i++){\n                            var descriptor = props[i];\n                            descriptor.enumerable = descriptor.enumerable || false;\n                            descriptor.configurable = true;\n                            if (\"value\" in descriptor) descriptor.writable = true;\n                            Object.defineProperty(target, descriptor.key, descriptor);\n                        }\n                    }\n                    return function(Constructor, protoProps, staticProps) {\n                        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                        if (staticProps) defineProperties(Constructor, staticProps);\n                        return Constructor;\n                    };\n                }();\n                function _classCallCheck(instance, Constructor) {\n                    if (!(instance instanceof Constructor)) {\n                        throw new TypeError(\"Cannot call a class as a function\");\n                    }\n                }\n                /**\n  The implementation of the fcose layout algorithm\n*/ var assign = __nested_webpack_require_33038__(658);\n                var aux = __nested_webpack_require_33038__(548);\n                var _require = __nested_webpack_require_33038__(657), spectralLayout = _require.spectralLayout;\n                var _require2 = __nested_webpack_require_33038__(816), coseLayout = _require2.coseLayout;\n                var defaults = Object.freeze({\n                    // 'draft', 'default' or 'proof' \n                    // - 'draft' only applies spectral layout \n                    // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n                    // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n                    quality: \"default\",\n                    // Use random node positions at beginning of layout\n                    // if this is set to false, then quality option must be \"proof\"\n                    randomize: true,\n                    // Whether or not to animate the layout\n                    animate: true,\n                    // Duration of animation in ms, if enabled\n                    animationDuration: 1000,\n                    // Easing of animation, if enabled\n                    animationEasing: undefined,\n                    // Fit the viewport to the repositioned nodes\n                    fit: true,\n                    // Padding around layout\n                    padding: 30,\n                    // Whether to include labels in node dimensions. Valid in \"proof\" quality\n                    nodeDimensionsIncludeLabels: false,\n                    // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n                    uniformNodeDimensions: false,\n                    // Whether to pack disconnected components - valid only if randomize: true\n                    packComponents: true,\n                    // Layout step - all, transformed, enforced, cose - for debug purpose only\n                    step: \"all\",\n                    /* spectral layout options */ // False for random, true for greedy\n                    samplingType: true,\n                    // Sample size to construct distance matrix\n                    sampleSize: 25,\n                    // Separation amount between nodes\n                    nodeSeparation: 75,\n                    // Power iteration tolerance\n                    piTol: 0.0000001,\n                    /* CoSE layout options */ // Node repulsion (non overlapping) multiplier\n                    nodeRepulsion: function nodeRepulsion(node) {\n                        return 4500;\n                    },\n                    // Ideal edge (non nested) length\n                    idealEdgeLength: function idealEdgeLength(edge) {\n                        return 50;\n                    },\n                    // Divisor to compute edge forces\n                    edgeElasticity: function edgeElasticity(edge) {\n                        return 0.45;\n                    },\n                    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n                    nestingFactor: 0.1,\n                    // Gravity force (constant)\n                    gravity: 0.25,\n                    // Maximum number of iterations to perform\n                    numIter: 2500,\n                    // For enabling tiling\n                    tile: true,\n                    // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n                    // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n                    tilingCompareBy: undefined,\n                    // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n                    tilingPaddingVertical: 10,\n                    // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n                    tilingPaddingHorizontal: 10,\n                    // Gravity range (constant) for compounds\n                    gravityRangeCompound: 1.5,\n                    // Gravity force (constant) for compounds\n                    gravityCompound: 1.0,\n                    // Gravity range (constant)\n                    gravityRange: 3.8,\n                    // Initial cooling factor for incremental layout  \n                    initialEnergyOnIncremental: 0.3,\n                    /* constraint options */ // Fix required nodes to predefined positions\n                    // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n                    fixedNodeConstraint: undefined,\n                    // Align required nodes in vertical/horizontal direction\n                    // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n                    alignmentConstraint: undefined,\n                    // Place two nodes relatively in vertical/horizontal direction \n                    // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n                    relativePlacementConstraint: undefined,\n                    /* layout event callbacks */ ready: function ready() {},\n                    stop: function stop() {} // on layoutstop\n                });\n                var Layout = function() {\n                    function Layout(options) {\n                        _classCallCheck(this, Layout);\n                        this.options = assign({}, defaults, options);\n                    }\n                    _createClass(Layout, [\n                        {\n                            key: \"run\",\n                            value: function run() {\n                                var layout = this;\n                                var options = this.options;\n                                var cy = options.cy;\n                                var eles = options.eles;\n                                var spectralResult = [];\n                                var xCoords = void 0;\n                                var yCoords = void 0;\n                                var coseResult = [];\n                                var components = void 0;\n                                var componentCenters = [];\n                                // basic validity check for constraint inputs \n                                if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n                                    options.fixedNodeConstraint = undefined;\n                                }\n                                if (options.alignmentConstraint) {\n                                    if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n                                        options.alignmentConstraint.vertical = undefined;\n                                    }\n                                    if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n                                        options.alignmentConstraint.horizontal = undefined;\n                                    }\n                                }\n                                if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n                                    options.relativePlacementConstraint = undefined;\n                                }\n                                // if any constraint exists, set some options\n                                var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n                                if (constraintExist) {\n                                    // constraints work with these options\n                                    options.tile = false;\n                                    options.packComponents = false;\n                                }\n                                // decide component packing is enabled or not\n                                var layUtil = void 0;\n                                var packingEnabled = false;\n                                if (cy.layoutUtilities && options.packComponents) {\n                                    layUtil = cy.layoutUtilities(\"get\");\n                                    if (!layUtil) layUtil = cy.layoutUtilities();\n                                    packingEnabled = true;\n                                }\n                                if (eles.nodes().length > 0) {\n                                    // if packing is not enabled, perform layout on the whole graph\n                                    if (!packingEnabled) {\n                                        // store component center\n                                        var boundingBox = options.eles.boundingBox();\n                                        componentCenters.push({\n                                            x: boundingBox.x1 + boundingBox.w / 2,\n                                            y: boundingBox.y1 + boundingBox.h / 2\n                                        });\n                                        // apply spectral layout\n                                        if (options.randomize) {\n                                            var result = spectralLayout(options);\n                                            spectralResult.push(result);\n                                        }\n                                        // apply cose layout as postprocessing\n                                        if (options.quality == \"default\" || options.quality == \"proof\") {\n                                            coseResult.push(coseLayout(options, spectralResult[0]));\n                                            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n                                        } else {\n                                            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n                                        }\n                                    } else {\n                                        // packing is enabled\n                                        var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n                                        components = aux.connectComponents(cy, options.eles, topMostNodes);\n                                        // store component centers\n                                        components.forEach(function(component) {\n                                            var boundingBox = component.boundingBox();\n                                            componentCenters.push({\n                                                x: boundingBox.x1 + boundingBox.w / 2,\n                                                y: boundingBox.y1 + boundingBox.h / 2\n                                            });\n                                        });\n                                        //send each component to spectral layout if randomized\n                                        if (options.randomize) {\n                                            components.forEach(function(component) {\n                                                options.eles = component;\n                                                spectralResult.push(spectralLayout(options));\n                                            });\n                                        }\n                                        if (options.quality == \"default\" || options.quality == \"proof\") {\n                                            var toBeTiledNodes = cy.collection();\n                                            if (options.tile) {\n                                                // behave nodes to be tiled as one component\n                                                var nodeIndexes = new Map();\n                                                var _xCoords = [];\n                                                var _yCoords = [];\n                                                var count = 0;\n                                                var tempSpectralResult = {\n                                                    nodeIndexes: nodeIndexes,\n                                                    xCoords: _xCoords,\n                                                    yCoords: _yCoords\n                                                };\n                                                var indexesToBeDeleted = [];\n                                                components.forEach(function(component, index) {\n                                                    if (component.edges().length == 0) {\n                                                        component.nodes().forEach(function(node, i) {\n                                                            toBeTiledNodes.merge(component.nodes()[i]);\n                                                            if (!node.isParent()) {\n                                                                tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                                                                tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                                                                tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                                                            }\n                                                        });\n                                                        indexesToBeDeleted.push(index);\n                                                    }\n                                                });\n                                                if (toBeTiledNodes.length > 1) {\n                                                    var _boundingBox = toBeTiledNodes.boundingBox();\n                                                    componentCenters.push({\n                                                        x: _boundingBox.x1 + _boundingBox.w / 2,\n                                                        y: _boundingBox.y1 + _boundingBox.h / 2\n                                                    });\n                                                    components.push(toBeTiledNodes);\n                                                    spectralResult.push(tempSpectralResult);\n                                                    for(var i = indexesToBeDeleted.length - 1; i >= 0; i--){\n                                                        components.splice(indexesToBeDeleted[i], 1);\n                                                        spectralResult.splice(indexesToBeDeleted[i], 1);\n                                                        componentCenters.splice(indexesToBeDeleted[i], 1);\n                                                    }\n                                                    ;\n                                                }\n                                            }\n                                            components.forEach(function(component, index) {\n                                                // send each component to cose layout\n                                                options.eles = component;\n                                                coseResult.push(coseLayout(options, spectralResult[index]));\n                                                aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n                                            });\n                                        } else {\n                                            components.forEach(function(component, index) {\n                                                aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n                                            });\n                                        }\n                                        // packing\n                                        var componentsEvaluated = new Set();\n                                        if (components.length > 1) {\n                                            var subgraphs = [];\n                                            var hiddenEles = eles.filter(function(ele) {\n                                                return ele.css(\"display\") == \"none\";\n                                            });\n                                            components.forEach(function(component, index) {\n                                                var nodeIndexes = void 0;\n                                                if (options.quality == \"draft\") {\n                                                    nodeIndexes = spectralResult[index].nodeIndexes;\n                                                }\n                                                if (component.nodes().not(hiddenEles).length > 0) {\n                                                    var subgraph = {};\n                                                    subgraph.edges = [];\n                                                    subgraph.nodes = [];\n                                                    var nodeIndex = void 0;\n                                                    component.nodes().not(hiddenEles).forEach(function(node) {\n                                                        if (options.quality == \"draft\") {\n                                                            if (!node.isParent()) {\n                                                                nodeIndex = nodeIndexes.get(node.id());\n                                                                subgraph.nodes.push({\n                                                                    x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2,\n                                                                    y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2,\n                                                                    width: node.boundingbox().w,\n                                                                    height: node.boundingbox().h\n                                                                });\n                                                            } else {\n                                                                var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                                                subgraph.nodes.push({\n                                                                    x: parentInfo.topLeftX,\n                                                                    y: parentInfo.topLeftY,\n                                                                    width: parentInfo.width,\n                                                                    height: parentInfo.height\n                                                                });\n                                                            }\n                                                        } else {\n                                                            if (coseResult[index][node.id()]) {\n                                                                subgraph.nodes.push({\n                                                                    x: coseResult[index][node.id()].getLeft(),\n                                                                    y: coseResult[index][node.id()].getTop(),\n                                                                    width: coseResult[index][node.id()].getWidth(),\n                                                                    height: coseResult[index][node.id()].getHeight()\n                                                                });\n                                                            }\n                                                        }\n                                                    });\n                                                    component.edges().forEach(function(edge) {\n                                                        var source = edge.source();\n                                                        var target = edge.target();\n                                                        if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                                                            if (options.quality == \"draft\") {\n                                                                var sourceNodeIndex = nodeIndexes.get(source.id());\n                                                                var targetNodeIndex = nodeIndexes.get(target.id());\n                                                                var sourceCenter = [];\n                                                                var targetCenter = [];\n                                                                if (source.isParent()) {\n                                                                    var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                                                    sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                                                                    sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                                                                } else {\n                                                                    sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                                                                    sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                                                                }\n                                                                if (target.isParent()) {\n                                                                    var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                                                    targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                                                                    targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                                                                } else {\n                                                                    targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                                                                    targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                                                                }\n                                                                subgraph.edges.push({\n                                                                    startX: sourceCenter[0],\n                                                                    startY: sourceCenter[1],\n                                                                    endX: targetCenter[0],\n                                                                    endY: targetCenter[1]\n                                                                });\n                                                            } else {\n                                                                if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                                                                    subgraph.edges.push({\n                                                                        startX: coseResult[index][source.id()].getCenterX(),\n                                                                        startY: coseResult[index][source.id()].getCenterY(),\n                                                                        endX: coseResult[index][target.id()].getCenterX(),\n                                                                        endY: coseResult[index][target.id()].getCenterY()\n                                                                    });\n                                                                }\n                                                            }\n                                                        }\n                                                    });\n                                                    if (subgraph.nodes.length > 0) {\n                                                        subgraphs.push(subgraph);\n                                                        componentsEvaluated.add(index);\n                                                    }\n                                                }\n                                            });\n                                            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n                                            if (options.quality == \"draft\") {\n                                                spectralResult.forEach(function(result, index) {\n                                                    var newXCoords = result.xCoords.map(function(x) {\n                                                        return x + shiftResult[index].dx;\n                                                    });\n                                                    var newYCoords = result.yCoords.map(function(y) {\n                                                        return y + shiftResult[index].dy;\n                                                    });\n                                                    result.xCoords = newXCoords;\n                                                    result.yCoords = newYCoords;\n                                                });\n                                            } else {\n                                                var _count = 0;\n                                                componentsEvaluated.forEach(function(index) {\n                                                    Object.keys(coseResult[index]).forEach(function(item) {\n                                                        var nodeRectangle = coseResult[index][item];\n                                                        nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                                                    });\n                                                    _count++;\n                                                });\n                                            }\n                                        }\n                                    }\n                                }\n                                // get each element's calculated position\n                                var getPositions = function getPositions(ele, i) {\n                                    if (options.quality == \"default\" || options.quality == \"proof\") {\n                                        if (typeof ele === \"number\") {\n                                            ele = i;\n                                        }\n                                        var pos = void 0;\n                                        var node = void 0;\n                                        var theId = ele.data(\"id\");\n                                        coseResult.forEach(function(result) {\n                                            if (theId in result) {\n                                                pos = {\n                                                    x: result[theId].getRect().getCenterX(),\n                                                    y: result[theId].getRect().getCenterY()\n                                                };\n                                                node = result[theId];\n                                            }\n                                        });\n                                        if (options.nodeDimensionsIncludeLabels) {\n                                            if (node.labelWidth) {\n                                                if (node.labelPosHorizontal == \"left\") {\n                                                    pos.x += node.labelWidth / 2;\n                                                } else if (node.labelPosHorizontal == \"right\") {\n                                                    pos.x -= node.labelWidth / 2;\n                                                }\n                                            }\n                                            if (node.labelHeight) {\n                                                if (node.labelPosVertical == \"top\") {\n                                                    pos.y += node.labelHeight / 2;\n                                                } else if (node.labelPosVertical == \"bottom\") {\n                                                    pos.y -= node.labelHeight / 2;\n                                                }\n                                            }\n                                        }\n                                        if (pos == undefined) pos = {\n                                            x: ele.position(\"x\"),\n                                            y: ele.position(\"y\")\n                                        };\n                                        return {\n                                            x: pos.x,\n                                            y: pos.y\n                                        };\n                                    } else {\n                                        var _pos = void 0;\n                                        spectralResult.forEach(function(result) {\n                                            var index = result.nodeIndexes.get(ele.id());\n                                            if (index != undefined) {\n                                                _pos = {\n                                                    x: result.xCoords[index],\n                                                    y: result.yCoords[index]\n                                                };\n                                            }\n                                        });\n                                        if (_pos == undefined) _pos = {\n                                            x: ele.position(\"x\"),\n                                            y: ele.position(\"y\")\n                                        };\n                                        return {\n                                            x: _pos.x,\n                                            y: _pos.y\n                                        };\n                                    }\n                                };\n                                // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n                                if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n                                    // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n                                    var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n                                    var _hiddenEles = eles.filter(function(ele) {\n                                        return ele.css(\"display\") == \"none\";\n                                    });\n                                    options.eles = eles.not(_hiddenEles);\n                                    eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n                                    if (parentsWithoutChildren.length > 0) {\n                                        parentsWithoutChildren.forEach(function(ele) {\n                                            ele.position(getPositions(ele));\n                                        });\n                                    }\n                                } else {\n                                    console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n                                }\n                            }\n                        }\n                    ]);\n                    return Layout;\n                }();\n                module1.exports = Layout;\n            /***/ },\n            /***/ 657: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_67167__)=>{\n                /**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/ var aux = __nested_webpack_require_67167__(548);\n                var Matrix = __nested_webpack_require_67167__(140).layoutBase.Matrix;\n                var SVD = __nested_webpack_require_67167__(140).layoutBase.SVD;\n                // main function that spectral layout is processed\n                var spectralLayout = function spectralLayout(options) {\n                    var cy = options.cy;\n                    var eles = options.eles;\n                    var nodes = eles.nodes();\n                    var parentNodes = eles.nodes(\":parent\");\n                    var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n                    var nodeIndexes = new Map(); // map to keep indexes to nodes\n                    var parentChildMap = new Map(); // mapping btw. compound and its representative node \n                    var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n                    var xCoords = [];\n                    var yCoords = [];\n                    var samplesColumn = []; // sampled vertices\n                    var minDistancesColumn = [];\n                    var C = []; // column sampling matrix\n                    var PHI = []; // intersection of column and row sampling matrices \n                    var INV = []; // inverse of PHI \n                    var firstSample = void 0; // the first sampled node\n                    var nodeSize = void 0;\n                    var infinity = 100000000;\n                    var small = 0.000000001;\n                    var piTol = options.piTol;\n                    var samplingType = options.samplingType; // false for random, true for greedy\n                    var nodeSeparation = options.nodeSeparation;\n                    var sampleSize = void 0;\n                    /**** Spectral-preprocessing functions ****/ /**** Spectral layout functions ****/ // determine which columns to be sampled\n                    var randomSampleCR = function randomSampleCR() {\n                        var sample = 0;\n                        var count = 0;\n                        var flag = false;\n                        while(count < sampleSize){\n                            sample = Math.floor(Math.random() * nodeSize);\n                            flag = false;\n                            for(var i = 0; i < count; i++){\n                                if (samplesColumn[i] == sample) {\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                            if (!flag) {\n                                samplesColumn[count] = sample;\n                                count++;\n                            } else {\n                                continue;\n                            }\n                        }\n                    };\n                    // takes the index of the node(pivot) to initiate BFS as a parameter\n                    var BFS = function BFS(pivot, index, samplingMethod) {\n                        var path = []; // the front of the path\n                        var front = 0; // the back of the path\n                        var back = 0;\n                        var current = 0;\n                        var temp = void 0;\n                        var distance = [];\n                        var max_dist = 0; // the furthest node to be returned\n                        var max_ind = 1;\n                        for(var i = 0; i < nodeSize; i++){\n                            distance[i] = infinity;\n                        }\n                        path[back] = pivot;\n                        distance[pivot] = 0;\n                        while(back >= front){\n                            current = path[front++];\n                            var neighbors = allNodesNeighborhood[current];\n                            for(var _i = 0; _i < neighbors.length; _i++){\n                                temp = nodeIndexes.get(neighbors[_i]);\n                                if (distance[temp] == infinity) {\n                                    distance[temp] = distance[current] + 1;\n                                    path[++back] = temp;\n                                }\n                            }\n                            C[current][index] = distance[current] * nodeSeparation;\n                        }\n                        if (samplingMethod) {\n                            for(var _i2 = 0; _i2 < nodeSize; _i2++){\n                                if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n                            }\n                            for(var _i3 = 0; _i3 < nodeSize; _i3++){\n                                if (minDistancesColumn[_i3] > max_dist) {\n                                    max_dist = minDistancesColumn[_i3];\n                                    max_ind = _i3;\n                                }\n                            }\n                        }\n                        return max_ind;\n                    };\n                    // apply BFS to all nodes or selected samples\n                    var allBFS = function allBFS(samplingMethod) {\n                        var sample = void 0;\n                        if (!samplingMethod) {\n                            randomSampleCR();\n                            // call BFS\n                            for(var i = 0; i < sampleSize; i++){\n                                BFS(samplesColumn[i], i, samplingMethod, false);\n                            }\n                        } else {\n                            sample = Math.floor(Math.random() * nodeSize);\n                            firstSample = sample;\n                            for(var _i4 = 0; _i4 < nodeSize; _i4++){\n                                minDistancesColumn[_i4] = infinity;\n                            }\n                            for(var _i5 = 0; _i5 < sampleSize; _i5++){\n                                samplesColumn[_i5] = sample;\n                                sample = BFS(sample, _i5, samplingMethod);\n                            }\n                        }\n                        // form the squared distances for C\n                        for(var _i6 = 0; _i6 < nodeSize; _i6++){\n                            for(var j = 0; j < sampleSize; j++){\n                                C[_i6][j] *= C[_i6][j];\n                            }\n                        }\n                        // form PHI\n                        for(var _i7 = 0; _i7 < sampleSize; _i7++){\n                            PHI[_i7] = [];\n                        }\n                        for(var _i8 = 0; _i8 < sampleSize; _i8++){\n                            for(var _j = 0; _j < sampleSize; _j++){\n                                PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n                            }\n                        }\n                    };\n                    // perform the SVD algorithm and apply a regularization step\n                    var sample = function sample() {\n                        var SVDResult = SVD.svd(PHI);\n                        var a_q = SVDResult.S;\n                        var a_u = SVDResult.U;\n                        var a_v = SVDResult.V;\n                        var max_s = a_q[0] * a_q[0] * a_q[0];\n                        var a_Sig = [];\n                        //  regularization\n                        for(var i = 0; i < sampleSize; i++){\n                            a_Sig[i] = [];\n                            for(var j = 0; j < sampleSize; j++){\n                                a_Sig[i][j] = 0;\n                                if (i == j) {\n                                    a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n                                }\n                            }\n                        }\n                        INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n                    };\n                    // calculate final coordinates \n                    var powerIteration = function powerIteration() {\n                        // two largest eigenvalues\n                        var theta1 = void 0;\n                        var theta2 = void 0;\n                        // initial guesses for eigenvectors\n                        var Y1 = [];\n                        var Y2 = [];\n                        var V1 = [];\n                        var V2 = [];\n                        for(var i = 0; i < nodeSize; i++){\n                            Y1[i] = Math.random();\n                            Y2[i] = Math.random();\n                        }\n                        Y1 = Matrix.normalize(Y1);\n                        Y2 = Matrix.normalize(Y2);\n                        var count = 0;\n                        // to keep track of the improvement ratio in power iteration\n                        var current = small;\n                        var previous = small;\n                        var temp = void 0;\n                        while(true){\n                            count++;\n                            for(var _i9 = 0; _i9 < nodeSize; _i9++){\n                                V1[_i9] = Y1[_i9];\n                            }\n                            Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n                            theta1 = Matrix.dotProduct(V1, Y1);\n                            Y1 = Matrix.normalize(Y1);\n                            current = Matrix.dotProduct(V1, Y1);\n                            temp = Math.abs(current / previous);\n                            if (temp <= 1 + piTol && temp >= 1) {\n                                break;\n                            }\n                            previous = current;\n                        }\n                        for(var _i10 = 0; _i10 < nodeSize; _i10++){\n                            V1[_i10] = Y1[_i10];\n                        }\n                        count = 0;\n                        previous = small;\n                        while(true){\n                            count++;\n                            for(var _i11 = 0; _i11 < nodeSize; _i11++){\n                                V2[_i11] = Y2[_i11];\n                            }\n                            V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n                            Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n                            theta2 = Matrix.dotProduct(V2, Y2);\n                            Y2 = Matrix.normalize(Y2);\n                            current = Matrix.dotProduct(V2, Y2);\n                            temp = Math.abs(current / previous);\n                            if (temp <= 1 + piTol && temp >= 1) {\n                                break;\n                            }\n                            previous = current;\n                        }\n                        for(var _i12 = 0; _i12 < nodeSize; _i12++){\n                            V2[_i12] = Y2[_i12];\n                        }\n                        // theta1 now contains dominant eigenvalue\n                        // theta2 now contains the second-largest eigenvalue\n                        // V1 now contains theta1's eigenvector\n                        // V2 now contains theta2's eigenvector\n                        //populate the two vectors\n                        xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n                        yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n                    };\n                    /**** Preparation for spectral layout (Preprocessing) ****/ // connect disconnected components (first top level, then inside of each compound node)\n                    aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n                    parentNodes.forEach(function(ele) {\n                        aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n                    });\n                    // assign indexes to nodes (first real, then dummy nodes)\n                    var index = 0;\n                    for(var i = 0; i < nodes.length; i++){\n                        if (!nodes[i].isParent()) {\n                            nodeIndexes.set(nodes[i].id(), index++);\n                        }\n                    }\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n                    try {\n                        for(var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                            var key = _step.value;\n                            nodeIndexes.set(key, index++);\n                        }\n                    // instantiate the neighborhood matrix\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally{\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return) {\n                                _iterator.return();\n                            }\n                        } finally{\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                    for(var _i13 = 0; _i13 < nodeIndexes.size; _i13++){\n                        allNodesNeighborhood[_i13] = [];\n                    }\n                    // form a parent-child map to keep representative node of each compound node  \n                    parentNodes.forEach(function(ele) {\n                        var children = ele.children().intersection(eles);\n                        //      let random = 0;\n                        while(children.nodes(\":childless\").length == 0){\n                            //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n                            children = children.nodes()[0].children().intersection(eles);\n                        }\n                        //  select the representative node - we can apply different methods here\n                        //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n                        var index = 0;\n                        var min = children.nodes(\":childless\")[0].connectedEdges().length;\n                        children.nodes(\":childless\").forEach(function(ele2, i) {\n                            if (ele2.connectedEdges().length < min) {\n                                min = ele2.connectedEdges().length;\n                                index = i;\n                            }\n                        });\n                        parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n                    });\n                    // add neighborhood relations (first real, then dummy nodes)\n                    nodes.forEach(function(ele) {\n                        var eleIndex = void 0;\n                        if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));\n                        else eleIndex = nodeIndexes.get(ele.id());\n                        ele.neighborhood().nodes().forEach(function(node) {\n                            if (eles.intersection(ele.edgesWith(node)).length > 0) {\n                                if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));\n                                else allNodesNeighborhood[eleIndex].push(node.id());\n                            }\n                        });\n                    });\n                    var _loop = function _loop(_key) {\n                        var eleIndex = nodeIndexes.get(_key);\n                        var disconnectedId = void 0;\n                        dummyNodes.get(_key).forEach(function(id) {\n                            if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);\n                            else disconnectedId = id;\n                            allNodesNeighborhood[eleIndex].push(disconnectedId);\n                            allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n                        });\n                    };\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n                    try {\n                        for(var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                            var _key = _step2.value;\n                            _loop(_key);\n                        }\n                    // nodeSize now only considers the size of transformed graph\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally{\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally{\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                    nodeSize = nodeIndexes.size;\n                    var spectralResult = void 0;\n                    // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n                    // So skip spectral and layout the graph with cose\n                    if (nodeSize > 2) {\n                        // if # of nodes in transformed graph is smaller than sample size,\n                        // then use # of nodes as sample size\n                        sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n                        // instantiates the partial matrices that will be used in spectral layout\n                        for(var _i14 = 0; _i14 < nodeSize; _i14++){\n                            C[_i14] = [];\n                        }\n                        for(var _i15 = 0; _i15 < sampleSize; _i15++){\n                            INV[_i15] = [];\n                        }\n                        /**** Apply spectral layout ****/ if (options.quality == \"draft\" || options.step == \"all\") {\n                            allBFS(samplingType);\n                            sample();\n                            powerIteration();\n                            spectralResult = {\n                                nodeIndexes: nodeIndexes,\n                                xCoords: xCoords,\n                                yCoords: yCoords\n                            };\n                        } else {\n                            nodeIndexes.forEach(function(value, key) {\n                                xCoords.push(cy.getElementById(key).position(\"x\"));\n                                yCoords.push(cy.getElementById(key).position(\"y\"));\n                            });\n                            spectralResult = {\n                                nodeIndexes: nodeIndexes,\n                                xCoords: xCoords,\n                                yCoords: yCoords\n                            };\n                        }\n                        return spectralResult;\n                    } else {\n                        var iterator = nodeIndexes.keys();\n                        var firstNode = cy.getElementById(iterator.next().value);\n                        var firstNodePos = firstNode.position();\n                        var firstNodeWidth = firstNode.outerWidth();\n                        xCoords.push(firstNodePos.x);\n                        yCoords.push(firstNodePos.y);\n                        if (nodeSize == 2) {\n                            var secondNode = cy.getElementById(iterator.next().value);\n                            var secondNodeWidth = secondNode.outerWidth();\n                            xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n                            yCoords.push(firstNodePos.y);\n                        }\n                        spectralResult = {\n                            nodeIndexes: nodeIndexes,\n                            xCoords: xCoords,\n                            yCoords: yCoords\n                        };\n                        return spectralResult;\n                    }\n                };\n                module1.exports = {\n                    spectralLayout: spectralLayout\n                };\n            /***/ },\n            /***/ 579: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_88218__)=>{\n                var impl = __nested_webpack_require_88218__(212);\n                // registers the extension on a cytoscape lib ref\n                var register = function register(cytoscape1) {\n                    if (!cytoscape1) {\n                        return;\n                    } // can't register if cytoscape unspecified\n                    cytoscape1(\"layout\", \"fcose\", impl); // register with cytoscape.js\n                };\n                if (typeof cytoscape !== \"undefined\") {\n                    // expose to global cytoscape (i.e. window.cytoscape)\n                    register(cytoscape);\n                }\n                module1.exports = register;\n            /***/ },\n            /***/ 140: /***/ (module1)=>{\n                module1.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_89292__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __nested_webpack_require_89292__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_89292__(579);\n        /******/ /******/ return __nested_webpack_exports__;\n    /******/ })();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL2N5dG9zY2FwZS1mY29zZS5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdELFFBQVFHLG1CQUFPQSxDQUFDLDJGQUFXO1NBQ3hDLEVBSytDO0FBQ3JELEdBQUcsSUFBSSxFQUFFLFNBQVNHLGdDQUFnQztJQUNsRCxPQUFnQixNQUFILEdBQUk7UUFDakIsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUFJLElBQUlDLHNCQUF1QjtZQUVyQyxHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQ0w7Z0JBSVIscUVBQXFFO2dCQUVyRUEsUUFBT0QsT0FBTyxHQUFHTyxPQUFPQyxNQUFNLElBQUksT0FBT0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLENBQUNGLFVBQVUsU0FBVUcsR0FBRztvQkFDakYsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU9DLE1BQU1KLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlLLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTt3QkFDdEdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztvQkFDbEM7b0JBRUFGLEtBQUtHLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO3dCQUN4QlgsT0FBT1ksSUFBSSxDQUFDRCxLQUFLRCxPQUFPLENBQUMsU0FBVUcsQ0FBQzs0QkFDbEMsT0FBT1YsR0FBRyxDQUFDVSxFQUFFLEdBQUdGLEdBQUcsQ0FBQ0UsRUFBRTt3QkFDeEI7b0JBQ0Y7b0JBRUEsT0FBT1Y7Z0JBQ1Q7WUFFQSxHQUFHLEdBQUc7WUFFTixHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQ1QsU0FBUW9CLDBCQUEwQkMsK0JBQW1CQTtnQkFJN0QsSUFBSUMsaUJBQWlCO29CQUFjLFNBQVNDLGNBQWNDLEdBQUcsRUFBRUMs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aEMsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLHdFQUF3RSxHQUN4RSxNQUFNLEdBQ04sTUFBTSxHQUFJLFVBQVU7UUFDcEIsTUFBTSxHQUFJLHVDQUF1QztRQUNqRCxNQUFNLEdBQUksMEVBQTBFO1FBQ3BGLE1BQU0sR0FBSSxJQUFJZ2QsMEJBQW1CQSxHQUFHMWIsZ0NBQW1CQSxDQUFDO1FBQ3hELE1BQU0sR0FDTixNQUFNLEdBQUksT0FBTzBiLDBCQUFtQkE7SUFDcEMsTUFBTSxHQUFHO0FBRVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXJvLW5ldHdvcmstd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2UvY3l0b3NjYXBlLWZjb3NlLmpzP2I2NDciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiY29zZS1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImNvc2UtYmFzZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjeXRvc2NhcGVGY29zZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY3l0b3NjYXBlRmNvc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJjb3NlQmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXykge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNjU4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5cbi8vIFNpbXBsZSwgaW50ZXJuYWwgT2JqZWN0LmFzc2lnbigpIHBvbHlmaWxsIGZvciBvcHRpb25zIG9iamVjdHMgZXRjLlxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3JjcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzcmNzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHNyY3MuZm9yRWFjaChmdW5jdGlvbiAoc3JjKSB7XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gdGd0W2tdID0gc3JjW2tdO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGd0O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU0ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuLypcbiAqIEF1eGlsaWFyeSBmdW5jdGlvbnNcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLkxpbmtlZExpc3Q7XG5cbnZhciBhdXhpbGlhcnkgPSB7fTtcblxuLy8gZ2V0IHRoZSB0b3AgbW9zdCBub2Rlc1xuYXV4aWxpYXJ5LmdldFRvcE1vc3ROb2RlcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbm9kZXNNYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGVzTWFwW25vZGVzW2ldLmlkKCldID0gdHJ1ZTtcbiAgfVxuICB2YXIgcm9vdHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBlbGUgPSBpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpWzBdO1xuICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGVzTWFwW3BhcmVudC5pZCgpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KClbMF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gcm9vdHM7XG59O1xuXG4vLyBmaW5kIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIGFuZCBjcmVhdGUgZHVtbXkgbm9kZXMgdGhhdCBjb25uZWN0IHRoZW1cbmF1eGlsaWFyeS5jb25uZWN0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdG9wTW9zdE5vZGVzLCBkdW1teU5vZGVzKSB7XG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdmlzaXRlZFRvcE1vc3ROb2RlcyA9IFtdO1xuICB2YXIgY3VycmVudE5laWdoYm9yID0gdm9pZCAwO1xuICB2YXIgbWluRGVncmVlTm9kZSA9IHZvaWQgMDtcbiAgdmFyIG1pbkRlZ3JlZSA9IHZvaWQgMDtcblxuICB2YXIgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgdmFyIGNvdW50ID0gMTtcbiAgdmFyIG5vZGVzQ29ubmVjdGVkVG9EdW1teSA9IFtdO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBjbXB0ID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGNvbXBvbmVudHMucHVzaChjbXB0KTtcblxuICAgIHZhciBjdXJyZW50Tm9kZSA9IHRvcE1vc3ROb2Rlc1swXTtcbiAgICB2YXIgY2hpbGRyZW5PZkN1cnJlbnROb2RlID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGNoaWxkcmVuT2ZDdXJyZW50Tm9kZS5tZXJnZShjdXJyZW50Tm9kZSkubWVyZ2UoY3VycmVudE5vZGUuZGVzY2VuZGFudHMoKS5pbnRlcnNlY3Rpb24oZWxlcykpO1xuICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XG5cbiAgICBjaGlsZHJlbk9mQ3VycmVudE5vZGUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgY21wdC5tZXJnZShub2RlKTtcbiAgICB9KTtcblxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgICB2YXIgbmVpZ2hib3JOb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGN1cnJlbnROb2RlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoZWxlcy5pbnRlcnNlY3Rpb24oY3VycmVudE5vZGUuZWRnZXNXaXRoKG5vZGUpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbmVpZ2hib3JOb2Rlcy5tZXJnZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcbiAgICAgICAgY3VycmVudE5laWdoYm9yID0gdG9wTW9zdE5vZGVzLmludGVyc2VjdGlvbihuZWlnaGJvck5vZGUudW5pb24obmVpZ2hib3JOb2RlLmFuY2VzdG9ycygpKSk7XG4gICAgICAgIGlmIChjdXJyZW50TmVpZ2hib3IgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yWzBdKSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3IudW5pb24oY3VycmVudE5laWdoYm9yLmRlc2NlbmRhbnRzKCkpO1xuXG4gICAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgICAgICAgIGNtcHQubWVyZ2Uobm9kZSk7XG4gICAgICAgICAgICBpZiAodG9wTW9zdE5vZGVzLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICBfbG9vcDIoKTtcbiAgICB9XG5cbiAgICBjbXB0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGVsZXMuaW50ZXJzZWN0aW9uKG5vZGUuY29ubmVjdGVkRWRnZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBjb25uZWN0ZWRFZGdlcygpIHVzdWFsbHkgY2FjaGVkXG4gICAgICAgIGlmIChjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgIC8vIGhhcygpIGlzIGNoZWFwXG4gICAgICAgICAgY21wdC5tZXJnZShlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAodmlzaXRlZFRvcE1vc3ROb2Rlcy5sZW5ndGggPT0gdG9wTW9zdE5vZGVzLmxlbmd0aCkge1xuICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNDb25uZWN0ZWQgfHwgaXNDb25uZWN0ZWQgJiYgY291bnQgPiAxKSB7XG4gICAgICBtaW5EZWdyZWVOb2RlID0gdmlzaXRlZFRvcE1vc3ROb2Rlc1swXTtcbiAgICAgIG1pbkRlZ3JlZSA9IG1pbkRlZ3JlZU5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGggPCBtaW5EZWdyZWUpIHtcbiAgICAgICAgICBtaW5EZWdyZWUgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgICAgICAgIG1pbkRlZ3JlZU5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5vZGVzQ29ubmVjdGVkVG9EdW1teS5wdXNoKG1pbkRlZ3JlZU5vZGUuaWQoKSk7XG4gICAgICAvLyBUTyBETzogQ2hlY2sgZWZmaWNpZW5jeSBvZiB0aGlzIHBhcnRcbiAgICAgIHZhciB0ZW1wID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgdGVtcC5tZXJnZSh2aXNpdGVkVG9wTW9zdE5vZGVzWzBdKTtcbiAgICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0ZW1wLm1lcmdlKG5vZGUpO1xuICAgICAgfSk7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzID0gW107XG4gICAgICB0b3BNb3N0Tm9kZXMgPSB0b3BNb3N0Tm9kZXMuZGlmZmVyZW5jZSh0ZW1wKTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9O1xuXG4gIGRvIHtcbiAgICBfbG9vcCgpO1xuICB9IHdoaWxlICghaXNDb25uZWN0ZWQpO1xuXG4gIGlmIChkdW1teU5vZGVzKSB7XG4gICAgaWYgKG5vZGVzQ29ubmVjdGVkVG9EdW1teS5sZW5ndGggPiAwKSB7XG4gICAgICBkdW1teU5vZGVzLnNldCgnZHVtbXknICsgKGR1bW15Tm9kZXMuc2l6ZSArIDEpLCBub2Rlc0Nvbm5lY3RlZFRvRHVtbXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50cztcbn07XG5cbi8vIHJlbG9jYXRlcyBjb21wb25lbnRSZXN1bHQgdG8gb3JpZ2luYWxDZW50ZXIgaWYgdGhlcmUgaXMgbm8gZml4ZWROb2RlQ29uc3RyYWludFxuYXV4aWxpYXJ5LnJlbG9jYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG9yaWdpbmFsQ2VudGVyLCBjb21wb25lbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICB2YXIgbWluWENvb3JkID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBtYXhYQ29vcmQgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pbllDb29yZCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4WUNvb3JkID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjb21wb25lbnRSZXN1bHQubm9kZUluZGV4ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgICAgICAgdmFyIGtleSA9IF9yZWYyWzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgdmFyIGN5Tm9kZSA9IG9wdGlvbnMuY3kuZ2V0RWxlbWVudEJ5SWQoa2V5KTtcbiAgICAgICAgICBpZiAoY3lOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUJCID0gY3lOb2RlLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB2YXIgbGVmdFggPSBjb21wb25lbnRSZXN1bHQueENvb3Jkc1t2YWx1ZV0gLSBub2RlQkIudyAvIDI7XG4gICAgICAgICAgICB2YXIgcmlnaHRYID0gY29tcG9uZW50UmVzdWx0LnhDb29yZHNbdmFsdWVdICsgbm9kZUJCLncgLyAyO1xuICAgICAgICAgICAgdmFyIHRvcFkgPSBjb21wb25lbnRSZXN1bHQueUNvb3Jkc1t2YWx1ZV0gLSBub2RlQkIuaCAvIDI7XG4gICAgICAgICAgICB2YXIgYm90dG9tWSA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzW3ZhbHVlXSArIG5vZGVCQi5oIC8gMjtcblxuICAgICAgICAgICAgaWYgKGxlZnRYIDwgbWluWENvb3JkKSBtaW5YQ29vcmQgPSBsZWZ0WDtcbiAgICAgICAgICAgIGlmIChyaWdodFggPiBtYXhYQ29vcmQpIG1heFhDb29yZCA9IHJpZ2h0WDtcbiAgICAgICAgICAgIGlmICh0b3BZIDwgbWluWUNvb3JkKSBtaW5ZQ29vcmQgPSB0b3BZO1xuICAgICAgICAgICAgaWYgKGJvdHRvbVkgPiBtYXhZQ29vcmQpIG1heFlDb29yZCA9IGJvdHRvbVk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIG9yaWdpbmFsIGNlbnRlclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaWZmT25YID0gb3JpZ2luYWxDZW50ZXIueCAtIChtYXhYQ29vcmQgKyBtaW5YQ29vcmQpIC8gMjtcbiAgICAgIHZhciBkaWZmT25ZID0gb3JpZ2luYWxDZW50ZXIueSAtIChtYXhZQ29vcmQgKyBtaW5ZQ29vcmQpIC8gMjtcbiAgICAgIC8vIG1vdmUgY29tcG9uZW50IHRvIG9yaWdpbmFsIGNlbnRlclxuICAgICAgY29tcG9uZW50UmVzdWx0LnhDb29yZHMgPSBjb21wb25lbnRSZXN1bHQueENvb3Jkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggKyBkaWZmT25YO1xuICAgICAgfSk7XG4gICAgICBjb21wb25lbnRSZXN1bHQueUNvb3JkcyA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICByZXR1cm4geSArIGRpZmZPblk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2FsY3VsYXRlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgICBPYmplY3Qua2V5cyhjb21wb25lbnRSZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRSZXN1bHRbaXRlbV07XG4gICAgICAgIHZhciBsZWZ0WCA9IG5vZGUuZ2V0UmVjdCgpLng7XG4gICAgICAgIHZhciByaWdodFggPSBub2RlLmdldFJlY3QoKS54ICsgbm9kZS5nZXRSZWN0KCkud2lkdGg7XG4gICAgICAgIHZhciB0b3BZID0gbm9kZS5nZXRSZWN0KCkueTtcbiAgICAgICAgdmFyIGJvdHRvbVkgPSBub2RlLmdldFJlY3QoKS55ICsgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgICAgIGlmIChsZWZ0WCA8IG1pblhDb29yZCkgbWluWENvb3JkID0gbGVmdFg7XG4gICAgICAgIGlmIChyaWdodFggPiBtYXhYQ29vcmQpIG1heFhDb29yZCA9IHJpZ2h0WDtcbiAgICAgICAgaWYgKHRvcFkgPCBtaW5ZQ29vcmQpIG1pbllDb29yZCA9IHRvcFk7XG4gICAgICAgIGlmIChib3R0b21ZID4gbWF4WUNvb3JkKSBtYXhZQ29vcmQgPSBib3R0b21ZO1xuICAgICAgfSk7XG4gICAgICAvLyBmaW5kIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIHZhciBfZGlmZk9uWCA9IG9yaWdpbmFsQ2VudGVyLnggLSAobWF4WENvb3JkICsgbWluWENvb3JkKSAvIDI7XG4gICAgICB2YXIgX2RpZmZPblkgPSBvcmlnaW5hbENlbnRlci55IC0gKG1heFlDb29yZCArIG1pbllDb29yZCkgLyAyO1xuICAgICAgLy8gbW92ZSBjb21wb25lbnQgdG8gb3JpZ2luYWwgY2VudGVyXG4gICAgICBPYmplY3Qua2V5cyhjb21wb25lbnRSZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRSZXN1bHRbaXRlbV07XG4gICAgICAgIG5vZGUuc2V0Q2VudGVyKG5vZGUuZ2V0Q2VudGVyWCgpICsgX2RpZmZPblgsIG5vZGUuZ2V0Q2VudGVyWSgpICsgX2RpZmZPblkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG5hdXhpbGlhcnkuY2FsY0JvdW5kaW5nQm94ID0gZnVuY3Rpb24gKHBhcmVudE5vZGUsIHhDb29yZHMsIHlDb29yZHMsIG5vZGVJbmRleGVzKSB7XG4gIC8vIGNhbGN1bGF0ZSBib3VuZHNcbiAgdmFyIGxlZnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIHJpZ2h0ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gIHZhciB0b3AgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIGJvdHRvbSA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB2YXIgbm9kZUxlZnQgPSB2b2lkIDA7XG4gIHZhciBub2RlUmlnaHQgPSB2b2lkIDA7XG4gIHZhciBub2RlVG9wID0gdm9pZCAwO1xuICB2YXIgbm9kZUJvdHRvbSA9IHZvaWQgMDtcblxuICB2YXIgbm9kZXMgPSBwYXJlbnROb2RlLmRlc2NlbmRhbnRzKCkubm90KFwiOnBhcmVudFwiKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIG5vZGVMZWZ0ID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gLSBub2RlLndpZHRoKCkgLyAyO1xuICAgIG5vZGVSaWdodCA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldICsgbm9kZS53aWR0aCgpIC8gMjtcbiAgICBub2RlVG9wID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gLSBub2RlLmhlaWdodCgpIC8gMjtcbiAgICBub2RlQm90dG9tID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gKyBub2RlLmhlaWdodCgpIC8gMjtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ0JveCA9IHt9O1xuICBib3VuZGluZ0JveC50b3BMZWZ0WCA9IGxlZnQ7XG4gIGJvdW5kaW5nQm94LnRvcExlZnRZID0gdG9wO1xuICBib3VuZGluZ0JveC53aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgYm91bmRpbmdCb3guaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICByZXR1cm4gYm91bmRpbmdCb3g7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGZpbmRzIGFuZCByZXR1cm5zIHBhcmVudCBub2RlcyB3aG9zZSBhbGwgY2hpbGRyZW4gYXJlIGhpZGRlblxuYXV4aWxpYXJ5LmNhbGNQYXJlbnRzV2l0aG91dENoaWxkcmVuID0gZnVuY3Rpb24gKGN5LCBlbGVzKSB7XG4gIHZhciBwYXJlbnRzV2l0aG91dENoaWxkcmVuID0gY3kuY29sbGVjdGlvbigpO1xuICBlbGVzLm5vZGVzKCc6cGFyZW50JykuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgdmFyIGNoZWNrID0gZmFsc2U7XG4gICAgcGFyZW50LmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5jc3MoJ2Rpc3BsYXknKSAhPSAnbm9uZScpIHtcbiAgICAgICAgY2hlY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4ubWVyZ2UocGFyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJlbnRzV2l0aG91dENoaWxkcmVuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdXhpbGlhcnk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG4vKipcbiAgVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwb3N0cHJvY2Vzc2luZyBwYXJ0IHRoYXQgYXBwbGllcyBDb1NFIGxheW91dCBvdmVyIHRoZSBzcGVjdHJhbCBsYXlvdXRcbiovXG5cbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG52YXIgQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5Db1NFTGF5b3V0O1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VOb2RlO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLlBvaW50RDtcbnZhciBEaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuRGltZW5zaW9uRDtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5MYXlvdXRDb25zdGFudHM7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5GRExheW91dENvbnN0YW50cztcbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VDb25zdGFudHM7XG5cbi8vIG1haW4gZnVuY3Rpb24gdGhhdCBjb3NlIGxheW91dCBpcyBwcm9jZXNzZWRcbnZhciBjb3NlTGF5b3V0ID0gZnVuY3Rpb24gY29zZUxheW91dChvcHRpb25zLCBzcGVjdHJhbFJlc3VsdCkge1xuXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcblxuICB2YXIgbm9kZUluZGV4ZXMgPSB2b2lkIDA7XG4gIHZhciB4Q29vcmRzID0gdm9pZCAwO1xuICB2YXIgeUNvb3JkcyA9IHZvaWQgMDtcbiAgdmFyIGlkVG9MTm9kZSA9IHt9O1xuXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIG5vZGVJbmRleGVzID0gc3BlY3RyYWxSZXN1bHRbXCJub2RlSW5kZXhlc1wiXTtcbiAgICB4Q29vcmRzID0gc3BlY3RyYWxSZXN1bHRbXCJ4Q29vcmRzXCJdO1xuICAgIHlDb29yZHMgPSBzcGVjdHJhbFJlc3VsdFtcInlDb29yZHNcIl07XG4gIH1cblxuICB2YXIgaXNGbiA9IGZ1bmN0aW9uIGlzRm4oZm4pIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nO1xuICB9O1xuXG4gIHZhciBvcHRGbiA9IGZ1bmN0aW9uIG9wdEZuKG9wdCwgZWxlKSB7XG4gICAgaWYgKGlzRm4ob3B0KSkge1xuICAgICAgcmV0dXJuIG9wdChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0O1xuICAgIH1cbiAgfTtcblxuICAvKioqKiBQb3N0cHJvY2Vzc2luZyBmdW5jdGlvbnMgKioqKi9cblxuICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGF1eC5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbihjeSwgZWxlcyk7XG5cbiAgLy8gdHJhbnNmZXIgY3l0b3NjYXBlIG5vZGVzIHRvIGNvc2Ugbm9kZXNcbiAgdmFyIHByb2Nlc3NDaGlsZHJlbkxpc3QgPSBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRyZW5MaXN0KHBhcmVudCwgY2hpbGRyZW4sIGxheW91dCwgb3B0aW9ucykge1xuICAgIHZhciBzaXplID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBjaGlsZHJlbl9vZl9jaGlsZHJlbiA9IG51bGw7XG4gICAgICBpZiAodGhlQ2hpbGQuaW50ZXJzZWN0aW9uKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNoaWxkcmVuX29mX2NoaWxkcmVuID0gdGhlQ2hpbGQuY2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGVOb2RlID0gdm9pZCAwO1xuXG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoZUNoaWxkLmxheW91dERpbWVuc2lvbnMoe1xuICAgICAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoZUNoaWxkLm91dGVyV2lkdGgoKSAhPSBudWxsICYmIHRoZUNoaWxkLm91dGVySGVpZ2h0KCkgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgICBpZiAoIXRoZUNoaWxkLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHRoZUNoaWxkLmlkKCkpXSAtIGRpbWVuc2lvbnMudyAvIDIsIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHRoZUNoaWxkLmlkKCkpXSAtIGRpbWVuc2lvbnMuaCAvIDIpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcmVudEluZm8gPSBhdXguY2FsY0JvdW5kaW5nQm94KHRoZUNoaWxkLCB4Q29vcmRzLCB5Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICBpZiAodGhlQ2hpbGQuaW50ZXJzZWN0aW9uKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHBhcmVudEluZm8udG9wTGVmdFgsIHBhcmVudEluZm8udG9wTGVmdFkpLCBuZXcgRGltZW5zaW9uRChwYXJlbnRJbmZvLndpZHRoLCBwYXJlbnRJbmZvLmhlaWdodCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgcGFyZW50c1dpdGhvdXRDaGlsZHJlblxuICAgICAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RChwYXJlbnRJbmZvLnRvcExlZnRYLCBwYXJlbnRJbmZvLnRvcExlZnRZKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHRoZUNoaWxkLnBvc2l0aW9uKCd4JykgLSBkaW1lbnNpb25zLncgLyAyLCB0aGVDaGlsZC5wb3NpdGlvbigneScpIC0gZGltZW5zaW9ucy5oIC8gMiksIG5ldyBEaW1lbnNpb25EKHBhcnNlRmxvYXQoZGltZW5zaW9ucy53KSwgcGFyc2VGbG9hdChkaW1lbnNpb25zLmgpKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIpKTtcbiAgICAgIH1cbiAgICAgIC8vIEF0dGFjaCBpZCB0byB0aGUgbGF5b3V0IG5vZGUgYW5kIHJlcHVsc2lvbiB2YWx1ZVxuICAgICAgdGhlTm9kZS5pZCA9IHRoZUNoaWxkLmRhdGEoXCJpZFwiKTtcbiAgICAgIHRoZU5vZGUubm9kZVJlcHVsc2lvbiA9IG9wdEZuKG9wdGlvbnMubm9kZVJlcHVsc2lvbiwgdGhlQ2hpbGQpO1xuICAgICAgLy8gQXR0YWNoIHRoZSBwYWRkaW5ncyBvZiBjeSBub2RlIHRvIGxheW91dCBub2RlXG4gICAgICB0aGVOb2RlLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nVG9wID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nUmlnaHQgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgICB0aGVOb2RlLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG5cbiAgICAgIC8vQXR0YWNoIHRoZSBsYWJlbCBwcm9wZXJ0aWVzIHRvIGJvdGggY29tcG91bmQgYW5kIHNpbXBsZSBub2RlcyBpZiBsYWJlbHMgd2lsbCBiZSBpbmNsdWRlZCBpbiBub2RlIGRpbWVuc2lvbnNcbiAgICAgIC8vVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgd2hpbGUgdXBkYXRpbmcgYm91bmRzIG9mIGNvbXBvdW5kcyBkdXJpbmcgaXRlcmF0aW9ucyBvciB0aWxpbmdcbiAgICAgIC8vYW5kIHdpbGwgYmUgdXNlZCBmb3Igc2ltcGxlIG5vZGVzIHdoaWxlIHRyYW5zZmVycmluZyBmaW5hbCBwb3NpdGlvbnMgdG8gY3l0b3NjYXBlXG4gICAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFdpZHRoID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlLCBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlIH0pLnc7XG4gICAgICAgIHRoZU5vZGUubGFiZWxIZWlnaHQgPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UsIGluY2x1ZGVPdmVybGF5czogZmFsc2UgfSkuaDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID0gdGhlQ2hpbGQuY3NzKFwidGV4dC12YWxpZ25cIik7XG4gICAgICAgIHRoZU5vZGUubGFiZWxQb3NIb3Jpem9udGFsID0gdGhlQ2hpbGQuY3NzKFwidGV4dC1oYWxpZ25cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCB0aGUgbGF5b3V0IG5vZGVcbiAgICAgIGlkVG9MTm9kZVt0aGVDaGlsZC5kYXRhKFwiaWRcIildID0gdGhlTm9kZTtcblxuICAgICAgaWYgKGlzTmFOKHRoZU5vZGUucmVjdC54KSkge1xuICAgICAgICB0aGVOb2RlLnJlY3QueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueSkpIHtcbiAgICAgICAgdGhlTm9kZS5yZWN0LnkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGRyZW5fb2ZfY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbl9vZl9jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0aGVOZXdHcmFwaCA9IHZvaWQgMDtcbiAgICAgICAgdGhlTmV3R3JhcGggPSBsYXlvdXQuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKGxheW91dC5uZXdHcmFwaCgpLCB0aGVOb2RlKTtcbiAgICAgICAgcHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGVOZXdHcmFwaCwgY2hpbGRyZW5fb2ZfY2hpbGRyZW4sIGxheW91dCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHRyYW5zZmVyIGN5dG9zY2FwZSBlZGdlcyB0byBjb3NlIGVkZ2VzXG4gIHZhciBwcm9jZXNzRWRnZXMgPSBmdW5jdGlvbiBwcm9jZXNzRWRnZXMobGF5b3V0LCBnbSwgZWRnZXMpIHtcbiAgICB2YXIgaWRlYWxMZW5ndGhUb3RhbCA9IDA7XG4gICAgdmFyIGVkZ2VDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBzb3VyY2VOb2RlID0gaWRUb0xOb2RlW2VkZ2UuZGF0YShcInNvdXJjZVwiKV07XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGlkVG9MTm9kZVtlZGdlLmRhdGEoXCJ0YXJnZXRcIildO1xuICAgICAgaWYgKHNvdXJjZU5vZGUgJiYgdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlICE9PSB0YXJnZXROb2RlICYmIHNvdXJjZU5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHRhcmdldE5vZGUpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHZhciBlMSA9IGdtLmFkZChsYXlvdXQubmV3RWRnZSgpLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKTtcbiAgICAgICAgZTEuaWQgPSBlZGdlLmlkKCk7XG4gICAgICAgIGUxLmlkZWFsTGVuZ3RoID0gb3B0Rm4ob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgsIGVkZ2UpO1xuICAgICAgICBlMS5lZGdlRWxhc3RpY2l0eSA9IG9wdEZuKG9wdGlvbnMuZWRnZUVsYXN0aWNpdHksIGVkZ2UpO1xuICAgICAgICBpZGVhbExlbmd0aFRvdGFsICs9IGUxLmlkZWFsTGVuZ3RoO1xuICAgICAgICBlZGdlQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgdGhlIGlkZWFsIGVkZ2UgbGVuZ3RoIGNvbnN0YW50IHdpdGggdGhlIGF2Zy4gaWRlYWwgbGVuZ3RoIHZhbHVlIGFmdGVyIHByb2Nlc3NpbmcgZWRnZXNcbiAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UsIHVzZSBvdGhlciBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIGlmIChlZGdlQ291bnQgPiAwKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gaWRlYWxMZW5ndGhUb3RhbCAvIGVkZ2VDb3VudDtlbHNlIGlmICghaXNGbihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkpIC8vIGluIGNhc2UgdGhlcmUgaXMgbm8gZWRnZSwgYnV0IG9wdGlvbiBnaXZlcyBhIHZhbHVlIHRvIHVzZVxuICAgICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7ZWxzZSAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UgYW5kIHdlIGNhbm5vdCBnZXQgYSB2YWx1ZSBmcm9tIG9wdGlvbiAoYmVjYXVzZSBpdCdzIGEgZnVuY3Rpb24pXG4gICAgICAgIENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSA1MDtcbiAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiYXNlZCBvbiB0aGUgaWRlYWwgZWRnZSBsZW5ndGggY29uc3RhbnRcbiAgICAgIENvU0VDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwLjA7XG4gICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cbiAgfTtcblxuICAvLyB0cmFuc2ZlciBjeXRvc2NhcGUgY29uc3RyYWludHMgdG8gY29zZSBsYXlvdXRcbiAgdmFyIHByb2Nlc3NDb25zdHJhaW50cyA9IGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cyhsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgZml4ZWRcbiAgICBpZiAob3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgICBsYXlvdXQuY29uc3RyYWludHNbXCJmaXhlZE5vZGVDb25zdHJhaW50XCJdID0gb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50O1xuICAgIH1cbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgYWxpZ25lZFxuICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGxheW91dC5jb25zdHJhaW50c1tcImFsaWdubWVudENvbnN0cmFpbnRcIl0gPSBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQ7XG4gICAgfVxuICAgIC8vIGdldCBub2RlcyB0byBiZSByZWxhdGl2ZWx5IHBsYWNlZFxuICAgIGlmIChvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgbGF5b3V0LmNvbnN0cmFpbnRzW1wicmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50XCJdID0gb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKioqIEFwcGx5IHBvc3Rwcm9jZXNzaW5nICoqKiovXG4gIGlmIChvcHRpb25zLm5lc3RpbmdGYWN0b3IgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eTtcbiAgaWYgKG9wdGlvbnMubnVtSXRlciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBvcHRpb25zLm51bUl0ZXI7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2U7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw7XG5cbiAgaWYgKG9wdGlvbnMudGlsaW5nQ29tcGFyZUJ5ICE9IG51bGwpIENvU0VDb25zdGFudHMuVElMSU5HX0NPTVBBUkVfQlkgPSBvcHRpb25zLnRpbGluZ0NvbXBhcmVCeTtcblxuICBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdwcm9vZicpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMjtlbHNlIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMDtcblxuICBDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IEZETGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscztcbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBDb1NFQ29uc3RhbnRzLkFOSU1BVEUgPSBGRExheW91dENvbnN0YW50cy5BTklNQVRFID0gTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBvcHRpb25zLmFuaW1hdGU7XG4gIENvU0VDb25zdGFudHMuVElMRSA9IG9wdGlvbnMudGlsZTtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDtcblxuICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSB0cnVlO1xuICBDb1NFQ29uc3RhbnRzLlBVUkVfSU5DUkVNRU5UQUwgPSAhb3B0aW9ucy5yYW5kb21pemU7XG4gIExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTID0gb3B0aW9ucy51bmlmb3JtTm9kZURpbWVuc2lvbnM7XG5cbiAgLy8gVGhpcyBwYXJ0IGlzIGZvciBkZWJ1Zy9kZW1vIHB1cnBvc2VcbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcInRyYW5zZm9ybWVkXCIpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gdHJ1ZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLnN0ZXAgPT0gXCJlbmZvcmNlZFwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiY29zZVwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiYWxsXCIpIHtcbiAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSB0cnVlO2Vsc2UgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQgfHwgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IHRydWU7XG4gIH1cblxuICB2YXIgY29zZUxheW91dCA9IG5ldyBDb1NFTGF5b3V0KCk7XG4gIHZhciBnbSA9IGNvc2VMYXlvdXQubmV3R3JhcGhNYW5hZ2VyKCk7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuTGlzdChnbS5hZGRSb290KCksIGF1eC5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBjb3NlTGF5b3V0LCBvcHRpb25zKTtcbiAgcHJvY2Vzc0VkZ2VzKGNvc2VMYXlvdXQsIGdtLCBlZGdlcyk7XG4gIHByb2Nlc3NDb25zdHJhaW50cyhjb3NlTGF5b3V0LCBvcHRpb25zKTtcblxuICBjb3NlTGF5b3V0LnJ1bkxheW91dCgpO1xuXG4gIHJldHVybiBpZFRvTE5vZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgY29zZUxheW91dDogY29zZUxheW91dCB9O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjEyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZmNvc2UgbGF5b3V0IGFsZ29yaXRobVxuKi9cblxudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjU4KTtcbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjU3KSxcbiAgICBzcGVjdHJhbExheW91dCA9IF9yZXF1aXJlLnNwZWN0cmFsTGF5b3V0O1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYpLFxuICAgIGNvc2VMYXlvdXQgPSBfcmVxdWlyZTIuY29zZUxheW91dDtcblxudmFyIGRlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG5cbiAgLy8gJ2RyYWZ0JywgJ2RlZmF1bHQnIG9yICdwcm9vZicgXG4gIC8vIC0gJ2RyYWZ0JyBvbmx5IGFwcGxpZXMgc3BlY3RyYWwgbGF5b3V0IFxuICAvLyAtICdkZWZhdWx0JyBpbXByb3ZlcyB0aGUgcXVhbGl0eSB3aXRoIHN1YnNlcXVlbnQgQ29TRSBsYXlvdXQgKGZhc3QgY29vbGluZyByYXRlKVxuICAvLyAtICdwcm9vZicgaW1wcm92ZXMgdGhlIHF1YWxpdHkgd2l0aCBzdWJzZXF1ZW50IENvU0UgbGF5b3V0IChzbG93IGNvb2xpbmcgcmF0ZSkgXG4gIHF1YWxpdHk6IFwiZGVmYXVsdFwiLFxuICAvLyBVc2UgcmFuZG9tIG5vZGUgcG9zaXRpb25zIGF0IGJlZ2lubmluZyBvZiBsYXlvdXRcbiAgLy8gaWYgdGhpcyBpcyBzZXQgdG8gZmFsc2UsIHRoZW4gcXVhbGl0eSBvcHRpb24gbXVzdCBiZSBcInByb29mXCJcbiAgcmFuZG9taXplOiB0cnVlLFxuICAvLyBXaGV0aGVyIG9yIG5vdCB0byBhbmltYXRlIHRoZSBsYXlvdXRcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgLy8gRHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zLCBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAvLyBFYXNpbmcgb2YgYW5pbWF0aW9uLCBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBGaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSByZXBvc2l0aW9uZWQgbm9kZXNcbiAgZml0OiB0cnVlLFxuICAvLyBQYWRkaW5nIGFyb3VuZCBsYXlvdXRcbiAgcGFkZGluZzogMzAsXG4gIC8vIFdoZXRoZXIgdG8gaW5jbHVkZSBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zLiBWYWxpZCBpbiBcInByb29mXCIgcXVhbGl0eVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBXaGV0aGVyIG9yIG5vdCBzaW1wbGUgbm9kZXMgKG5vbi1jb21wb3VuZCBub2RlcykgYXJlIG9mIHVuaWZvcm0gZGltZW5zaW9uc1xuICB1bmlmb3JtTm9kZURpbWVuc2lvbnM6IGZhbHNlLFxuICAvLyBXaGV0aGVyIHRvIHBhY2sgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgLSB2YWxpZCBvbmx5IGlmIHJhbmRvbWl6ZTogdHJ1ZVxuICBwYWNrQ29tcG9uZW50czogdHJ1ZSxcbiAgLy8gTGF5b3V0IHN0ZXAgLSBhbGwsIHRyYW5zZm9ybWVkLCBlbmZvcmNlZCwgY29zZSAtIGZvciBkZWJ1ZyBwdXJwb3NlIG9ubHlcbiAgc3RlcDogXCJhbGxcIixcblxuICAvKiBzcGVjdHJhbCBsYXlvdXQgb3B0aW9ucyAqL1xuXG4gIC8vIEZhbHNlIGZvciByYW5kb20sIHRydWUgZm9yIGdyZWVkeVxuICBzYW1wbGluZ1R5cGU6IHRydWUsXG4gIC8vIFNhbXBsZSBzaXplIHRvIGNvbnN0cnVjdCBkaXN0YW5jZSBtYXRyaXhcbiAgc2FtcGxlU2l6ZTogMjUsXG4gIC8vIFNlcGFyYXRpb24gYW1vdW50IGJldHdlZW4gbm9kZXNcbiAgbm9kZVNlcGFyYXRpb246IDc1LFxuICAvLyBQb3dlciBpdGVyYXRpb24gdG9sZXJhbmNlXG4gIHBpVG9sOiAwLjAwMDAwMDEsXG5cbiAgLyogQ29TRSBsYXlvdXQgb3B0aW9ucyAqL1xuXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIDQ1MDA7XG4gIH0sXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDUwO1xuICB9LFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IGZ1bmN0aW9uIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICByZXR1cm4gMC40NTtcbiAgfSxcbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yOiAwLjEsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5OiAwLjI1LFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMjUwMCxcbiAgLy8gRm9yIGVuYWJsaW5nIHRpbGluZ1xuICB0aWxlOiB0cnVlLFxuICAvLyBUaGUgZnVuY3Rpb24gdGhhdCBzcGVjaWZpZXMgdGhlIGNyaXRlcmlhIGZvciBjb21wYXJpbmcgbm9kZXMgd2hpbGUgc29ydGluZyB0aGVtIGR1cmluZyB0aWxpbmcgb3BlcmF0aW9uLlxuICAvLyBUYWtlcyB0aGUgbm9kZSBpZCBhcyBhIHBhcmFtZXRlciBhbmQgdGhlIGRlZmF1bHQgdGlsaW5nIG9wZXJhdGlvbiBpcyBwZXJmb21lZCB3aGVuIHRoaXMgb3B0aW9uIGlzIG5vdCBzZXQuXG4gIHRpbGluZ0NvbXBhcmVCeTogdW5kZWZpbmVkLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIHZlcnRpY2FsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nVmVydGljYWw6IDEwLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIGhvcml6b250YWwgc3BhY2UgdG8gcHV0IGJldHdlZW4gdGhlIHplcm8gZGVncmVlIG1lbWJlcnMgZHVyaW5nIHRoZSB0aWxpbmcgb3BlcmF0aW9uKGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24pXG4gIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsOiAxMCxcbiAgLy8gR3Jhdml0eSByYW5nZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eVJhbmdlQ29tcG91bmQ6IDEuNSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eUNvbXBvdW5kOiAxLjAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KVxuICBncmF2aXR5UmFuZ2U6IDMuOCxcbiAgLy8gSW5pdGlhbCBjb29saW5nIGZhY3RvciBmb3IgaW5jcmVtZW50YWwgbGF5b3V0ICBcbiAgaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw6IDAuMyxcblxuICAvKiBjb25zdHJhaW50IG9wdGlvbnMgKi9cblxuICAvLyBGaXggcmVxdWlyZWQgbm9kZXMgdG8gcHJlZGVmaW5lZCBwb3NpdGlvbnNcbiAgLy8gW3tub2RlSWQ6ICduMScsIHBvc2l0aW9uOiB7eDogMTAwLCB5OiAyMDB9LCB7Li4ufV1cbiAgZml4ZWROb2RlQ29uc3RyYWludDogdW5kZWZpbmVkLFxuICAvLyBBbGlnbiByZXF1aXJlZCBub2RlcyBpbiB2ZXJ0aWNhbC9ob3Jpem9udGFsIGRpcmVjdGlvblxuICAvLyB7dmVydGljYWw6IFtbJ24xJywgJ24yJyldLCBbJ24zJywgJ240J11dLCBob3Jpem9udGFsOiBbJ24yJywgJ240J119XG4gIGFsaWdubWVudENvbnN0cmFpbnQ6IHVuZGVmaW5lZCxcbiAgLy8gUGxhY2UgdHdvIG5vZGVzIHJlbGF0aXZlbHkgaW4gdmVydGljYWwvaG9yaXpvbnRhbCBkaXJlY3Rpb24gXG4gIC8vIFt7dG9wOiAnbjEnLCBib3R0b206ICduMicsIGdhcDogMTAwfSwge2xlZnQ6ICduMycsIHJpZ2h0OiAnbjQnLCBnYXA6IDc1fV1cbiAgcmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50OiB1bmRlZmluZWQsXG5cbiAgLyogbGF5b3V0IGV2ZW50IGNhbGxiYWNrcyAqL1xuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9IC8vIG9uIGxheW91dHN0b3Bcbn0pO1xuXG52YXIgTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXlvdXQpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGF5b3V0LCBbe1xuICAgIGtleTogJ3J1bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgICAgIHZhciBzcGVjdHJhbFJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHhDb29yZHMgPSB2b2lkIDA7XG4gICAgICB2YXIgeUNvb3JkcyA9IHZvaWQgMDtcbiAgICAgIHZhciBjb3NlUmVzdWx0ID0gW107XG4gICAgICB2YXIgY29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICAgIHZhciBjb21wb25lbnRDZW50ZXJzID0gW107XG5cbiAgICAgIC8vIGJhc2ljIHZhbGlkaXR5IGNoZWNrIGZvciBjb25zdHJhaW50IGlucHV0cyBcbiAgICAgIGlmIChvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCkgfHwgb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aCA9PSAwKSkge1xuICAgICAgICBvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwubGVuZ3RoID09IDApKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsLmxlbmd0aCA9PSAwKSkge1xuICAgICAgICAgIG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHx8IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50Lmxlbmd0aCA9PSAwKSkge1xuICAgICAgICBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYW55IGNvbnN0cmFpbnQgZXhpc3RzLCBzZXQgc29tZSBvcHRpb25zXG4gICAgICB2YXIgY29uc3RyYWludEV4aXN0ID0gb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50IHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludCB8fCBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDtcbiAgICAgIGlmIChjb25zdHJhaW50RXhpc3QpIHtcbiAgICAgICAgLy8gY29uc3RyYWludHMgd29yayB3aXRoIHRoZXNlIG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucy50aWxlID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMucGFja0NvbXBvbmVudHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVjaWRlIGNvbXBvbmVudCBwYWNraW5nIGlzIGVuYWJsZWQgb3Igbm90XG4gICAgICB2YXIgbGF5VXRpbCA9IHZvaWQgMDtcbiAgICAgIHZhciBwYWNraW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKGN5LmxheW91dFV0aWxpdGllcyAmJiBvcHRpb25zLnBhY2tDb21wb25lbnRzKSB7XG4gICAgICAgIGxheVV0aWwgPSBjeS5sYXlvdXRVdGlsaXRpZXMoXCJnZXRcIik7XG4gICAgICAgIGlmICghbGF5VXRpbCkgbGF5VXRpbCA9IGN5LmxheW91dFV0aWxpdGllcygpO1xuICAgICAgICBwYWNraW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVzLm5vZGVzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBpZiBwYWNraW5nIGlzIG5vdCBlbmFibGVkLCBwZXJmb3JtIGxheW91dCBvbiB0aGUgd2hvbGUgZ3JhcGhcbiAgICAgICAgaWYgKCFwYWNraW5nRW5hYmxlZCkge1xuICAgICAgICAgIC8vIHN0b3JlIGNvbXBvbmVudCBjZW50ZXJcbiAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBvcHRpb25zLmVsZXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBib3VuZGluZ0JveC54MSArIGJvdW5kaW5nQm94LncgLyAyLCB5OiBib3VuZGluZ0JveC55MSArIGJvdW5kaW5nQm94LmggLyAyIH0pO1xuICAgICAgICAgIC8vIGFwcGx5IHNwZWN0cmFsIGxheW91dFxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpO1xuICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhcHBseSBjb3NlIGxheW91dCBhcyBwb3N0cHJvY2Vzc2luZ1xuICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgICAgY29zZVJlc3VsdC5wdXNoKGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHRbMF0pKTtcbiAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzWzBdLCBjb3NlUmVzdWx0WzBdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzWzBdLCBzcGVjdHJhbFJlc3VsdFswXSwgb3B0aW9ucyk7IC8vIHJlbG9jYXRlIGNlbnRlciB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwYWNraW5nIGlzIGVuYWJsZWRcbiAgICAgICAgICB2YXIgdG9wTW9zdE5vZGVzID0gYXV4LmdldFRvcE1vc3ROb2RlcyhvcHRpb25zLmVsZXMubm9kZXMoKSk7XG4gICAgICAgICAgY29tcG9uZW50cyA9IGF1eC5jb25uZWN0Q29tcG9uZW50cyhjeSwgb3B0aW9ucy5lbGVzLCB0b3BNb3N0Tm9kZXMpO1xuICAgICAgICAgIC8vIHN0b3JlIGNvbXBvbmVudCBjZW50ZXJzXG4gICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IGNvbXBvbmVudC5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgY29tcG9uZW50Q2VudGVycy5wdXNoKHsgeDogYm91bmRpbmdCb3gueDEgKyBib3VuZGluZ0JveC53IC8gMiwgeTogYm91bmRpbmdCb3gueTEgKyBib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vc2VuZCBlYWNoIGNvbXBvbmVudCB0byBzcGVjdHJhbCBsYXlvdXQgaWYgcmFuZG9taXplZFxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5lbGVzID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5wdXNoKHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgICAgdmFyIHRvQmVUaWxlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGlsZSkge1xuICAgICAgICAgICAgICAvLyBiZWhhdmUgbm9kZXMgdG8gYmUgdGlsZWQgYXMgb25lIGNvbXBvbmVudFxuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIHZhciBfeENvb3JkcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgX3lDb29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdmFyIHRlbXBTcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiBfeENvb3JkcywgeUNvb3JkczogX3lDb29yZHMgfTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ZXNUb0JlRGVsZXRlZCA9IFtdO1xuICAgICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmVkZ2VzKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9CZVRpbGVkTm9kZXMubWVyZ2UoY29tcG9uZW50Lm5vZGVzKClbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC5ub2RlSW5kZXhlcy5zZXQoY29tcG9uZW50Lm5vZGVzKClbaV0uaWQoKSwgY291bnQrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcFNwZWN0cmFsUmVzdWx0LnhDb29yZHMucHVzaChjb21wb25lbnQubm9kZXMoKVswXS5wb3NpdGlvbigpLngpO1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC55Q29vcmRzLnB1c2goY29tcG9uZW50Lm5vZGVzKClbMF0ucG9zaXRpb24oKS55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpbmRleGVzVG9CZURlbGV0ZWQucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHRvQmVUaWxlZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2JvdW5kaW5nQm94ID0gdG9CZVRpbGVkTm9kZXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBfYm91bmRpbmdCb3gueDEgKyBfYm91bmRpbmdCb3gudyAvIDIsIHk6IF9ib3VuZGluZ0JveC55MSArIF9ib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2godG9CZVRpbGVkTm9kZXMpO1xuICAgICAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnB1c2godGVtcFNwZWN0cmFsUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXhlc1RvQmVEZWxldGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQuc3BsaWNlKGluZGV4ZXNUb0JlRGVsZXRlZFtpXSwgMSk7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAvLyBzZW5kIGVhY2ggY29tcG9uZW50IHRvIGNvc2UgbGF5b3V0XG4gICAgICAgICAgICAgIG9wdGlvbnMuZWxlcyA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgY29zZVJlc3VsdC5wdXNoKGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdKSk7XG4gICAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzW2luZGV4XSwgY29zZVJlc3VsdFtpbmRleF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgYXV4LnJlbG9jYXRlQ29tcG9uZW50KGNvbXBvbmVudENlbnRlcnNbaW5kZXhdLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBhY2tpbmdcbiAgICAgICAgICB2YXIgY29tcG9uZW50c0V2YWx1YXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgc3ViZ3JhcGhzID0gW107XG4gICAgICAgICAgICB2YXIgaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZS5jc3MoJ2Rpc3BsYXknKSA9PSAnbm9uZSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4ZXMgPSBzcGVjdHJhbFJlc3VsdFtpbmRleF0ubm9kZUluZGV4ZXM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm5vZGVzKCkubm90KGhpZGRlbkVsZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViZ3JhcGggPSB7fTtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHN1YmdyYXBoLm5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQubm9kZXMoKS5ub3QoaGlkZGVuRWxlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHNbbm9kZUluZGV4XSAtIG5vZGUuYm91bmRpbmdib3goKS53IC8gMiwgeTogc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbbm9kZUluZGV4XSAtIG5vZGUuYm91bmRpbmdib3goKS5oIC8gMiwgd2lkdGg6IG5vZGUuYm91bmRpbmdib3goKS53LCBoZWlnaHQ6IG5vZGUuYm91bmRpbmdib3goKS5oIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveChub2RlLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogcGFyZW50SW5mby50b3BMZWZ0WCwgeTogcGFyZW50SW5mby50b3BMZWZ0WSwgd2lkdGg6IHBhcmVudEluZm8ud2lkdGgsIGhlaWdodDogcGFyZW50SW5mby5oZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMucHVzaCh7IHg6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0TGVmdCgpLCB5OiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldFRvcCgpLCB3aWR0aDogY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXS5nZXRXaWR0aCgpLCBoZWlnaHQ6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0SGVpZ2h0KCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jc3MoXCJkaXNwbGF5XCIpICE9IFwibm9uZVwiICYmIHRhcmdldC5jc3MoXCJkaXNwbGF5XCIpICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChzb3VyY2UuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldE5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldCh0YXJnZXQuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNlbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRDZW50ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveChzb3VyY2UsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkcywgbm9kZUluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2VudGVyLnB1c2gocGFyZW50SW5mby50b3BMZWZ0WCArIHBhcmVudEluZm8ud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHBhcmVudEluZm8udG9wTGVmdFkgKyBwYXJlbnRJbmZvLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkc1tzb3VyY2VOb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzW3NvdXJjZU5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3godGFyZ2V0LCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKF9wYXJlbnRJbmZvLnRvcExlZnRYICsgX3BhcmVudEluZm8ud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKF9wYXJlbnRJbmZvLnRvcExlZnRZICsgX3BhcmVudEluZm8uaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzW3RhcmdldE5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyLnB1c2goc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbdGFyZ2V0Tm9kZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLmVkZ2VzLnB1c2goeyBzdGFydFg6IHNvdXJjZUNlbnRlclswXSwgc3RhcnRZOiBzb3VyY2VDZW50ZXJbMV0sIGVuZFg6IHRhcmdldENlbnRlclswXSwgZW5kWTogdGFyZ2V0Q2VudGVyWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0gJiYgY29zZVJlc3VsdFtpbmRleF1bdGFyZ2V0LmlkKCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcy5wdXNoKHsgc3RhcnRYOiBjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0uZ2V0Q2VudGVyWCgpLCBzdGFydFk6IGNvc2VSZXN1bHRbaW5kZXhdW3NvdXJjZS5pZCgpXS5nZXRDZW50ZXJZKCksIGVuZFg6IGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXS5nZXRDZW50ZXJYKCksIGVuZFk6IGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXS5nZXRDZW50ZXJZKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmdyYXBoLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHN1YmdyYXBocy5wdXNoKHN1YmdyYXBoKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNFdmFsdWF0ZWQuYWRkKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNoaWZ0UmVzdWx0ID0gbGF5VXRpbC5wYWNrQ29tcG9uZW50cyhzdWJncmFwaHMsIG9wdGlvbnMucmFuZG9taXplKS5zaGlmdHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1hDb29yZHMgPSByZXN1bHQueENvb3Jkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgc2hpZnRSZXN1bHRbaW5kZXhdLmR4O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdZQ29vcmRzID0gcmVzdWx0LnlDb29yZHMubWFwKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geSArIHNoaWZ0UmVzdWx0W2luZGV4XS5keTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQueENvb3JkcyA9IG5ld1hDb29yZHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnlDb29yZHMgPSBuZXdZQ29vcmRzO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfY291bnQgPSAwO1xuICAgICAgICAgICAgICBjb21wb25lbnRzRXZhbHVhdGVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29zZVJlc3VsdFtpbmRleF0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBub2RlUmVjdGFuZ2xlID0gY29zZVJlc3VsdFtpbmRleF1baXRlbV07XG4gICAgICAgICAgICAgICAgICBub2RlUmVjdGFuZ2xlLnNldENlbnRlcihub2RlUmVjdGFuZ2xlLmdldENlbnRlclgoKSArIHNoaWZ0UmVzdWx0W19jb3VudF0uZHgsIG5vZGVSZWN0YW5nbGUuZ2V0Q2VudGVyWSgpICsgc2hpZnRSZXN1bHRbX2NvdW50XS5keSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2NvdW50Kys7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgZWFjaCBlbGVtZW50J3MgY2FsY3VsYXRlZCBwb3NpdGlvblxuICAgICAgdmFyIGdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhlbGUsIGkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRlZmF1bHRcIiB8fCBvcHRpb25zLnF1YWxpdHkgPT0gXCJwcm9vZlwiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGVsZSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRoZUlkID0gZWxlLmRhdGEoJ2lkJyk7XG4gICAgICAgICAgY29zZVJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGVJZCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgcG9zID0geyB4OiByZXN1bHRbdGhlSWRdLmdldFJlY3QoKS5nZXRDZW50ZXJYKCksIHk6IHJlc3VsdFt0aGVJZF0uZ2V0UmVjdCgpLmdldENlbnRlclkoKSB9O1xuICAgICAgICAgICAgICBub2RlID0gcmVzdWx0W3RoZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxhYmVsV2lkdGgpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggKz0gbm9kZS5sYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueCAtPSBub2RlLmxhYmVsV2lkdGggLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueSArPSBub2RlLmxhYmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJib3R0b21cIikge1xuICAgICAgICAgICAgICAgIHBvcy55IC09IG5vZGUubGFiZWxIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3MgPT0gdW5kZWZpbmVkKSBwb3MgPSB7IHg6IGVsZS5wb3NpdGlvbihcInhcIiksIHk6IGVsZS5wb3NpdGlvbihcInlcIikgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICB5OiBwb3MueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3MgPSB2b2lkIDA7XG4gICAgICAgICAgc3BlY3RyYWxSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubm9kZUluZGV4ZXMuZ2V0KGVsZS5pZCgpKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3BvcyA9IHsgeDogcmVzdWx0LnhDb29yZHNbaW5kZXhdLCB5OiByZXN1bHQueUNvb3Jkc1tpbmRleF0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoX3BvcyA9PSB1bmRlZmluZWQpIF9wb3MgPSB7IHg6IGVsZS5wb3NpdGlvbihcInhcIiksIHk6IGVsZS5wb3NpdGlvbihcInlcIikgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogX3Bvcy54LFxuICAgICAgICAgICAgeTogX3Bvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gcXVhbGl0eSA9IFwiZHJhZnRcIiBhbmQgcmFuZG9taXplID0gZmFsc2UgYXJlIGNvbnRyYWRpY3RpdmUgc28gaW4gdGhhdCBjYXNlIHBvc2l0aW9ucyBkb24ndCBjaGFuZ2VcbiAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIiB8fCBvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAvLyB0cmFuc2ZlciBjYWxjdWxhdGVkIHBvc2l0aW9ucyB0byBub2RlcyAocG9zaXRpb25zIG9mIG9ubHkgc2ltcGxlIG5vZGVzIGFyZSBldmFsdWF0ZWQsIGNvbXBvdW5kcyBhcmUgcG9zaXRpb25lZCBhdXRvbWF0aWNhbGx5KVxuICAgICAgICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGF1eC5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbihjeSwgZWxlcyk7XG4gICAgICAgIHZhciBfaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmNzcygnZGlzcGxheScpID09ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuZWxlcyA9IGVsZXMubm90KF9oaWRkZW5FbGVzKTtcblxuICAgICAgICBlbGVzLm5vZGVzKCkubm90KFwiOnBhcmVudFwiKS5ub3QoX2hpZGRlbkVsZXMpLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFBvc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24oZ2V0UG9zaXRpb25zKGVsZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIklmIHJhbmRvbWl6ZSBvcHRpb24gaXMgc2V0IHRvIGZhbHNlLCB0aGVuIHF1YWxpdHkgb3B0aW9uIG11c3QgYmUgJ2RlZmF1bHQnIG9yICdwcm9vZicuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXlvdXQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3BlY3RyYWwgbGF5b3V0IHRoYXQgaXMgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIGZjb3NlIGxheW91dCBhbGdvcml0aG1cbiovXG5cbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG52YXIgTWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuTWF0cml4O1xudmFyIFNWRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLlNWRDtcblxuLy8gbWFpbiBmdW5jdGlvbiB0aGF0IHNwZWN0cmFsIGxheW91dCBpcyBwcm9jZXNzZWRcbnZhciBzcGVjdHJhbExheW91dCA9IGZ1bmN0aW9uIHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpIHtcblxuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICB2YXIgcGFyZW50Tm9kZXMgPSBlbGVzLm5vZGVzKFwiOnBhcmVudFwiKTtcblxuICB2YXIgZHVtbXlOb2RlcyA9IG5ldyBNYXAoKTsgLy8gbWFwIHRvIGtlZXAgZHVtbXkgbm9kZXMgYW5kIHRoZWlyIG5laWdoYm9yc1xuICB2YXIgbm9kZUluZGV4ZXMgPSBuZXcgTWFwKCk7IC8vIG1hcCB0byBrZWVwIGluZGV4ZXMgdG8gbm9kZXNcbiAgdmFyIHBhcmVudENoaWxkTWFwID0gbmV3IE1hcCgpOyAvLyBtYXBwaW5nIGJ0dy4gY29tcG91bmQgYW5kIGl0cyByZXByZXNlbnRhdGl2ZSBub2RlIFxuICB2YXIgYWxsTm9kZXNOZWlnaGJvcmhvb2QgPSBbXTsgLy8gYXJyYXkgdG8ga2VlcCBuZWlnaGJvcmhvb2Qgb2YgYWxsIG5vZGVzXG4gIHZhciB4Q29vcmRzID0gW107XG4gIHZhciB5Q29vcmRzID0gW107XG5cbiAgdmFyIHNhbXBsZXNDb2x1bW4gPSBbXTsgLy8gc2FtcGxlZCB2ZXJ0aWNlc1xuICB2YXIgbWluRGlzdGFuY2VzQ29sdW1uID0gW107XG4gIHZhciBDID0gW107IC8vIGNvbHVtbiBzYW1wbGluZyBtYXRyaXhcbiAgdmFyIFBISSA9IFtdOyAvLyBpbnRlcnNlY3Rpb24gb2YgY29sdW1uIGFuZCByb3cgc2FtcGxpbmcgbWF0cmljZXMgXG4gIHZhciBJTlYgPSBbXTsgLy8gaW52ZXJzZSBvZiBQSEkgXG5cbiAgdmFyIGZpcnN0U2FtcGxlID0gdm9pZCAwOyAvLyB0aGUgZmlyc3Qgc2FtcGxlZCBub2RlXG4gIHZhciBub2RlU2l6ZSA9IHZvaWQgMDtcblxuICB2YXIgaW5maW5pdHkgPSAxMDAwMDAwMDA7XG4gIHZhciBzbWFsbCA9IDAuMDAwMDAwMDAxO1xuXG4gIHZhciBwaVRvbCA9IG9wdGlvbnMucGlUb2w7XG4gIHZhciBzYW1wbGluZ1R5cGUgPSBvcHRpb25zLnNhbXBsaW5nVHlwZTsgLy8gZmFsc2UgZm9yIHJhbmRvbSwgdHJ1ZSBmb3IgZ3JlZWR5XG4gIHZhciBub2RlU2VwYXJhdGlvbiA9IG9wdGlvbnMubm9kZVNlcGFyYXRpb247XG4gIHZhciBzYW1wbGVTaXplID0gdm9pZCAwO1xuXG4gIC8qKioqIFNwZWN0cmFsLXByZXByb2Nlc3NpbmcgZnVuY3Rpb25zICoqKiovXG5cbiAgLyoqKiogU3BlY3RyYWwgbGF5b3V0IGZ1bmN0aW9ucyAqKioqL1xuXG4gIC8vIGRldGVybWluZSB3aGljaCBjb2x1bW5zIHRvIGJlIHNhbXBsZWRcbiAgdmFyIHJhbmRvbVNhbXBsZUNSID0gZnVuY3Rpb24gcmFuZG9tU2FtcGxlQ1IoKSB7XG4gICAgdmFyIHNhbXBsZSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgc2FtcGxlU2l6ZSkge1xuICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZVNpemUpO1xuXG4gICAgICBmbGFnID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgaWYgKHNhbXBsZXNDb2x1bW5baV0gPT0gc2FtcGxlKSB7XG4gICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgIHNhbXBsZXNDb2x1bW5bY291bnRdID0gc2FtcGxlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHRha2VzIHRoZSBpbmRleCBvZiB0aGUgbm9kZShwaXZvdCkgdG8gaW5pdGlhdGUgQkZTIGFzIGEgcGFyYW1ldGVyXG4gIHZhciBCRlMgPSBmdW5jdGlvbiBCRlMocGl2b3QsIGluZGV4LCBzYW1wbGluZ01ldGhvZCkge1xuICAgIHZhciBwYXRoID0gW107IC8vIHRoZSBmcm9udCBvZiB0aGUgcGF0aFxuICAgIHZhciBmcm9udCA9IDA7IC8vIHRoZSBiYWNrIG9mIHRoZSBwYXRoXG4gICAgdmFyIGJhY2sgPSAwO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgdGVtcCA9IHZvaWQgMDtcbiAgICB2YXIgZGlzdGFuY2UgPSBbXTtcblxuICAgIHZhciBtYXhfZGlzdCA9IDA7IC8vIHRoZSBmdXJ0aGVzdCBub2RlIHRvIGJlIHJldHVybmVkXG4gICAgdmFyIG1heF9pbmQgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2l6ZTsgaSsrKSB7XG4gICAgICBkaXN0YW5jZVtpXSA9IGluZmluaXR5O1xuICAgIH1cblxuICAgIHBhdGhbYmFja10gPSBwaXZvdDtcbiAgICBkaXN0YW5jZVtwaXZvdF0gPSAwO1xuXG4gICAgd2hpbGUgKGJhY2sgPj0gZnJvbnQpIHtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2Zyb250KytdO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGFsbE5vZGVzTmVpZ2hib3Job29kW2N1cnJlbnRdO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5laWdoYm9ycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGVtcCA9IG5vZGVJbmRleGVzLmdldChuZWlnaGJvcnNbX2ldKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlW3RlbXBdID09IGluZmluaXR5KSB7XG4gICAgICAgICAgZGlzdGFuY2VbdGVtcF0gPSBkaXN0YW5jZVtjdXJyZW50XSArIDE7XG4gICAgICAgICAgcGF0aFsrK2JhY2tdID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ1tjdXJyZW50XVtpbmRleF0gPSBkaXN0YW5jZVtjdXJyZW50XSAqIG5vZGVTZXBhcmF0aW9uO1xuICAgIH1cblxuICAgIGlmIChzYW1wbGluZ01ldGhvZCkge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZVNpemU7IF9pMisrKSB7XG4gICAgICAgIGlmIChDW19pMl1baW5kZXhdIDwgbWluRGlzdGFuY2VzQ29sdW1uW19pMl0pIG1pbkRpc3RhbmNlc0NvbHVtbltfaTJdID0gQ1tfaTJdW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZVNpemU7IF9pMysrKSB7XG4gICAgICAgIGlmIChtaW5EaXN0YW5jZXNDb2x1bW5bX2kzXSA+IG1heF9kaXN0KSB7XG4gICAgICAgICAgbWF4X2Rpc3QgPSBtaW5EaXN0YW5jZXNDb2x1bW5bX2kzXTtcbiAgICAgICAgICBtYXhfaW5kID0gX2kzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhfaW5kO1xuICB9O1xuXG4gIC8vIGFwcGx5IEJGUyB0byBhbGwgbm9kZXMgb3Igc2VsZWN0ZWQgc2FtcGxlc1xuICB2YXIgYWxsQkZTID0gZnVuY3Rpb24gYWxsQkZTKHNhbXBsaW5nTWV0aG9kKSB7XG5cbiAgICB2YXIgc2FtcGxlID0gdm9pZCAwO1xuXG4gICAgaWYgKCFzYW1wbGluZ01ldGhvZCkge1xuICAgICAgcmFuZG9tU2FtcGxlQ1IoKTtcblxuICAgICAgLy8gY2FsbCBCRlNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG4gICAgICAgIEJGUyhzYW1wbGVzQ29sdW1uW2ldLCBpLCBzYW1wbGluZ01ldGhvZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzYW1wbGUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2RlU2l6ZSk7XG4gICAgICBmaXJzdFNhbXBsZSA9IHNhbXBsZTtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZVNpemU7IF9pNCsrKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlc0NvbHVtbltfaTRdID0gaW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHNhbXBsZVNpemU7IF9pNSsrKSB7XG4gICAgICAgIHNhbXBsZXNDb2x1bW5bX2k1XSA9IHNhbXBsZTtcbiAgICAgICAgc2FtcGxlID0gQkZTKHNhbXBsZSwgX2k1LCBzYW1wbGluZ01ldGhvZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9ybSB0aGUgc3F1YXJlZCBkaXN0YW5jZXMgZm9yIENcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBub2RlU2l6ZTsgX2k2KyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2FtcGxlU2l6ZTsgaisrKSB7XG4gICAgICAgIENbX2k2XVtqXSAqPSBDW19pNl1bal07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9ybSBQSElcbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBzYW1wbGVTaXplOyBfaTcrKykge1xuICAgICAgUEhJW19pN10gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBzYW1wbGVTaXplOyBfaTgrKykge1xuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHNhbXBsZVNpemU7IF9qKyspIHtcbiAgICAgICAgUEhJW19pOF1bX2pdID0gQ1tzYW1wbGVzQ29sdW1uW19qXV1bX2k4XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcGVyZm9ybSB0aGUgU1ZEIGFsZ29yaXRobSBhbmQgYXBwbHkgYSByZWd1bGFyaXphdGlvbiBzdGVwXG4gIHZhciBzYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUoKSB7XG5cbiAgICB2YXIgU1ZEUmVzdWx0ID0gU1ZELnN2ZChQSEkpO1xuXG4gICAgdmFyIGFfcSA9IFNWRFJlc3VsdC5TO1xuICAgIHZhciBhX3UgPSBTVkRSZXN1bHQuVTtcbiAgICB2YXIgYV92ID0gU1ZEUmVzdWx0LlY7XG5cbiAgICB2YXIgbWF4X3MgPSBhX3FbMF0gKiBhX3FbMF0gKiBhX3FbMF07XG5cbiAgICB2YXIgYV9TaWcgPSBbXTtcblxuICAgIC8vICByZWd1bGFyaXphdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG4gICAgICBhX1NpZ1tpXSA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzYW1wbGVTaXplOyBqKyspIHtcbiAgICAgICAgYV9TaWdbaV1bal0gPSAwO1xuICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgYV9TaWdbaV1bal0gPSBhX3FbaV0gLyAoYV9xW2ldICogYV9xW2ldICsgbWF4X3MgLyAoYV9xW2ldICogYV9xW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBJTlYgPSBNYXRyaXgubXVsdE1hdChNYXRyaXgubXVsdE1hdChhX3YsIGFfU2lnKSwgTWF0cml4LnRyYW5zcG9zZShhX3UpKTtcbiAgfTtcblxuICAvLyBjYWxjdWxhdGUgZmluYWwgY29vcmRpbmF0ZXMgXG4gIHZhciBwb3dlckl0ZXJhdGlvbiA9IGZ1bmN0aW9uIHBvd2VySXRlcmF0aW9uKCkge1xuICAgIC8vIHR3byBsYXJnZXN0IGVpZ2VudmFsdWVzXG4gICAgdmFyIHRoZXRhMSA9IHZvaWQgMDtcbiAgICB2YXIgdGhldGEyID0gdm9pZCAwO1xuXG4gICAgLy8gaW5pdGlhbCBndWVzc2VzIGZvciBlaWdlbnZlY3RvcnNcbiAgICB2YXIgWTEgPSBbXTtcbiAgICB2YXIgWTIgPSBbXTtcblxuICAgIHZhciBWMSA9IFtdO1xuICAgIHZhciBWMiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2l6ZTsgaSsrKSB7XG4gICAgICBZMVtpXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICBZMltpXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgfVxuXG4gICAgWTEgPSBNYXRyaXgubm9ybWFsaXplKFkxKTtcbiAgICBZMiA9IE1hdHJpeC5ub3JtYWxpemUoWTIpO1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvLyB0byBrZWVwIHRyYWNrIG9mIHRoZSBpbXByb3ZlbWVudCByYXRpbyBpbiBwb3dlciBpdGVyYXRpb25cbiAgICB2YXIgY3VycmVudCA9IHNtYWxsO1xuICAgIHZhciBwcmV2aW91cyA9IHNtYWxsO1xuXG4gICAgdmFyIHRlbXAgPSB2b2lkIDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY291bnQrKztcblxuICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgbm9kZVNpemU7IF9pOSsrKSB7XG4gICAgICAgIFYxW19pOV0gPSBZMVtfaTldO1xuICAgICAgfVxuXG4gICAgICBZMSA9IE1hdHJpeC5tdWx0R2FtbWEoTWF0cml4Lm11bHRMKE1hdHJpeC5tdWx0R2FtbWEoVjEpLCBDLCBJTlYpKTtcbiAgICAgIHRoZXRhMSA9IE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBZMSk7XG4gICAgICBZMSA9IE1hdHJpeC5ub3JtYWxpemUoWTEpO1xuXG4gICAgICBjdXJyZW50ID0gTWF0cml4LmRvdFByb2R1Y3QoVjEsIFkxKTtcblxuICAgICAgdGVtcCA9IE1hdGguYWJzKGN1cnJlbnQgLyBwcmV2aW91cyk7XG5cbiAgICAgIGlmICh0ZW1wIDw9IDEgKyBwaVRvbCAmJiB0ZW1wID49IDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG5vZGVTaXplOyBfaTEwKyspIHtcbiAgICAgIFYxW19pMTBdID0gWTFbX2kxMF07XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZpb3VzID0gc21hbGw7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvdW50Kys7XG5cbiAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgbm9kZVNpemU7IF9pMTErKykge1xuICAgICAgICBWMltfaTExXSA9IFkyW19pMTFdO1xuICAgICAgfVxuXG4gICAgICBWMiA9IE1hdHJpeC5taW51c09wKFYyLCBNYXRyaXgubXVsdENvbnMoVjEsIE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBWMikpKTtcbiAgICAgIFkyID0gTWF0cml4Lm11bHRHYW1tYShNYXRyaXgubXVsdEwoTWF0cml4Lm11bHRHYW1tYShWMiksIEMsIElOVikpO1xuICAgICAgdGhldGEyID0gTWF0cml4LmRvdFByb2R1Y3QoVjIsIFkyKTtcbiAgICAgIFkyID0gTWF0cml4Lm5vcm1hbGl6ZShZMik7XG5cbiAgICAgIGN1cnJlbnQgPSBNYXRyaXguZG90UHJvZHVjdChWMiwgWTIpO1xuXG4gICAgICB0ZW1wID0gTWF0aC5hYnMoY3VycmVudCAvIHByZXZpb3VzKTtcblxuICAgICAgaWYgKHRlbXAgPD0gMSArIHBpVG9sICYmIHRlbXAgPj0gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbm9kZVNpemU7IF9pMTIrKykge1xuICAgICAgVjJbX2kxMl0gPSBZMltfaTEyXTtcbiAgICB9XG5cbiAgICAvLyB0aGV0YTEgbm93IGNvbnRhaW5zIGRvbWluYW50IGVpZ2VudmFsdWVcbiAgICAvLyB0aGV0YTIgbm93IGNvbnRhaW5zIHRoZSBzZWNvbmQtbGFyZ2VzdCBlaWdlbnZhbHVlXG4gICAgLy8gVjEgbm93IGNvbnRhaW5zIHRoZXRhMSdzIGVpZ2VudmVjdG9yXG4gICAgLy8gVjIgbm93IGNvbnRhaW5zIHRoZXRhMidzIGVpZ2VudmVjdG9yXG5cbiAgICAvL3BvcHVsYXRlIHRoZSB0d28gdmVjdG9yc1xuICAgIHhDb29yZHMgPSBNYXRyaXgubXVsdENvbnMoVjEsIE1hdGguc3FydChNYXRoLmFicyh0aGV0YTEpKSk7XG4gICAgeUNvb3JkcyA9IE1hdHJpeC5tdWx0Q29ucyhWMiwgTWF0aC5zcXJ0KE1hdGguYWJzKHRoZXRhMikpKTtcbiAgfTtcblxuICAvKioqKiBQcmVwYXJhdGlvbiBmb3Igc3BlY3RyYWwgbGF5b3V0IChQcmVwcm9jZXNzaW5nKSAqKioqL1xuXG4gIC8vIGNvbm5lY3QgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgKGZpcnN0IHRvcCBsZXZlbCwgdGhlbiBpbnNpZGUgb2YgZWFjaCBjb21wb3VuZCBub2RlKVxuICBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIGVsZXMsIGF1eC5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBkdW1teU5vZGVzKTtcblxuICBwYXJlbnROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIGVsZXMsIGF1eC5nZXRUb3BNb3N0Tm9kZXMoZWxlLmRlc2NlbmRhbnRzKCkuaW50ZXJzZWN0aW9uKGVsZXMpKSwgZHVtbXlOb2Rlcyk7XG4gIH0pO1xuXG4gIC8vIGFzc2lnbiBpbmRleGVzIHRvIG5vZGVzIChmaXJzdCByZWFsLCB0aGVuIGR1bW15IG5vZGVzKVxuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFub2Rlc1tpXS5pc1BhcmVudCgpKSB7XG4gICAgICBub2RlSW5kZXhlcy5zZXQobm9kZXNbaV0uaWQoKSwgaW5kZXgrKyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZHVtbXlOb2Rlcy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIG5vZGVJbmRleGVzLnNldChrZXksIGluZGV4KyspO1xuICAgIH1cblxuICAgIC8vIGluc3RhbnRpYXRlIHRoZSBuZWlnaGJvcmhvb2QgbWF0cml4XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kxMyA9IDA7IF9pMTMgPCBub2RlSW5kZXhlcy5zaXplOyBfaTEzKyspIHtcbiAgICBhbGxOb2Rlc05laWdoYm9yaG9vZFtfaTEzXSA9IFtdO1xuICB9XG5cbiAgLy8gZm9ybSBhIHBhcmVudC1jaGlsZCBtYXAgdG8ga2VlcCByZXByZXNlbnRhdGl2ZSBub2RlIG9mIGVhY2ggY29tcG91bmQgbm9kZSAgXG4gIHBhcmVudE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZS5jaGlsZHJlbigpLmludGVyc2VjdGlvbihlbGVzKTtcblxuICAgIC8vICAgICAgbGV0IHJhbmRvbSA9IDA7XG4gICAgd2hpbGUgKGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKS5sZW5ndGggPT0gMCkge1xuICAgICAgLy8gICAgICAgIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoaWxkcmVuLm5vZGVzKCkubGVuZ3RoKTsgLy8gaWYgYWxsIGNoaWxkcmVuIGFyZSBjb21wb3VuZCB0aGVuIHByb2NlZWQgcmFuZG9tbHlcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ubm9kZXMoKVswXS5jaGlsZHJlbigpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICB9XG4gICAgLy8gIHNlbGVjdCB0aGUgcmVwcmVzZW50YXRpdmUgbm9kZSAtIHdlIGNhbiBhcHBseSBkaWZmZXJlbnQgbWV0aG9kcyBoZXJlXG4gICAgLy8gICAgICByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIikubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBtaW4gPSBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIilbMF0uY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpLmZvckVhY2goZnVuY3Rpb24gKGVsZTIsIGkpIHtcbiAgICAgIGlmIChlbGUyLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGVsZTIuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwYXJlbnRDaGlsZE1hcC5zZXQoZWxlLmlkKCksIGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKVtpbmRleF0uaWQoKSk7XG4gIH0pO1xuXG4gIC8vIGFkZCBuZWlnaGJvcmhvb2QgcmVsYXRpb25zIChmaXJzdCByZWFsLCB0aGVuIGR1bW15IG5vZGVzKVxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgZWxlSW5kZXggPSB2b2lkIDA7XG5cbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIGVsZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KHBhcmVudENoaWxkTWFwLmdldChlbGUuaWQoKSkpO2Vsc2UgZWxlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQoZWxlLmlkKCkpO1xuXG4gICAgZWxlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKGVsZXMuaW50ZXJzZWN0aW9uKGVsZS5lZGdlc1dpdGgobm9kZSkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG5vZGUuaXNQYXJlbnQoKSkgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2gocGFyZW50Q2hpbGRNYXAuZ2V0KG5vZGUuaWQoKSkpO2Vsc2UgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2gobm9kZS5pZCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2tleSkge1xuICAgIHZhciBlbGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChfa2V5KTtcbiAgICB2YXIgZGlzY29ubmVjdGVkSWQgPSB2b2lkIDA7XG4gICAgZHVtbXlOb2Rlcy5nZXQoX2tleSkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChjeS5nZXRFbGVtZW50QnlJZChpZCkuaXNQYXJlbnQoKSkgZGlzY29ubmVjdGVkSWQgPSBwYXJlbnRDaGlsZE1hcC5nZXQoaWQpO2Vsc2UgZGlzY29ubmVjdGVkSWQgPSBpZDtcblxuICAgICAgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2goZGlzY29ubmVjdGVkSWQpO1xuICAgICAgYWxsTm9kZXNOZWlnaGJvcmhvb2Rbbm9kZUluZGV4ZXMuZ2V0KGRpc2Nvbm5lY3RlZElkKV0ucHVzaChfa2V5KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZHVtbXlOb2Rlcy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgIHZhciBfa2V5ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBfbG9vcChfa2V5KTtcbiAgICB9XG5cbiAgICAvLyBub2RlU2l6ZSBub3cgb25seSBjb25zaWRlcnMgdGhlIHNpemUgb2YgdHJhbnNmb3JtZWQgZ3JhcGhcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbm9kZVNpemUgPSBub2RlSW5kZXhlcy5zaXplO1xuXG4gIHZhciBzcGVjdHJhbFJlc3VsdCA9IHZvaWQgMDtcblxuICAvLyBJZiBudW1iZXIgb2Ygbm9kZXMgaW4gdHJhbnNmb3JtZWQgZ3JhcGggaXMgMSBvciAyLCBlaXRoZXIgU1ZEIG9yIHBvd2VySXRlcmF0aW9uIGNhdXNlcyBwcm9ibGVtXG4gIC8vIFNvIHNraXAgc3BlY3RyYWwgYW5kIGxheW91dCB0aGUgZ3JhcGggd2l0aCBjb3NlXG4gIGlmIChub2RlU2l6ZSA+IDIpIHtcbiAgICAvLyBpZiAjIG9mIG5vZGVzIGluIHRyYW5zZm9ybWVkIGdyYXBoIGlzIHNtYWxsZXIgdGhhbiBzYW1wbGUgc2l6ZSxcbiAgICAvLyB0aGVuIHVzZSAjIG9mIG5vZGVzIGFzIHNhbXBsZSBzaXplXG4gICAgc2FtcGxlU2l6ZSA9IG5vZGVTaXplIDwgb3B0aW9ucy5zYW1wbGVTaXplID8gbm9kZVNpemUgOiBvcHRpb25zLnNhbXBsZVNpemU7XG5cbiAgICAvLyBpbnN0YW50aWF0ZXMgdGhlIHBhcnRpYWwgbWF0cmljZXMgdGhhdCB3aWxsIGJlIHVzZWQgaW4gc3BlY3RyYWwgbGF5b3V0XG4gICAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCBub2RlU2l6ZTsgX2kxNCsrKSB7XG4gICAgICBDW19pMTRdID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIF9pMTUgPSAwOyBfaTE1IDwgc2FtcGxlU2l6ZTsgX2kxNSsrKSB7XG4gICAgICBJTlZbX2kxNV0gPSBbXTtcbiAgICB9XG5cbiAgICAvKioqKiBBcHBseSBzcGVjdHJhbCBsYXlvdXQgKioqKi9cblxuICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiIHx8IG9wdGlvbnMuc3RlcCA9PSBcImFsbFwiKSB7XG4gICAgICBhbGxCRlMoc2FtcGxpbmdUeXBlKTtcbiAgICAgIHNhbXBsZSgpO1xuICAgICAgcG93ZXJJdGVyYXRpb24oKTtcblxuICAgICAgc3BlY3RyYWxSZXN1bHQgPSB7IG5vZGVJbmRleGVzOiBub2RlSW5kZXhlcywgeENvb3JkczogeENvb3JkcywgeUNvb3JkczogeUNvb3JkcyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHhDb29yZHMucHVzaChjeS5nZXRFbGVtZW50QnlJZChrZXkpLnBvc2l0aW9uKFwieFwiKSk7XG4gICAgICAgIHlDb29yZHMucHVzaChjeS5nZXRFbGVtZW50QnlJZChrZXkpLnBvc2l0aW9uKFwieVwiKSk7XG4gICAgICB9KTtcbiAgICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWN0cmFsUmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvciA9IG5vZGVJbmRleGVzLmtleXMoKTtcbiAgICB2YXIgZmlyc3ROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB2YXIgZmlyc3ROb2RlUG9zID0gZmlyc3ROb2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIGZpcnN0Tm9kZVdpZHRoID0gZmlyc3ROb2RlLm91dGVyV2lkdGgoKTtcbiAgICB4Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLngpO1xuICAgIHlDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueSk7XG4gICAgaWYgKG5vZGVTaXplID09IDIpIHtcbiAgICAgIHZhciBzZWNvbmROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICAgIHZhciBzZWNvbmROb2RlV2lkdGggPSBzZWNvbmROb2RlLm91dGVyV2lkdGgoKTtcbiAgICAgIHhDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueCArIGZpcnN0Tm9kZVdpZHRoIC8gMiArIHNlY29uZE5vZGVXaWR0aCAvIDIgKyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCk7XG4gICAgICB5Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLnkpO1xuICAgIH1cblxuICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICByZXR1cm4gc3BlY3RyYWxSZXN1bHQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBzcGVjdHJhbExheW91dDogc3BlY3RyYWxMYXlvdXQgfTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU3OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBpbXBsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTIpO1xuXG4vLyByZWdpc3RlcnMgdGhlIGV4dGVuc2lvbiBvbiBhIGN5dG9zY2FwZSBsaWIgcmVmXG52YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjeXRvc2NhcGUpIHtcbiAgaWYgKCFjeXRvc2NhcGUpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gY2FuJ3QgcmVnaXN0ZXIgaWYgY3l0b3NjYXBlIHVuc3BlY2lmaWVkXG5cbiAgY3l0b3NjYXBlKCdsYXlvdXQnLCAnZmNvc2UnLCBpbXBsKTsgLy8gcmVnaXN0ZXIgd2l0aCBjeXRvc2NhcGUuanNcbn07XG5cbmlmICh0eXBlb2YgY3l0b3NjYXBlICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBleHBvc2UgdG8gZ2xvYmFsIGN5dG9zY2FwZSAoaS5lLiB3aW5kb3cuY3l0b3NjYXBlKVxuICByZWdpc3RlcihjeXRvc2NhcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQwOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzkpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMTQwX18iLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRndCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzcmNzIiwiQXJyYXkiLCJfa2V5IiwiZm9yRWFjaCIsInNyYyIsImtleXMiLCJrIiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIl9zbGljZWRUb0FycmF5Iiwic2xpY2VJdGVyYXRvciIsImFyciIsImkiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwidW5kZWZpbmVkIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwibmV4dCIsImRvbmUiLCJwdXNoIiwidmFsdWUiLCJlcnIiLCJpc0FycmF5IiwiVHlwZUVycm9yIiwiTGlua2VkTGlzdCIsImxheW91dEJhc2UiLCJhdXhpbGlhcnkiLCJnZXRUb3BNb3N0Tm9kZXMiLCJub2RlcyIsIm5vZGVzTWFwIiwiaWQiLCJyb290cyIsImZpbHRlciIsImVsZSIsInBhcmVudCIsImNvbm5lY3RDb21wb25lbnRzIiwiY3kiLCJlbGVzIiwidG9wTW9zdE5vZGVzIiwiZHVtbXlOb2RlcyIsInF1ZXVlIiwidmlzaXRlZCIsIlNldCIsInZpc2l0ZWRUb3BNb3N0Tm9kZXMiLCJjdXJyZW50TmVpZ2hib3IiLCJtaW5EZWdyZWVOb2RlIiwibWluRGVncmVlIiwiaXNDb25uZWN0ZWQiLCJjb3VudCIsIm5vZGVzQ29ubmVjdGVkVG9EdW1teSIsImNvbXBvbmVudHMiLCJfbG9vcCIsImNtcHQiLCJjb2xsZWN0aW9uIiwiY3VycmVudE5vZGUiLCJjaGlsZHJlbk9mQ3VycmVudE5vZGUiLCJtZXJnZSIsImRlc2NlbmRhbnRzIiwiaW50ZXJzZWN0aW9uIiwibm9kZSIsImFkZCIsIl9sb29wMiIsInNoaWZ0IiwibmVpZ2hib3JOb2RlcyIsIm5laWdoYm9yaG9vZCIsImVkZ2VzV2l0aCIsIm5laWdoYm9yTm9kZSIsInVuaW9uIiwiYW5jZXN0b3JzIiwiaGFzIiwiY2hpbGRyZW5PZk5laWdoYm9yIiwiY29ubmVjdGVkRWRnZXMiLCJlIiwic291cmNlIiwidGFyZ2V0IiwidGVtcCIsImRpZmZlcmVuY2UiLCJzZXQiLCJzaXplIiwicmVsb2NhdGVDb21wb25lbnQiLCJvcmlnaW5hbENlbnRlciIsImNvbXBvbmVudFJlc3VsdCIsIm9wdGlvbnMiLCJmaXhlZE5vZGVDb25zdHJhaW50IiwibWluWENvb3JkIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJtYXhYQ29vcmQiLCJORUdBVElWRV9JTkZJTklUWSIsIm1pbllDb29yZCIsIm1heFlDb29yZCIsInF1YWxpdHkiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIm5vZGVJbmRleGVzIiwiX3N0ZXAiLCJfcmVmIiwiX3JlZjIiLCJrZXkiLCJjeU5vZGUiLCJnZXRFbGVtZW50QnlJZCIsIm5vZGVCQiIsImJvdW5kaW5nQm94IiwibGVmdFgiLCJ4Q29vcmRzIiwidyIsInJpZ2h0WCIsInRvcFkiLCJ5Q29vcmRzIiwiaCIsImJvdHRvbVkiLCJyZXR1cm4iLCJkaWZmT25YIiwieCIsImRpZmZPblkiLCJ5IiwibWFwIiwiaXRlbSIsImdldFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsIl9kaWZmT25YIiwiX2RpZmZPblkiLCJzZXRDZW50ZXIiLCJnZXRDZW50ZXJYIiwiZ2V0Q2VudGVyWSIsImNhbGNCb3VuZGluZ0JveCIsInBhcmVudE5vZGUiLCJsZWZ0IiwiTUFYX1NBRkVfSU5URUdFUiIsInJpZ2h0IiwiTUlOX1NBRkVfSU5URUdFUiIsInRvcCIsImJvdHRvbSIsIm5vZGVMZWZ0Iiwibm9kZVJpZ2h0Iiwibm9kZVRvcCIsIm5vZGVCb3R0b20iLCJub3QiLCJzIiwiZ2V0IiwidG9wTGVmdFgiLCJ0b3BMZWZ0WSIsImNhbGNQYXJlbnRzV2l0aG91dENoaWxkcmVuIiwicGFyZW50c1dpdGhvdXRDaGlsZHJlbiIsImNoZWNrIiwiY2hpbGRyZW4iLCJjaGlsZCIsImNzcyIsImF1eCIsIkNvU0VMYXlvdXQiLCJDb1NFTm9kZSIsIlBvaW50RCIsIkRpbWVuc2lvbkQiLCJMYXlvdXRDb25zdGFudHMiLCJGRExheW91dENvbnN0YW50cyIsIkNvU0VDb25zdGFudHMiLCJjb3NlTGF5b3V0Iiwic3BlY3RyYWxSZXN1bHQiLCJlZGdlcyIsImlkVG9MTm9kZSIsInJhbmRvbWl6ZSIsImlzRm4iLCJmbiIsIm9wdEZuIiwib3B0IiwicHJvY2Vzc0NoaWxkcmVuTGlzdCIsImxheW91dCIsInRoZUNoaWxkIiwiY2hpbGRyZW5fb2ZfY2hpbGRyZW4iLCJ0aGVOb2RlIiwiZGltZW5zaW9ucyIsImxheW91dERpbWVuc2lvbnMiLCJub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMiLCJvdXRlcldpZHRoIiwib3V0ZXJIZWlnaHQiLCJpc1BhcmVudCIsImdyYXBoTWFuYWdlciIsInBhcnNlRmxvYXQiLCJwYXJlbnRJbmZvIiwicG9zaXRpb24iLCJkYXRhIiwibm9kZVJlcHVsc2lvbiIsInBhZGRpbmdMZWZ0IiwicGFyc2VJbnQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsImxhYmVsV2lkdGgiLCJpbmNsdWRlTGFiZWxzIiwiaW5jbHVkZU5vZGVzIiwiaW5jbHVkZU92ZXJsYXlzIiwibGFiZWxIZWlnaHQiLCJsYWJlbFBvc1ZlcnRpY2FsIiwibGFiZWxQb3NIb3Jpem9udGFsIiwiaXNOYU4iLCJyZWN0IiwidGhlTmV3R3JhcGgiLCJnZXRHcmFwaE1hbmFnZXIiLCJuZXdHcmFwaCIsInByb2Nlc3NFZGdlcyIsImdtIiwiaWRlYWxMZW5ndGhUb3RhbCIsImVkZ2VDb3VudCIsImVkZ2UiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsImdldEVkZ2VzQmV0d2VlbiIsImUxIiwibmV3RWRnZSIsImlkZWFsTGVuZ3RoIiwiaWRlYWxFZGdlTGVuZ3RoIiwiZWRnZUVsYXN0aWNpdHkiLCJERUZBVUxUX0VER0VfTEVOR1RIIiwiTUlOX1JFUFVMU0lPTl9ESVNUIiwiREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTiIsInByb2Nlc3NDb25zdHJhaW50cyIsImNvbnN0cmFpbnRzIiwiYWxpZ25tZW50Q29uc3RyYWludCIsInJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCIsIm5lc3RpbmdGYWN0b3IiLCJQRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SIiwiZ3Jhdml0eSIsIkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCIsIm51bUl0ZXIiLCJNQVhfSVRFUkFUSU9OUyIsImdyYXZpdHlSYW5nZSIsIkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IiLCJncmF2aXR5Q29tcG91bmQiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEgiLCJncmF2aXR5UmFuZ2VDb21wb3VuZCIsIkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IiLCJpbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbCIsIkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwiLCJ0aWxpbmdDb21wYXJlQnkiLCJUSUxJTkdfQ09NUEFSRV9CWSIsIlFVQUxJVFkiLCJOT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMiLCJERUZBVUxUX0lOQ1JFTUVOVEFMIiwiQU5JTUFURSIsImFuaW1hdGUiLCJUSUxFIiwidGlsZSIsIlRJTElOR19QQURESU5HX1ZFUlRJQ0FMIiwidGlsaW5nUGFkZGluZ1ZlcnRpY2FsIiwiY2FsbCIsIlRJTElOR19QQURESU5HX0hPUklaT05UQUwiLCJ0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCIsIlBVUkVfSU5DUkVNRU5UQUwiLCJERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTIiwidW5pZm9ybU5vZGVEaW1lbnNpb25zIiwic3RlcCIsIlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HIiwiRU5GT1JDRV9DT05TVFJBSU5UUyIsIkFQUExZX0xBWU9VVCIsIlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMIiwibmV3R3JhcGhNYW5hZ2VyIiwiYWRkUm9vdCIsInJ1bkxheW91dCIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJfcmVxdWlyZSIsInNwZWN0cmFsTGF5b3V0IiwiX3JlcXVpcmUyIiwiZGVmYXVsdHMiLCJmcmVlemUiLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsImZpdCIsInBhZGRpbmciLCJwYWNrQ29tcG9uZW50cyIsInNhbXBsaW5nVHlwZSIsInNhbXBsZVNpemUiLCJub2RlU2VwYXJhdGlvbiIsInBpVG9sIiwicmVhZHkiLCJzdG9wIiwiTGF5b3V0IiwicnVuIiwiY29zZVJlc3VsdCIsImNvbXBvbmVudENlbnRlcnMiLCJ2ZXJ0aWNhbCIsImhvcml6b250YWwiLCJjb25zdHJhaW50RXhpc3QiLCJsYXlVdGlsIiwicGFja2luZ0VuYWJsZWQiLCJsYXlvdXRVdGlsaXRpZXMiLCJ4MSIsInkxIiwicmVzdWx0IiwiY29tcG9uZW50IiwidG9CZVRpbGVkTm9kZXMiLCJNYXAiLCJfeENvb3JkcyIsIl95Q29vcmRzIiwidGVtcFNwZWN0cmFsUmVzdWx0IiwiaW5kZXhlc1RvQmVEZWxldGVkIiwiaW5kZXgiLCJfYm91bmRpbmdCb3giLCJzcGxpY2UiLCJjb21wb25lbnRzRXZhbHVhdGVkIiwic3ViZ3JhcGhzIiwiaGlkZGVuRWxlcyIsInN1YmdyYXBoIiwibm9kZUluZGV4IiwiYm91bmRpbmdib3giLCJnZXRMZWZ0IiwiZ2V0VG9wIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJzb3VyY2VOb2RlSW5kZXgiLCJ0YXJnZXROb2RlSW5kZXgiLCJzb3VyY2VDZW50ZXIiLCJ0YXJnZXRDZW50ZXIiLCJfcGFyZW50SW5mbyIsInN0YXJ0WCIsInN0YXJ0WSIsImVuZFgiLCJlbmRZIiwic2hpZnRSZXN1bHQiLCJzaGlmdHMiLCJuZXdYQ29vcmRzIiwiZHgiLCJuZXdZQ29vcmRzIiwiZHkiLCJfY291bnQiLCJub2RlUmVjdGFuZ2xlIiwiZ2V0UG9zaXRpb25zIiwicG9zIiwidGhlSWQiLCJfcG9zIiwiX2hpZGRlbkVsZXMiLCJsYXlvdXRQb3NpdGlvbnMiLCJjb25zb2xlIiwibG9nIiwiTWF0cml4IiwiU1ZEIiwicGFyZW50Tm9kZXMiLCJwYXJlbnRDaGlsZE1hcCIsImFsbE5vZGVzTmVpZ2hib3Job29kIiwic2FtcGxlc0NvbHVtbiIsIm1pbkRpc3RhbmNlc0NvbHVtbiIsIkMiLCJQSEkiLCJJTlYiLCJmaXJzdFNhbXBsZSIsIm5vZGVTaXplIiwiaW5maW5pdHkiLCJzbWFsbCIsInJhbmRvbVNhbXBsZUNSIiwic2FtcGxlIiwiZmxhZyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIkJGUyIsInBpdm90Iiwic2FtcGxpbmdNZXRob2QiLCJwYXRoIiwiZnJvbnQiLCJiYWNrIiwiY3VycmVudCIsImRpc3RhbmNlIiwibWF4X2Rpc3QiLCJtYXhfaW5kIiwibmVpZ2hib3JzIiwiX2kyIiwiX2kzIiwiYWxsQkZTIiwiX2k0IiwiX2k1IiwiX2k2IiwiaiIsIl9pNyIsIl9pOCIsIl9qIiwiU1ZEUmVzdWx0Iiwic3ZkIiwiYV9xIiwiUyIsImFfdSIsIlUiLCJhX3YiLCJWIiwibWF4X3MiLCJhX1NpZyIsIm11bHRNYXQiLCJ0cmFuc3Bvc2UiLCJwb3dlckl0ZXJhdGlvbiIsInRoZXRhMSIsInRoZXRhMiIsIlkxIiwiWTIiLCJWMSIsIlYyIiwibm9ybWFsaXplIiwicHJldmlvdXMiLCJfaTkiLCJtdWx0R2FtbWEiLCJtdWx0TCIsImRvdFByb2R1Y3QiLCJhYnMiLCJfaTEwIiwiX2kxMSIsIm1pbnVzT3AiLCJtdWx0Q29ucyIsIl9pMTIiLCJzcXJ0IiwiX2kxMyIsIm1pbiIsImVsZTIiLCJlbGVJbmRleCIsImRpc2Nvbm5lY3RlZElkIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIiLCJfZGlkSXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiX2kxNCIsIl9pMTUiLCJmaXJzdE5vZGUiLCJmaXJzdE5vZGVQb3MiLCJmaXJzdE5vZGVXaWR0aCIsInNlY29uZE5vZGUiLCJzZWNvbmROb2RlV2lkdGgiLCJpbXBsIiwicmVnaXN0ZXIiLCJjeXRvc2NhcGUiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-fcose/cytoscape-fcose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! layout-base */ \"(ssr)/./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js\"));\n    else {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__551__) {\n    return /******/ (()=>{\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = {\n            /***/ 45: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_657__)=>{\n                var coseBase = {};\n                coseBase.layoutBase = __nested_webpack_require_657__(551);\n                coseBase.CoSEConstants = __nested_webpack_require_657__(806);\n                coseBase.CoSEEdge = __nested_webpack_require_657__(767);\n                coseBase.CoSEGraph = __nested_webpack_require_657__(880);\n                coseBase.CoSEGraphManager = __nested_webpack_require_657__(578);\n                coseBase.CoSELayout = __nested_webpack_require_657__(765);\n                coseBase.CoSENode = __nested_webpack_require_657__(991);\n                coseBase.ConstraintHandler = __nested_webpack_require_657__(902);\n                module1.exports = coseBase;\n            /***/ },\n            /***/ 806: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_1369__)=>{\n                var FDLayoutConstants = __nested_webpack_require_1369__(551).FDLayoutConstants;\n                function CoSEConstants() {}\n                //CoSEConstants inherits static props in FDLayoutConstants\n                for(var prop in FDLayoutConstants){\n                    CoSEConstants[prop] = FDLayoutConstants[prop];\n                }\n                CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n                CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n                CoSEConstants.TILE = true;\n                CoSEConstants.TILING_PADDING_VERTICAL = 10;\n                CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n                CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                CoSEConstants.APPLY_LAYOUT = true;\n                CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\n                CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n                // This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n                // an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\n                CoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n                module1.exports = CoSEConstants;\n            /***/ },\n            /***/ 767: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_3019__)=>{\n                var FDLayoutEdge = __nested_webpack_require_3019__(551).FDLayoutEdge;\n                function CoSEEdge(source, target, vEdge) {\n                    FDLayoutEdge.call(this, source, target, vEdge);\n                }\n                CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n                for(var prop in FDLayoutEdge){\n                    CoSEEdge[prop] = FDLayoutEdge[prop];\n                }\n                module1.exports = CoSEEdge;\n            /***/ },\n            /***/ 880: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_3590__)=>{\n                var LGraph = __nested_webpack_require_3590__(551).LGraph;\n                function CoSEGraph(parent, graphMgr, vGraph) {\n                    LGraph.call(this, parent, graphMgr, vGraph);\n                }\n                CoSEGraph.prototype = Object.create(LGraph.prototype);\n                for(var prop in LGraph){\n                    CoSEGraph[prop] = LGraph[prop];\n                }\n                module1.exports = CoSEGraph;\n            /***/ },\n            /***/ 578: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_4135__)=>{\n                var LGraphManager = __nested_webpack_require_4135__(551).LGraphManager;\n                function CoSEGraphManager(layout) {\n                    LGraphManager.call(this, layout);\n                }\n                CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n                for(var prop in LGraphManager){\n                    CoSEGraphManager[prop] = LGraphManager[prop];\n                }\n                module1.exports = CoSEGraphManager;\n            /***/ },\n            /***/ 765: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_4714__)=>{\n                var FDLayout = __nested_webpack_require_4714__(551).FDLayout;\n                var CoSEGraphManager = __nested_webpack_require_4714__(578);\n                var CoSEGraph = __nested_webpack_require_4714__(880);\n                var CoSENode = __nested_webpack_require_4714__(991);\n                var CoSEEdge = __nested_webpack_require_4714__(767);\n                var CoSEConstants = __nested_webpack_require_4714__(806);\n                var ConstraintHandler = __nested_webpack_require_4714__(902);\n                var FDLayoutConstants = __nested_webpack_require_4714__(551).FDLayoutConstants;\n                var LayoutConstants = __nested_webpack_require_4714__(551).LayoutConstants;\n                var Point = __nested_webpack_require_4714__(551).Point;\n                var PointD = __nested_webpack_require_4714__(551).PointD;\n                var DimensionD = __nested_webpack_require_4714__(551).DimensionD;\n                var Layout = __nested_webpack_require_4714__(551).Layout;\n                var Integer = __nested_webpack_require_4714__(551).Integer;\n                var IGeometry = __nested_webpack_require_4714__(551).IGeometry;\n                var LGraph = __nested_webpack_require_4714__(551).LGraph;\n                var Transform = __nested_webpack_require_4714__(551).Transform;\n                var LinkedList = __nested_webpack_require_4714__(551).LinkedList;\n                function CoSELayout() {\n                    FDLayout.call(this);\n                    this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n                    this.constraints = {}; // keep layout constraints\n                }\n                CoSELayout.prototype = Object.create(FDLayout.prototype);\n                for(var prop in FDLayout){\n                    CoSELayout[prop] = FDLayout[prop];\n                }\n                CoSELayout.prototype.newGraphManager = function() {\n                    var gm = new CoSEGraphManager(this);\n                    this.graphManager = gm;\n                    return gm;\n                };\n                CoSELayout.prototype.newGraph = function(vGraph) {\n                    return new CoSEGraph(null, this.graphManager, vGraph);\n                };\n                CoSELayout.prototype.newNode = function(vNode) {\n                    return new CoSENode(this.graphManager, vNode);\n                };\n                CoSELayout.prototype.newEdge = function(vEdge) {\n                    return new CoSEEdge(null, null, vEdge);\n                };\n                CoSELayout.prototype.initParameters = function() {\n                    FDLayout.prototype.initParameters.call(this, arguments);\n                    if (!this.isSubLayout) {\n                        if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n                            this.idealEdgeLength = 10;\n                        } else {\n                            this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n                        }\n                        this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                        this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                        this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                        this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                        this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                        // variables for tree reduction support\n                        this.prunedNodesAll = [];\n                        this.growTreeIterations = 0;\n                        this.afterGrowthIterations = 0;\n                        this.isTreeGrowing = false;\n                        this.isGrowthFinished = false;\n                    }\n                };\n                // This method is used to set CoSE related parameters used by spring embedder.\n                CoSELayout.prototype.initSpringEmbedder = function() {\n                    FDLayout.prototype.initSpringEmbedder.call(this);\n                    // variables for cooling\n                    this.coolingCycle = 0;\n                    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n                    this.finalTemperature = 0.04;\n                    this.coolingAdjuster = 1;\n                };\n                CoSELayout.prototype.layout = function() {\n                    var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                    if (createBendsAsNeeded) {\n                        this.createBendpoints();\n                        this.graphManager.resetAllEdges();\n                    }\n                    this.level = 0;\n                    return this.classicLayout();\n                };\n                CoSELayout.prototype.classicLayout = function() {\n                    this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n                    this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n                    this.calcNoOfChildrenForAllNodes();\n                    this.graphManager.calcLowestCommonAncestors();\n                    this.graphManager.calcInclusionTreeDepths();\n                    this.graphManager.getRoot().calcEstimatedSize();\n                    this.calcIdealEdgeLengths();\n                    if (!this.incremental) {\n                        var forest = this.getFlatForest();\n                        // The graph associated with this layout is flat and a forest\n                        if (forest.length > 0) {\n                            this.positionNodesRadially(forest);\n                        } else {\n                            // Reduce the trees when incremental mode is not enabled and graph is not a forest \n                            this.reduceTrees();\n                            // Update nodes that gravity will be applied\n                            this.graphManager.resetAllNodesToApplyGravitation();\n                            var allNodes = new Set(this.getAllNodes());\n                            var intersection = this.nodesWithGravity.filter(function(x) {\n                                return allNodes.has(x);\n                            });\n                            this.graphManager.setAllNodesToApplyGravitation(intersection);\n                            this.positionNodesRandomly();\n                        }\n                    } else {\n                        if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n                            // Reduce the trees in incremental mode if only this constant is set to true \n                            this.reduceTrees();\n                            // Update nodes that gravity will be applied\n                            this.graphManager.resetAllNodesToApplyGravitation();\n                            var allNodes = new Set(this.getAllNodes());\n                            var intersection = this.nodesWithGravity.filter(function(x) {\n                                return allNodes.has(x);\n                            });\n                            this.graphManager.setAllNodesToApplyGravitation(intersection);\n                        }\n                    }\n                    if (Object.keys(this.constraints).length > 0) {\n                        ConstraintHandler.handleConstraints(this);\n                        this.initConstraintVariables();\n                    }\n                    this.initSpringEmbedder();\n                    if (CoSEConstants.APPLY_LAYOUT) {\n                        this.runSpringEmbedder();\n                    }\n                    return true;\n                };\n                CoSELayout.prototype.tick = function() {\n                    this.totalIterations++;\n                    if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n                        if (this.prunedNodesAll.length > 0) {\n                            this.isTreeGrowing = true;\n                        } else {\n                            return true;\n                        }\n                    }\n                    if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n                        if (this.isConverged()) {\n                            if (this.prunedNodesAll.length > 0) {\n                                this.isTreeGrowing = true;\n                            } else {\n                                return true;\n                            }\n                        }\n                        this.coolingCycle++;\n                        if (this.layoutQuality == 0) {\n                            // quality - \"draft\"\n                            this.coolingAdjuster = this.coolingCycle;\n                        } else if (this.layoutQuality == 1) {\n                            // quality - \"default\"\n                            this.coolingAdjuster = this.coolingCycle / 3;\n                        }\n                        // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n                        this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n                        this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n                    }\n                    // Operations while tree is growing again \n                    if (this.isTreeGrowing) {\n                        if (this.growTreeIterations % 10 == 0) {\n                            if (this.prunedNodesAll.length > 0) {\n                                this.graphManager.updateBounds();\n                                this.updateGrid();\n                                this.growTree(this.prunedNodesAll);\n                                // Update nodes that gravity will be applied\n                                this.graphManager.resetAllNodesToApplyGravitation();\n                                var allNodes = new Set(this.getAllNodes());\n                                var intersection = this.nodesWithGravity.filter(function(x) {\n                                    return allNodes.has(x);\n                                });\n                                this.graphManager.setAllNodesToApplyGravitation(intersection);\n                                this.graphManager.updateBounds();\n                                this.updateGrid();\n                                if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;\n                                else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                            } else {\n                                this.isTreeGrowing = false;\n                                this.isGrowthFinished = true;\n                            }\n                        }\n                        this.growTreeIterations++;\n                    }\n                    // Operations after growth is finished\n                    if (this.isGrowthFinished) {\n                        if (this.isConverged()) {\n                            return true;\n                        }\n                        if (this.afterGrowthIterations % 10 == 0) {\n                            this.graphManager.updateBounds();\n                            this.updateGrid();\n                        }\n                        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);\n                        else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n                        this.afterGrowthIterations++;\n                    }\n                    var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n                    var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n                    this.totalDisplacement = 0;\n                    this.graphManager.updateBounds();\n                    this.calcSpringForces();\n                    this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                    this.calcGravitationalForces();\n                    this.moveNodes();\n                    this.animate();\n                    return false; // Layout is not ended yet return false\n                };\n                CoSELayout.prototype.getPositionsData = function() {\n                    var allNodes = this.graphManager.getAllNodes();\n                    var pData = {};\n                    for(var i = 0; i < allNodes.length; i++){\n                        var rect = allNodes[i].rect;\n                        var id = allNodes[i].id;\n                        pData[id] = {\n                            id: id,\n                            x: rect.getCenterX(),\n                            y: rect.getCenterY(),\n                            w: rect.width,\n                            h: rect.height\n                        };\n                    }\n                    return pData;\n                };\n                CoSELayout.prototype.runSpringEmbedder = function() {\n                    this.initialAnimationPeriod = 25;\n                    this.animationPeriod = this.initialAnimationPeriod;\n                    var layoutEnded = false;\n                    // If aminate option is 'during' signal that layout is supposed to start iterating\n                    if (FDLayoutConstants.ANIMATE === \"during\") {\n                        this.emit(\"layoutstarted\");\n                    } else {\n                        // If aminate option is 'during' tick() function will be called on index.js\n                        while(!layoutEnded){\n                            layoutEnded = this.tick();\n                        }\n                        this.graphManager.updateBounds();\n                    }\n                };\n                // overrides moveNodes method in FDLayout\n                CoSELayout.prototype.moveNodes = function() {\n                    var lNodes = this.getAllNodes();\n                    var node;\n                    // calculate displacement for each node \n                    for(var i = 0; i < lNodes.length; i++){\n                        node = lNodes[i];\n                        node.calculateDisplacement();\n                    }\n                    if (Object.keys(this.constraints).length > 0) {\n                        this.updateDisplacements();\n                    }\n                    // move each node\n                    for(var i = 0; i < lNodes.length; i++){\n                        node = lNodes[i];\n                        node.move();\n                    }\n                };\n                // constraint related methods: initConstraintVariables and updateDisplacements\n                // initialize constraint related variables\n                CoSELayout.prototype.initConstraintVariables = function() {\n                    var self = this;\n                    this.idToNodeMap = new Map();\n                    this.fixedNodeSet = new Set();\n                    var allNodes = this.graphManager.getAllNodes();\n                    // fill idToNodeMap\n                    for(var i = 0; i < allNodes.length; i++){\n                        var node = allNodes[i];\n                        this.idToNodeMap.set(node.id, node);\n                    }\n                    // calculate fixed node weight for given compound node\n                    var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n                        var nodes = compoundNode.getChild().getNodes();\n                        var node;\n                        var fixedNodeWeight = 0;\n                        for(var i = 0; i < nodes.length; i++){\n                            node = nodes[i];\n                            if (node.getChild() == null) {\n                                if (self.fixedNodeSet.has(node.id)) {\n                                    fixedNodeWeight += 100;\n                                }\n                            } else {\n                                fixedNodeWeight += calculateCompoundWeight(node);\n                            }\n                        }\n                        return fixedNodeWeight;\n                    };\n                    if (this.constraints.fixedNodeConstraint) {\n                        // fill fixedNodeSet\n                        this.constraints.fixedNodeConstraint.forEach(function(nodeData) {\n                            self.fixedNodeSet.add(nodeData.nodeId);\n                        });\n                        // assign fixed node weights to compounds if they contain fixed nodes\n                        var allNodes = this.graphManager.getAllNodes();\n                        var node;\n                        for(var i = 0; i < allNodes.length; i++){\n                            node = allNodes[i];\n                            if (node.getChild() != null) {\n                                var fixedNodeWeight = calculateCompoundWeight(node);\n                                if (fixedNodeWeight > 0) {\n                                    node.fixedNodeWeight = fixedNodeWeight;\n                                }\n                            }\n                        }\n                    }\n                    if (this.constraints.relativePlacementConstraint) {\n                        var nodeToDummyForVerticalAlignment = new Map();\n                        var nodeToDummyForHorizontalAlignment = new Map();\n                        this.dummyToNodeForVerticalAlignment = new Map();\n                        this.dummyToNodeForHorizontalAlignment = new Map();\n                        this.fixedNodesOnHorizontal = new Set();\n                        this.fixedNodesOnVertical = new Set();\n                        // fill maps and sets\n                        this.fixedNodeSet.forEach(function(nodeId) {\n                            self.fixedNodesOnHorizontal.add(nodeId);\n                            self.fixedNodesOnVertical.add(nodeId);\n                        });\n                        if (this.constraints.alignmentConstraint) {\n                            if (this.constraints.alignmentConstraint.vertical) {\n                                var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n                                for(var i = 0; i < verticalAlignment.length; i++){\n                                    this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n                                    verticalAlignment[i].forEach(function(nodeId) {\n                                        nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n                                        self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n                                        if (self.fixedNodeSet.has(nodeId)) {\n                                            self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n                                        }\n                                    });\n                                }\n                            }\n                            if (this.constraints.alignmentConstraint.horizontal) {\n                                var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n                                for(var i = 0; i < horizontalAlignment.length; i++){\n                                    this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n                                    horizontalAlignment[i].forEach(function(nodeId) {\n                                        nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n                                        self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n                                        if (self.fixedNodeSet.has(nodeId)) {\n                                            self.fixedNodesOnVertical.add(\"dummy\" + i);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                        if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n                            this.shuffle = function(array) {\n                                var j, x, i;\n                                for(i = array.length - 1; i >= 2 * array.length / 3; i--){\n                                    j = Math.floor(Math.random() * (i + 1));\n                                    x = array[i];\n                                    array[i] = array[j];\n                                    array[j] = x;\n                                }\n                                return array;\n                            };\n                            this.nodesInRelativeHorizontal = [];\n                            this.nodesInRelativeVertical = [];\n                            this.nodeToRelativeConstraintMapHorizontal = new Map();\n                            this.nodeToRelativeConstraintMapVertical = new Map();\n                            this.nodeToTempPositionMapHorizontal = new Map();\n                            this.nodeToTempPositionMapVertical = new Map();\n                            // fill arrays and maps\n                            this.constraints.relativePlacementConstraint.forEach(function(constraint) {\n                                if (constraint.left) {\n                                    var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                                    var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                                    if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n                                        self.nodesInRelativeHorizontal.push(nodeIdLeft);\n                                        self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n                                        if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n                                            self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n                                        } else {\n                                            self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n                                        }\n                                    }\n                                    if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n                                        self.nodesInRelativeHorizontal.push(nodeIdRight);\n                                        self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n                                        if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n                                            self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n                                        } else {\n                                            self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n                                        }\n                                    }\n                                    self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({\n                                        right: nodeIdRight,\n                                        gap: constraint.gap\n                                    });\n                                    self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({\n                                        left: nodeIdLeft,\n                                        gap: constraint.gap\n                                    });\n                                } else {\n                                    var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                                    var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                                    if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n                                        self.nodesInRelativeVertical.push(nodeIdTop);\n                                        self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n                                        if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n                                            self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n                                        } else {\n                                            self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n                                        }\n                                    }\n                                    if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n                                        self.nodesInRelativeVertical.push(nodeIdBottom);\n                                        self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n                                        if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n                                            self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n                                        } else {\n                                            self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n                                        }\n                                    }\n                                    self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({\n                                        bottom: nodeIdBottom,\n                                        gap: constraint.gap\n                                    });\n                                    self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({\n                                        top: nodeIdTop,\n                                        gap: constraint.gap\n                                    });\n                                }\n                            });\n                        } else {\n                            var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n                            var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n                            // construct subgraphs from relative placement constraints \n                            this.constraints.relativePlacementConstraint.forEach(function(constraint) {\n                                if (constraint.left) {\n                                    var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                                    var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                                    if (subGraphOnHorizontal.has(left)) {\n                                        subGraphOnHorizontal.get(left).push(right);\n                                    } else {\n                                        subGraphOnHorizontal.set(left, [\n                                            right\n                                        ]);\n                                    }\n                                    if (subGraphOnHorizontal.has(right)) {\n                                        subGraphOnHorizontal.get(right).push(left);\n                                    } else {\n                                        subGraphOnHorizontal.set(right, [\n                                            left\n                                        ]);\n                                    }\n                                } else {\n                                    var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                                    var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                                    if (subGraphOnVertical.has(top)) {\n                                        subGraphOnVertical.get(top).push(bottom);\n                                    } else {\n                                        subGraphOnVertical.set(top, [\n                                            bottom\n                                        ]);\n                                    }\n                                    if (subGraphOnVertical.has(bottom)) {\n                                        subGraphOnVertical.get(bottom).push(top);\n                                    } else {\n                                        subGraphOnVertical.set(bottom, [\n                                            top\n                                        ]);\n                                    }\n                                }\n                            });\n                            // function to construct components from a given graph \n                            // also returns an array that keeps whether each component contains fixed node\n                            var constructComponents = function constructComponents(graph, fixedNodes) {\n                                var components = [];\n                                var isFixed = [];\n                                var queue = new LinkedList();\n                                var visited = new Set();\n                                var count = 0;\n                                graph.forEach(function(value, key) {\n                                    if (!visited.has(key)) {\n                                        components[count] = [];\n                                        isFixed[count] = false;\n                                        var currentNode = key;\n                                        queue.push(currentNode);\n                                        visited.add(currentNode);\n                                        components[count].push(currentNode);\n                                        while(queue.length != 0){\n                                            currentNode = queue.shift();\n                                            if (fixedNodes.has(currentNode)) {\n                                                isFixed[count] = true;\n                                            }\n                                            var neighbors = graph.get(currentNode);\n                                            neighbors.forEach(function(neighbor) {\n                                                if (!visited.has(neighbor)) {\n                                                    queue.push(neighbor);\n                                                    visited.add(neighbor);\n                                                    components[count].push(neighbor);\n                                                }\n                                            });\n                                        }\n                                        count++;\n                                    }\n                                });\n                                return {\n                                    components: components,\n                                    isFixed: isFixed\n                                };\n                            };\n                            var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n                            this.componentsOnHorizontal = resultOnHorizontal.components;\n                            this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n                            var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n                            this.componentsOnVertical = resultOnVertical.components;\n                            this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n                        }\n                    }\n                };\n                // updates node displacements based on constraints\n                CoSELayout.prototype.updateDisplacements = function() {\n                    var self = this;\n                    if (this.constraints.fixedNodeConstraint) {\n                        this.constraints.fixedNodeConstraint.forEach(function(nodeData) {\n                            var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n                            fixedNode.displacementX = 0;\n                            fixedNode.displacementY = 0;\n                        });\n                    }\n                    if (this.constraints.alignmentConstraint) {\n                        if (this.constraints.alignmentConstraint.vertical) {\n                            var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n                            for(var i = 0; i < allVerticalAlignments.length; i++){\n                                var totalDisplacementX = 0;\n                                for(var j = 0; j < allVerticalAlignments[i].length; j++){\n                                    if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n                                        totalDisplacementX = 0;\n                                        break;\n                                    }\n                                    totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n                                }\n                                var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n                                for(var j = 0; j < allVerticalAlignments[i].length; j++){\n                                    this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n                                }\n                            }\n                        }\n                        if (this.constraints.alignmentConstraint.horizontal) {\n                            var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n                            for(var i = 0; i < allHorizontalAlignments.length; i++){\n                                var totalDisplacementY = 0;\n                                for(var j = 0; j < allHorizontalAlignments[i].length; j++){\n                                    if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n                                        totalDisplacementY = 0;\n                                        break;\n                                    }\n                                    totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n                                }\n                                var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n                                for(var j = 0; j < allHorizontalAlignments[i].length; j++){\n                                    this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n                                }\n                            }\n                        }\n                    }\n                    if (this.constraints.relativePlacementConstraint) {\n                        if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n                            // shuffle array to randomize node processing order\n                            if (this.totalIterations % 10 == 0) {\n                                this.shuffle(this.nodesInRelativeHorizontal);\n                                this.shuffle(this.nodesInRelativeVertical);\n                            }\n                            this.nodesInRelativeHorizontal.forEach(function(nodeId) {\n                                if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                                    var displacement = 0;\n                                    if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                                        displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n                                    } else {\n                                        displacement = self.idToNodeMap.get(nodeId).displacementX;\n                                    }\n                                    self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function(constraint) {\n                                        if (constraint.right) {\n                                            var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n                                            if (diff < constraint.gap) {\n                                                displacement -= constraint.gap - diff;\n                                            }\n                                        } else {\n                                            var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n                                            if (diff < constraint.gap) {\n                                                displacement += constraint.gap - diff;\n                                            }\n                                        }\n                                    });\n                                    self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n                                    if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                                        self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function(nodeId) {\n                                            self.idToNodeMap.get(nodeId).displacementX = displacement;\n                                        });\n                                    } else {\n                                        self.idToNodeMap.get(nodeId).displacementX = displacement;\n                                    }\n                                }\n                            });\n                            this.nodesInRelativeVertical.forEach(function(nodeId) {\n                                if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                                    var displacement = 0;\n                                    if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                                        displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n                                    } else {\n                                        displacement = self.idToNodeMap.get(nodeId).displacementY;\n                                    }\n                                    self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function(constraint) {\n                                        if (constraint.bottom) {\n                                            var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n                                            if (diff < constraint.gap) {\n                                                displacement -= constraint.gap - diff;\n                                            }\n                                        } else {\n                                            var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n                                            if (diff < constraint.gap) {\n                                                displacement += constraint.gap - diff;\n                                            }\n                                        }\n                                    });\n                                    self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n                                    if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                                        self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function(nodeId) {\n                                            self.idToNodeMap.get(nodeId).displacementY = displacement;\n                                        });\n                                    } else {\n                                        self.idToNodeMap.get(nodeId).displacementY = displacement;\n                                    }\n                                }\n                            });\n                        } else {\n                            for(var i = 0; i < this.componentsOnHorizontal.length; i++){\n                                var component = this.componentsOnHorizontal[i];\n                                if (this.fixedComponentsOnHorizontal[i]) {\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                                            this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function(nodeId) {\n                                                self.idToNodeMap.get(nodeId).displacementX = 0;\n                                            });\n                                        } else {\n                                            this.idToNodeMap.get(component[j]).displacementX = 0;\n                                        }\n                                    }\n                                } else {\n                                    var sum = 0;\n                                    var count = 0;\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                                            var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n                                            sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n                                            count += actualNodes.length;\n                                        } else {\n                                            sum += this.idToNodeMap.get(component[j]).displacementX;\n                                            count++;\n                                        }\n                                    }\n                                    var averageDisplacement = sum / count;\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                                            this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function(nodeId) {\n                                                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n                                            });\n                                        } else {\n                                            this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n                                        }\n                                    }\n                                }\n                            }\n                            for(var i = 0; i < this.componentsOnVertical.length; i++){\n                                var component = this.componentsOnVertical[i];\n                                if (this.fixedComponentsOnVertical[i]) {\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                                            this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function(nodeId) {\n                                                self.idToNodeMap.get(nodeId).displacementY = 0;\n                                            });\n                                        } else {\n                                            this.idToNodeMap.get(component[j]).displacementY = 0;\n                                        }\n                                    }\n                                } else {\n                                    var sum = 0;\n                                    var count = 0;\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                                            var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n                                            sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n                                            count += actualNodes.length;\n                                        } else {\n                                            sum += this.idToNodeMap.get(component[j]).displacementY;\n                                            count++;\n                                        }\n                                    }\n                                    var averageDisplacement = sum / count;\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                                            this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function(nodeId) {\n                                                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n                                            });\n                                        } else {\n                                            this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                };\n                CoSELayout.prototype.calculateNodesToApplyGravitationTo = function() {\n                    var nodeList = [];\n                    var graph;\n                    var graphs = this.graphManager.getGraphs();\n                    var size = graphs.length;\n                    var i;\n                    for(i = 0; i < size; i++){\n                        graph = graphs[i];\n                        graph.updateConnected();\n                        if (!graph.isConnected) {\n                            nodeList = nodeList.concat(graph.getNodes());\n                        }\n                    }\n                    return nodeList;\n                };\n                CoSELayout.prototype.createBendpoints = function() {\n                    var edges = [];\n                    edges = edges.concat(this.graphManager.getAllEdges());\n                    var visited = new Set();\n                    var i;\n                    for(i = 0; i < edges.length; i++){\n                        var edge = edges[i];\n                        if (!visited.has(edge)) {\n                            var source = edge.getSource();\n                            var target = edge.getTarget();\n                            if (source == target) {\n                                edge.getBendpoints().push(new PointD());\n                                edge.getBendpoints().push(new PointD());\n                                this.createDummyNodesForBendpoints(edge);\n                                visited.add(edge);\n                            } else {\n                                var edgeList = [];\n                                edgeList = edgeList.concat(source.getEdgeListToNode(target));\n                                edgeList = edgeList.concat(target.getEdgeListToNode(source));\n                                if (!visited.has(edgeList[0])) {\n                                    if (edgeList.length > 1) {\n                                        var k;\n                                        for(k = 0; k < edgeList.length; k++){\n                                            var multiEdge = edgeList[k];\n                                            multiEdge.getBendpoints().push(new PointD());\n                                            this.createDummyNodesForBendpoints(multiEdge);\n                                        }\n                                    }\n                                    edgeList.forEach(function(edge) {\n                                        visited.add(edge);\n                                    });\n                                }\n                            }\n                        }\n                        if (visited.size == edges.length) {\n                            break;\n                        }\n                    }\n                };\n                CoSELayout.prototype.positionNodesRadially = function(forest) {\n                    // We tile the trees to a grid row by row; first tree starts at (0,0)\n                    var currentStartingPoint = new Point(0, 0);\n                    var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n                    var height = 0;\n                    var currentY = 0;\n                    var currentX = 0;\n                    var point = new PointD(0, 0);\n                    for(var i = 0; i < forest.length; i++){\n                        if (i % numberOfColumns == 0) {\n                            // Start of a new row, make the x coordinate 0, increment the\n                            // y coordinate with the max height of the previous row\n                            currentX = 0;\n                            currentY = height;\n                            if (i != 0) {\n                                currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n                            }\n                            height = 0;\n                        }\n                        var tree = forest[i];\n                        // Find the center of the tree\n                        var centerNode = Layout.findCenterOfTree(tree);\n                        // Set the staring point of the next tree\n                        currentStartingPoint.x = currentX;\n                        currentStartingPoint.y = currentY;\n                        // Do a radial layout starting with the center\n                        point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n                        if (point.y > height) {\n                            height = Math.floor(point.y);\n                        }\n                        currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n                    }\n                    this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n                };\n                CoSELayout.radialLayout = function(tree, centerNode, startingPoint) {\n                    var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n                    CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n                    var bounds = LGraph.calculateBounds(tree);\n                    var transform = new Transform();\n                    transform.setDeviceOrgX(bounds.getMinX());\n                    transform.setDeviceOrgY(bounds.getMinY());\n                    transform.setWorldOrgX(startingPoint.x);\n                    transform.setWorldOrgY(startingPoint.y);\n                    for(var i = 0; i < tree.length; i++){\n                        var node = tree[i];\n                        node.transform(transform);\n                    }\n                    var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n                    return transform.inverseTransformPoint(bottomRight);\n                };\n                CoSELayout.branchRadialLayout = function(node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n                    // First, position this node by finding its angle.\n                    var halfInterval = (endAngle - startAngle + 1) / 2;\n                    if (halfInterval < 0) {\n                        halfInterval += 180;\n                    }\n                    var nodeAngle = (halfInterval + startAngle) % 360;\n                    var teta = nodeAngle * IGeometry.TWO_PI / 360;\n                    // Make polar to java cordinate conversion.\n                    var cos_teta = Math.cos(teta);\n                    var x_ = distance * Math.cos(teta);\n                    var y_ = distance * Math.sin(teta);\n                    node.setCenter(x_, y_);\n                    // Traverse all neighbors of this node and recursively call this\n                    // function.\n                    var neighborEdges = [];\n                    neighborEdges = neighborEdges.concat(node.getEdges());\n                    var childCount = neighborEdges.length;\n                    if (parentOfNode != null) {\n                        childCount--;\n                    }\n                    var branchCount = 0;\n                    var incEdgesCount = neighborEdges.length;\n                    var startIndex;\n                    var edges = node.getEdgesBetween(parentOfNode);\n                    // If there are multiple edges, prune them until there remains only one\n                    // edge.\n                    while(edges.length > 1){\n                        //neighborEdges.remove(edges.remove(0));\n                        var temp = edges[0];\n                        edges.splice(0, 1);\n                        var index = neighborEdges.indexOf(temp);\n                        if (index >= 0) {\n                            neighborEdges.splice(index, 1);\n                        }\n                        incEdgesCount--;\n                        childCount--;\n                    }\n                    if (parentOfNode != null) {\n                        //assert edges.length == 1;\n                        startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n                    } else {\n                        startIndex = 0;\n                    }\n                    var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n                    for(var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount){\n                        var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n                        // Don't back traverse to root node in current tree.\n                        if (currentNeighbor == parentOfNode) {\n                            continue;\n                        }\n                        var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n                        var childEndAngle = (childStartAngle + stepAngle) % 360;\n                        CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n                        branchCount++;\n                    }\n                };\n                CoSELayout.maxDiagonalInTree = function(tree) {\n                    var maxDiagonal = Integer.MIN_VALUE;\n                    for(var i = 0; i < tree.length; i++){\n                        var node = tree[i];\n                        var diagonal = node.getDiagonal();\n                        if (diagonal > maxDiagonal) {\n                            maxDiagonal = diagonal;\n                        }\n                    }\n                    return maxDiagonal;\n                };\n                CoSELayout.prototype.calcRepulsionRange = function() {\n                    // formula is 2 x (level + 1) x idealEdgeLength\n                    return 2 * (this.level + 1) * this.idealEdgeLength;\n                };\n                // Tiling methods\n                // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n                CoSELayout.prototype.groupZeroDegreeMembers = function() {\n                    var self = this;\n                    // array of [parent_id x oneDegreeNode_id]\n                    var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n                    this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n                    this.idToDummyNode = {}; // A map of id to dummy node \n                    var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n                    var allNodes = this.graphManager.getAllNodes();\n                    // Fill zero degree list\n                    for(var i = 0; i < allNodes.length; i++){\n                        var node = allNodes[i];\n                        var parent = node.getParent();\n                        // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n                        if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n                            zeroDegree.push(node);\n                        }\n                    }\n                    // Create a map of parent node and its zero degree members\n                    for(var i = 0; i < zeroDegree.length; i++){\n                        var node = zeroDegree[i]; // Zero degree node itself\n                        var p_id = node.getParent().id; // Parent id\n                        if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n                        tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n                    }\n                    // If there are at least two nodes at a level, create a dummy compound for them\n                    Object.keys(tempMemberGroups).forEach(function(p_id) {\n                        if (tempMemberGroups[p_id].length > 1) {\n                            var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n                            self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n                            var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n                            // Create a dummy compound with calculated id\n                            var dummyCompound = new CoSENode(self.graphManager);\n                            dummyCompound.id = dummyCompoundId;\n                            dummyCompound.paddingLeft = parent.paddingLeft || 0;\n                            dummyCompound.paddingRight = parent.paddingRight || 0;\n                            dummyCompound.paddingBottom = parent.paddingBottom || 0;\n                            dummyCompound.paddingTop = parent.paddingTop || 0;\n                            self.idToDummyNode[dummyCompoundId] = dummyCompound;\n                            var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n                            var parentGraph = parent.getChild();\n                            // Add dummy compound to parent the graph\n                            parentGraph.add(dummyCompound);\n                            // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n                            for(var i = 0; i < tempMemberGroups[p_id].length; i++){\n                                var node = tempMemberGroups[p_id][i];\n                                parentGraph.remove(node);\n                                dummyParentGraph.add(node);\n                            }\n                        }\n                    });\n                };\n                CoSELayout.prototype.clearCompounds = function() {\n                    var childGraphMap = {};\n                    var idToNode = {};\n                    // Get compound ordering by finding the inner one first\n                    this.performDFSOnCompounds();\n                    for(var i = 0; i < this.compoundOrder.length; i++){\n                        idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n                        childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n                        // Remove children of compounds\n                        this.graphManager.remove(this.compoundOrder[i].getChild());\n                        this.compoundOrder[i].child = null;\n                    }\n                    this.graphManager.resetAllNodes();\n                    // Tile the removed children\n                    this.tileCompoundMembers(childGraphMap, idToNode);\n                };\n                CoSELayout.prototype.clearZeroDegreeMembers = function() {\n                    var self = this;\n                    var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n                    Object.keys(this.memberGroups).forEach(function(id) {\n                        var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n                        tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                        // Set the width and height of the dummy compound as calculated\n                        compoundNode.rect.width = tiledZeroDegreePack[id].width;\n                        compoundNode.rect.height = tiledZeroDegreePack[id].height;\n                        compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n                        // compound left and top margings for labels\n                        // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n                        // otherwise they stay as zero\n                        compoundNode.labelMarginLeft = 0;\n                        compoundNode.labelMarginTop = 0;\n                        // Update compound bounds considering its label properties and set label margins for left and top\n                        if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                            var width = compoundNode.rect.width;\n                            var height = compoundNode.rect.height;\n                            if (compoundNode.labelWidth) {\n                                if (compoundNode.labelPosHorizontal == \"left\") {\n                                    compoundNode.rect.x -= compoundNode.labelWidth;\n                                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                                    compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                                } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                                    compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                                    compoundNode.setWidth(compoundNode.labelWidth);\n                                    compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                                } else if (compoundNode.labelPosHorizontal == \"right\") {\n                                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                                }\n                            }\n                            if (compoundNode.labelHeight) {\n                                if (compoundNode.labelPosVertical == \"top\") {\n                                    compoundNode.rect.y -= compoundNode.labelHeight;\n                                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                                    compoundNode.labelMarginTop = compoundNode.labelHeight;\n                                } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                                    compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                                    compoundNode.setHeight(compoundNode.labelHeight);\n                                    compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                                } else if (compoundNode.labelPosVertical == \"bottom\") {\n                                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                                }\n                            }\n                        }\n                    });\n                };\n                CoSELayout.prototype.repopulateCompounds = function() {\n                    for(var i = this.compoundOrder.length - 1; i >= 0; i--){\n                        var lCompoundNode = this.compoundOrder[i];\n                        var id = lCompoundNode.id;\n                        var horizontalMargin = lCompoundNode.paddingLeft;\n                        var verticalMargin = lCompoundNode.paddingTop;\n                        var labelMarginLeft = lCompoundNode.labelMarginLeft;\n                        var labelMarginTop = lCompoundNode.labelMarginTop;\n                        this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n                    }\n                };\n                CoSELayout.prototype.repopulateZeroDegreeMembers = function() {\n                    var self = this;\n                    var tiledPack = this.tiledZeroDegreePack;\n                    Object.keys(tiledPack).forEach(function(id) {\n                        var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n                        var horizontalMargin = compoundNode.paddingLeft;\n                        var verticalMargin = compoundNode.paddingTop;\n                        var labelMarginLeft = compoundNode.labelMarginLeft;\n                        var labelMarginTop = compoundNode.labelMarginTop;\n                        // Adjust the positions of nodes wrt its compound\n                        self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n                    });\n                };\n                CoSELayout.prototype.getToBeTiled = function(node) {\n                    var id = node.id;\n                    //firstly check the previous results\n                    if (this.toBeTiled[id] != null) {\n                        return this.toBeTiled[id];\n                    }\n                    //only compound nodes are to be tiled\n                    var childGraph = node.getChild();\n                    if (childGraph == null) {\n                        this.toBeTiled[id] = false;\n                        return false;\n                    }\n                    var children = childGraph.getNodes(); // Get the children nodes\n                    //a compound node is not to be tiled if all of its compound children are not to be tiled\n                    for(var i = 0; i < children.length; i++){\n                        var theChild = children[i];\n                        if (this.getNodeDegree(theChild) > 0) {\n                            this.toBeTiled[id] = false;\n                            return false;\n                        }\n                        //pass the children not having the compound structure\n                        if (theChild.getChild() == null) {\n                            this.toBeTiled[theChild.id] = false;\n                            continue;\n                        }\n                        if (!this.getToBeTiled(theChild)) {\n                            this.toBeTiled[id] = false;\n                            return false;\n                        }\n                    }\n                    this.toBeTiled[id] = true;\n                    return true;\n                };\n                // Get degree of a node depending of its edges and independent of its children\n                CoSELayout.prototype.getNodeDegree = function(node) {\n                    var id = node.id;\n                    var edges = node.getEdges();\n                    var degree = 0;\n                    // For the edges connected\n                    for(var i = 0; i < edges.length; i++){\n                        var edge = edges[i];\n                        if (edge.getSource().id !== edge.getTarget().id) {\n                            degree = degree + 1;\n                        }\n                    }\n                    return degree;\n                };\n                // Get degree of a node with its children\n                CoSELayout.prototype.getNodeDegreeWithChildren = function(node) {\n                    var degree = this.getNodeDegree(node);\n                    if (node.getChild() == null) {\n                        return degree;\n                    }\n                    var children = node.getChild().getNodes();\n                    for(var i = 0; i < children.length; i++){\n                        var child = children[i];\n                        degree += this.getNodeDegreeWithChildren(child);\n                    }\n                    return degree;\n                };\n                CoSELayout.prototype.performDFSOnCompounds = function() {\n                    this.compoundOrder = [];\n                    this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n                };\n                CoSELayout.prototype.fillCompexOrderByDFS = function(children) {\n                    for(var i = 0; i < children.length; i++){\n                        var child = children[i];\n                        if (child.getChild() != null) {\n                            this.fillCompexOrderByDFS(child.getChild().getNodes());\n                        }\n                        if (this.getToBeTiled(child)) {\n                            this.compoundOrder.push(child);\n                        }\n                    }\n                };\n                /**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/ CoSELayout.prototype.adjustLocations = function(organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n                    x += compoundHorizontalMargin + compoundLabelMarginLeft;\n                    y += compoundVerticalMargin + compoundLabelMarginTop;\n                    var left = x;\n                    for(var i = 0; i < organization.rows.length; i++){\n                        var row = organization.rows[i];\n                        x = left;\n                        var maxHeight = 0;\n                        for(var j = 0; j < row.length; j++){\n                            var lnode = row[j];\n                            lnode.rect.x = x; // + lnode.rect.width / 2;\n                            lnode.rect.y = y; // + lnode.rect.height / 2;\n                            x += lnode.rect.width + organization.horizontalPadding;\n                            if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n                        }\n                        y += maxHeight + organization.verticalPadding;\n                    }\n                };\n                CoSELayout.prototype.tileCompoundMembers = function(childGraphMap, idToNode) {\n                    var self = this;\n                    this.tiledMemberPack = [];\n                    Object.keys(childGraphMap).forEach(function(id) {\n                        // Get the compound node\n                        var compoundNode = idToNode[id];\n                        self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                        compoundNode.rect.width = self.tiledMemberPack[id].width;\n                        compoundNode.rect.height = self.tiledMemberPack[id].height;\n                        compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n                        // compound left and top margings for labels\n                        // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n                        // otherwise they stay as zero\n                        compoundNode.labelMarginLeft = 0;\n                        compoundNode.labelMarginTop = 0;\n                        // Update compound bounds considering its label properties and set label margins for left and top\n                        if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                            var width = compoundNode.rect.width;\n                            var height = compoundNode.rect.height;\n                            if (compoundNode.labelWidth) {\n                                if (compoundNode.labelPosHorizontal == \"left\") {\n                                    compoundNode.rect.x -= compoundNode.labelWidth;\n                                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                                    compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                                } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                                    compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                                    compoundNode.setWidth(compoundNode.labelWidth);\n                                    compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                                } else if (compoundNode.labelPosHorizontal == \"right\") {\n                                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                                }\n                            }\n                            if (compoundNode.labelHeight) {\n                                if (compoundNode.labelPosVertical == \"top\") {\n                                    compoundNode.rect.y -= compoundNode.labelHeight;\n                                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                                    compoundNode.labelMarginTop = compoundNode.labelHeight;\n                                } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                                    compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                                    compoundNode.setHeight(compoundNode.labelHeight);\n                                    compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                                } else if (compoundNode.labelPosVertical == \"bottom\") {\n                                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                                }\n                            }\n                        }\n                    });\n                };\n                CoSELayout.prototype.tileNodes = function(nodes, minWidth) {\n                    var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n                    var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n                    var horizontalRatio = this.getOrgRatio(horizontalOrg);\n                    var verticalRatio = this.getOrgRatio(verticalOrg);\n                    var bestOrg;\n                    // the best ratio is the one that is closer to 1 since the ratios are already normalized\n                    // and the best organization is the one that has the best ratio\n                    if (verticalRatio < horizontalRatio) {\n                        bestOrg = verticalOrg;\n                    } else {\n                        bestOrg = horizontalOrg;\n                    }\n                    return bestOrg;\n                };\n                // get the width/height ratio of the organization that is normalized so that it will not be less than 1\n                CoSELayout.prototype.getOrgRatio = function(organization) {\n                    // get dimensions and calculate the initial ratio\n                    var width = organization.width;\n                    var height = organization.height;\n                    var ratio = width / height;\n                    // if the initial ratio is less then 1 then inverse it\n                    if (ratio < 1) {\n                        ratio = 1 / ratio;\n                    }\n                    // return the normalized ratio\n                    return ratio;\n                };\n                /*\n * Calculates the ideal width for the rows. This method assumes that\n * each node has the same sizes and calculates the ideal row width that\n * approximates a square shaped complex accordingly. However, since nodes would\n * have different sizes some rows would have different sizes and the resulting\n * shape would not be an exact square.\n */ CoSELayout.prototype.calcIdealRowWidth = function(members, favorHorizontalDim) {\n                    // To approximate a square shaped complex we need to make complex width equal to complex height.\n                    // To achieve this we need to solve the following equation system for hc:\n                    // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n                    // where x is the avarage width of the nodes, y is the avarage height of nodes\n                    // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n                    // hc and vc are the number of rows in horizontal and vertical dimensions\n                    // n is number of members.\n                    var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n                    var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n                    // number of members\n                    var membersSize = members.length;\n                    // sum of the width of all members\n                    var totalWidth = 0;\n                    // sum of the height of all members\n                    var totalHeight = 0;\n                    var maxWidth = 0;\n                    // traverse all members to calculate total width and total height and get the maximum members width\n                    members.forEach(function(node) {\n                        totalWidth += node.getWidth();\n                        totalHeight += node.getHeight();\n                        if (node.getWidth() > maxWidth) {\n                            maxWidth = node.getWidth();\n                        }\n                    });\n                    // average width of the members\n                    var averageWidth = totalWidth / membersSize;\n                    // average height of the members\n                    var averageHeight = totalHeight / membersSize;\n                    // solving the initial equation system for the hc yields the following second degree equation:\n                    // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n                    // the delta value to solve the equation above for hc\n                    var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n                    // solve the equation using delta value to calculate the horizontal count\n                    // that represents the number of nodes in an ideal row\n                    var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n                    // round the calculated horizontal count up or down according to the favored dimension\n                    var horizontalCount;\n                    if (favorHorizontalDim) {\n                        horizontalCount = Math.ceil(horizontalCountDouble);\n                        // if horizontalCount count is not a float value then both of rounding to floor and ceil\n                        // will yield the same values. Instead of repeating the same calculation try going up\n                        // while favoring horizontal dimension in such cases\n                        if (horizontalCount == horizontalCountDouble) {\n                            horizontalCount++;\n                        }\n                    } else {\n                        horizontalCount = Math.floor(horizontalCountDouble);\n                    }\n                    // ideal width to be calculated\n                    var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n                    // if max width is bigger than calculated ideal width reset ideal width to it\n                    if (maxWidth > idealWidth) {\n                        idealWidth = maxWidth;\n                    }\n                    // add the left-right margins to the ideal row width\n                    idealWidth += horizontalPadding * 2;\n                    // return the ideal row width1\n                    return idealWidth;\n                };\n                CoSELayout.prototype.tileNodesByFavoringDim = function(nodes, minWidth, favorHorizontalDim) {\n                    var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n                    var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n                    var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n                    var organization = {\n                        rows: [],\n                        rowWidth: [],\n                        rowHeight: [],\n                        width: 0,\n                        height: minWidth,\n                        verticalPadding: verticalPadding,\n                        horizontalPadding: horizontalPadding,\n                        centerX: 0,\n                        centerY: 0\n                    };\n                    if (tilingCompareBy) {\n                        organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n                    }\n                    var getNodeArea = function getNodeArea(n) {\n                        return n.rect.width * n.rect.height;\n                    };\n                    var areaCompareFcn = function areaCompareFcn(n1, n2) {\n                        return getNodeArea(n2) - getNodeArea(n1);\n                    };\n                    // Sort the nodes in descending order of their areas\n                    nodes.sort(function(n1, n2) {\n                        var cmpBy = areaCompareFcn;\n                        if (organization.idealRowWidth) {\n                            cmpBy = tilingCompareBy;\n                            return cmpBy(n1.id, n2.id);\n                        }\n                        return cmpBy(n1, n2);\n                    });\n                    // Create the organization -> calculate compound center\n                    var sumCenterX = 0;\n                    var sumCenterY = 0;\n                    for(var i = 0; i < nodes.length; i++){\n                        var lNode = nodes[i];\n                        sumCenterX += lNode.getCenterX();\n                        sumCenterY += lNode.getCenterY();\n                    }\n                    organization.centerX = sumCenterX / nodes.length;\n                    organization.centerY = sumCenterY / nodes.length;\n                    // Create the organization -> tile members\n                    for(var i = 0; i < nodes.length; i++){\n                        var lNode = nodes[i];\n                        if (organization.rows.length == 0) {\n                            this.insertNodeToRow(organization, lNode, 0, minWidth);\n                        } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n                            var rowIndex = organization.rows.length - 1;\n                            if (!organization.idealRowWidth) {\n                                rowIndex = this.getShortestRowIndex(organization);\n                            }\n                            this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n                        } else {\n                            this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n                        }\n                        this.shiftToLastRow(organization);\n                    }\n                    return organization;\n                };\n                CoSELayout.prototype.insertNodeToRow = function(organization, node, rowIndex, minWidth) {\n                    var minCompoundSize = minWidth;\n                    // Add new row if needed\n                    if (rowIndex == organization.rows.length) {\n                        var secondDimension = [];\n                        organization.rows.push(secondDimension);\n                        organization.rowWidth.push(minCompoundSize);\n                        organization.rowHeight.push(0);\n                    }\n                    // Update row width\n                    var w = organization.rowWidth[rowIndex] + node.rect.width;\n                    if (organization.rows[rowIndex].length > 0) {\n                        w += organization.horizontalPadding;\n                    }\n                    organization.rowWidth[rowIndex] = w;\n                    // Update compound width\n                    if (organization.width < w) {\n                        organization.width = w;\n                    }\n                    // Update height\n                    var h = node.rect.height;\n                    if (rowIndex > 0) h += organization.verticalPadding;\n                    var extraHeight = 0;\n                    if (h > organization.rowHeight[rowIndex]) {\n                        extraHeight = organization.rowHeight[rowIndex];\n                        organization.rowHeight[rowIndex] = h;\n                        extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n                    }\n                    organization.height += extraHeight;\n                    // Insert node\n                    organization.rows[rowIndex].push(node);\n                };\n                //Scans the rows of an organization and returns the one with the min width\n                CoSELayout.prototype.getShortestRowIndex = function(organization) {\n                    var r = -1;\n                    var min = Number.MAX_VALUE;\n                    for(var i = 0; i < organization.rows.length; i++){\n                        if (organization.rowWidth[i] < min) {\n                            r = i;\n                            min = organization.rowWidth[i];\n                        }\n                    }\n                    return r;\n                };\n                //Scans the rows of an organization and returns the one with the max width\n                CoSELayout.prototype.getLongestRowIndex = function(organization) {\n                    var r = -1;\n                    var max = Number.MIN_VALUE;\n                    for(var i = 0; i < organization.rows.length; i++){\n                        if (organization.rowWidth[i] > max) {\n                            r = i;\n                            max = organization.rowWidth[i];\n                        }\n                    }\n                    return r;\n                };\n                /**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/ CoSELayout.prototype.canAddHorizontal = function(organization, extraWidth, extraHeight) {\n                    // if there is an ideal row width specified use it instead of checking the aspect ratio\n                    if (organization.idealRowWidth) {\n                        var lastRowIndex = organization.rows.length - 1;\n                        var lastRowWidth = organization.rowWidth[lastRowIndex];\n                        // check and return if ideal row width will be exceed if the node is added to the row\n                        return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n                    }\n                    var sri = this.getShortestRowIndex(organization);\n                    if (sri < 0) {\n                        return true;\n                    }\n                    var min = organization.rowWidth[sri];\n                    if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n                    var hDiff = 0;\n                    // Adding to an existing row\n                    if (organization.rowHeight[sri] < extraHeight) {\n                        if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n                    }\n                    var add_to_row_ratio;\n                    if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n                        add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n                    } else {\n                        add_to_row_ratio = (organization.height + hDiff) / organization.width;\n                    }\n                    // Adding a new row for this node\n                    hDiff = extraHeight + organization.verticalPadding;\n                    var add_new_row_ratio;\n                    if (organization.width < extraWidth) {\n                        add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n                    } else {\n                        add_new_row_ratio = (organization.height + hDiff) / organization.width;\n                    }\n                    if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n                    if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n                    return add_to_row_ratio < add_new_row_ratio;\n                };\n                //If moving the last node from the longest row and adding it to the last\n                //row makes the bounding box smaller, do it.\n                CoSELayout.prototype.shiftToLastRow = function(organization) {\n                    var longest = this.getLongestRowIndex(organization);\n                    var last = organization.rowWidth.length - 1;\n                    var row = organization.rows[longest];\n                    var node = row[row.length - 1];\n                    var diff = node.width + organization.horizontalPadding;\n                    // Check if there is enough space on the last row\n                    if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n                        // Remove the last element of the longest row\n                        row.splice(-1, 1);\n                        // Push it to the last row\n                        organization.rows[last].push(node);\n                        organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n                        organization.rowWidth[last] = organization.rowWidth[last] + diff;\n                        organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n                        // Update heights of the organization\n                        var maxHeight = Number.MIN_VALUE;\n                        for(var i = 0; i < row.length; i++){\n                            if (row[i].height > maxHeight) maxHeight = row[i].height;\n                        }\n                        if (longest > 0) maxHeight += organization.verticalPadding;\n                        var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                        organization.rowHeight[longest] = maxHeight;\n                        if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n                        var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                        organization.height += finalTotal - prevTotal;\n                        this.shiftToLastRow(organization);\n                    }\n                };\n                CoSELayout.prototype.tilingPreLayout = function() {\n                    if (CoSEConstants.TILE) {\n                        // Find zero degree nodes and create a compound for each level\n                        this.groupZeroDegreeMembers();\n                        // Tile and clear children of each compound\n                        this.clearCompounds();\n                        // Separately tile and clear zero degree nodes for each level\n                        this.clearZeroDegreeMembers();\n                    }\n                };\n                CoSELayout.prototype.tilingPostLayout = function() {\n                    if (CoSEConstants.TILE) {\n                        this.repopulateZeroDegreeMembers();\n                        this.repopulateCompounds();\n                    }\n                };\n                // -----------------------------------------------------------------------------\n                // Section: Tree Reduction methods\n                // -----------------------------------------------------------------------------\n                // Reduce trees \n                CoSELayout.prototype.reduceTrees = function() {\n                    var prunedNodesAll = [];\n                    var containsLeaf = true;\n                    var node;\n                    while(containsLeaf){\n                        var allNodes = this.graphManager.getAllNodes();\n                        var prunedNodesInStepTemp = [];\n                        containsLeaf = false;\n                        for(var i = 0; i < allNodes.length; i++){\n                            node = allNodes[i];\n                            if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n                                if (CoSEConstants.PURE_INCREMENTAL) {\n                                    var otherEnd = node.getEdges()[0].getOtherEnd(node);\n                                    var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n                                    prunedNodesInStepTemp.push([\n                                        node,\n                                        node.getEdges()[0],\n                                        node.getOwner(),\n                                        relativePosition\n                                    ]);\n                                } else {\n                                    prunedNodesInStepTemp.push([\n                                        node,\n                                        node.getEdges()[0],\n                                        node.getOwner()\n                                    ]);\n                                }\n                                containsLeaf = true;\n                            }\n                        }\n                        if (containsLeaf == true) {\n                            var prunedNodesInStep = [];\n                            for(var j = 0; j < prunedNodesInStepTemp.length; j++){\n                                if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                                    prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                                    prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n                                }\n                            }\n                            prunedNodesAll.push(prunedNodesInStep);\n                            this.graphManager.resetAllNodes();\n                            this.graphManager.resetAllEdges();\n                        }\n                    }\n                    this.prunedNodesAll = prunedNodesAll;\n                };\n                // Grow tree one step \n                CoSELayout.prototype.growTree = function(prunedNodesAll) {\n                    var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n                    var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n                    var nodeData;\n                    for(var i = 0; i < prunedNodesInStep.length; i++){\n                        nodeData = prunedNodesInStep[i];\n                        this.findPlaceforPrunedNode(nodeData);\n                        nodeData[2].add(nodeData[0]);\n                        nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n                    }\n                    prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n                    this.graphManager.resetAllNodes();\n                    this.graphManager.resetAllEdges();\n                };\n                // Find an appropriate position to replace pruned node, this method can be improved\n                CoSELayout.prototype.findPlaceforPrunedNode = function(nodeData) {\n                    var gridForPrunedNode;\n                    var nodeToConnect;\n                    var prunedNode = nodeData[0];\n                    if (prunedNode == nodeData[1].source) {\n                        nodeToConnect = nodeData[1].target;\n                    } else {\n                        nodeToConnect = nodeData[1].source;\n                    }\n                    if (CoSEConstants.PURE_INCREMENTAL) {\n                        prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n                    } else {\n                        var startGridX = nodeToConnect.startX;\n                        var finishGridX = nodeToConnect.finishX;\n                        var startGridY = nodeToConnect.startY;\n                        var finishGridY = nodeToConnect.finishY;\n                        var upNodeCount = 0;\n                        var downNodeCount = 0;\n                        var rightNodeCount = 0;\n                        var leftNodeCount = 0;\n                        var controlRegions = [\n                            upNodeCount,\n                            rightNodeCount,\n                            downNodeCount,\n                            leftNodeCount\n                        ];\n                        if (startGridY > 0) {\n                            for(var i = startGridX; i <= finishGridX; i++){\n                                controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n                            }\n                        }\n                        if (finishGridX < this.grid.length - 1) {\n                            for(var i = startGridY; i <= finishGridY; i++){\n                                controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n                            }\n                        }\n                        if (finishGridY < this.grid[0].length - 1) {\n                            for(var i = startGridX; i <= finishGridX; i++){\n                                controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n                            }\n                        }\n                        if (startGridX > 0) {\n                            for(var i = startGridY; i <= finishGridY; i++){\n                                controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n                            }\n                        }\n                        var min = Integer.MAX_VALUE;\n                        var minCount;\n                        var minIndex;\n                        for(var j = 0; j < controlRegions.length; j++){\n                            if (controlRegions[j] < min) {\n                                min = controlRegions[j];\n                                minCount = 1;\n                                minIndex = j;\n                            } else if (controlRegions[j] == min) {\n                                minCount++;\n                            }\n                        }\n                        if (minCount == 3 && min == 0) {\n                            if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n                                gridForPrunedNode = 1;\n                            } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n                                gridForPrunedNode = 0;\n                            } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                                gridForPrunedNode = 3;\n                            } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                                gridForPrunedNode = 2;\n                            }\n                        } else if (minCount == 2 && min == 0) {\n                            var random = Math.floor(Math.random() * 2);\n                            if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n                                ;\n                                if (random == 0) {\n                                    gridForPrunedNode = 0;\n                                } else {\n                                    gridForPrunedNode = 1;\n                                }\n                            } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n                                if (random == 0) {\n                                    gridForPrunedNode = 0;\n                                } else {\n                                    gridForPrunedNode = 2;\n                                }\n                            } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n                                if (random == 0) {\n                                    gridForPrunedNode = 0;\n                                } else {\n                                    gridForPrunedNode = 3;\n                                }\n                            } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n                                if (random == 0) {\n                                    gridForPrunedNode = 1;\n                                } else {\n                                    gridForPrunedNode = 2;\n                                }\n                            } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n                                if (random == 0) {\n                                    gridForPrunedNode = 1;\n                                } else {\n                                    gridForPrunedNode = 3;\n                                }\n                            } else {\n                                if (random == 0) {\n                                    gridForPrunedNode = 2;\n                                } else {\n                                    gridForPrunedNode = 3;\n                                }\n                            }\n                        } else if (minCount == 4 && min == 0) {\n                            var random = Math.floor(Math.random() * 4);\n                            gridForPrunedNode = random;\n                        } else {\n                            gridForPrunedNode = minIndex;\n                        }\n                        if (gridForPrunedNode == 0) {\n                            prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n                        } else if (gridForPrunedNode == 1) {\n                            prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                        } else if (gridForPrunedNode == 2) {\n                            prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n                        } else {\n                            prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                        }\n                    }\n                };\n                module1.exports = CoSELayout;\n            /***/ },\n            /***/ 991: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_109971__)=>{\n                var FDLayoutNode = __nested_webpack_require_109971__(551).FDLayoutNode;\n                var IMath = __nested_webpack_require_109971__(551).IMath;\n                function CoSENode(gm, loc, size, vNode) {\n                    FDLayoutNode.call(this, gm, loc, size, vNode);\n                }\n                CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n                for(var prop in FDLayoutNode){\n                    CoSENode[prop] = FDLayoutNode[prop];\n                }\n                CoSENode.prototype.calculateDisplacement = function() {\n                    var layout = this.graphManager.getLayout();\n                    // this check is for compound nodes that contain fixed nodes\n                    if (this.getChild() != null && this.fixedNodeWeight) {\n                        this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n                        this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n                    } else {\n                        this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n                        this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n                    }\n                    if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                        this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n                    }\n                    if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                        this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n                    }\n                    // non-empty compound node, propogate movement to children as well\n                    if (this.child && this.child.getNodes().length > 0) {\n                        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n                    }\n                };\n                CoSENode.prototype.propogateDisplacementToChildren = function(dX, dY) {\n                    var nodes = this.getChild().getNodes();\n                    var node;\n                    for(var i = 0; i < nodes.length; i++){\n                        node = nodes[i];\n                        if (node.getChild() == null) {\n                            node.displacementX += dX;\n                            node.displacementY += dY;\n                        } else {\n                            node.propogateDisplacementToChildren(dX, dY);\n                        }\n                    }\n                };\n                CoSENode.prototype.move = function() {\n                    var layout = this.graphManager.getLayout();\n                    // a simple node or an empty compound node, move it\n                    if (this.child == null || this.child.getNodes().length == 0) {\n                        this.moveBy(this.displacementX, this.displacementY);\n                        layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n                    }\n                    this.springForceX = 0;\n                    this.springForceY = 0;\n                    this.repulsionForceX = 0;\n                    this.repulsionForceY = 0;\n                    this.gravitationForceX = 0;\n                    this.gravitationForceY = 0;\n                    this.displacementX = 0;\n                    this.displacementY = 0;\n                };\n                CoSENode.prototype.setPred1 = function(pred11) {\n                    this.pred1 = pred11;\n                };\n                CoSENode.prototype.getPred1 = function() {\n                    return pred1;\n                };\n                CoSENode.prototype.getPred2 = function() {\n                    return pred2;\n                };\n                CoSENode.prototype.setNext = function(next1) {\n                    this.next = next1;\n                };\n                CoSENode.prototype.getNext = function() {\n                    return next;\n                };\n                CoSENode.prototype.setProcessed = function(processed1) {\n                    this.processed = processed1;\n                };\n                CoSENode.prototype.isProcessed = function() {\n                    return processed;\n                };\n                module1.exports = CoSENode;\n            /***/ },\n            /***/ 902: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_114725__)=>{\n                function _toConsumableArray(arr) {\n                    if (Array.isArray(arr)) {\n                        for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                            arr2[i] = arr[i];\n                        }\n                        return arr2;\n                    } else {\n                        return Array.from(arr);\n                    }\n                }\n                var CoSEConstants = __nested_webpack_require_114725__(806);\n                var LinkedList = __nested_webpack_require_114725__(551).LinkedList;\n                var Matrix = __nested_webpack_require_114725__(551).Matrix;\n                var SVD = __nested_webpack_require_114725__(551).SVD;\n                function ConstraintHandler() {}\n                ConstraintHandler.handleConstraints = function(layout) {\n                    //  let layout = this.graphManager.getLayout();\n                    // get constraints from layout\n                    var constraints = {};\n                    constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n                    constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n                    constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n                    var idToNodeMap = new Map();\n                    var nodeIndexes = new Map();\n                    var xCoords = [];\n                    var yCoords = [];\n                    var allNodes = layout.getAllNodes();\n                    var index = 0;\n                    // fill index map and coordinates\n                    for(var i = 0; i < allNodes.length; i++){\n                        var node = allNodes[i];\n                        if (node.getChild() == null) {\n                            nodeIndexes.set(node.id, index++);\n                            xCoords.push(node.getCenterX());\n                            yCoords.push(node.getCenterY());\n                            idToNodeMap.set(node.id, node);\n                        }\n                    }\n                    // if there exists relative placement constraint without gap value, set it to default \n                    if (constraints.relativePlacementConstraint) {\n                        constraints.relativePlacementConstraint.forEach(function(constraint) {\n                            if (!constraint.gap && constraint.gap != 0) {\n                                if (constraint.left) {\n                                    constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n                                } else {\n                                    constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n                                }\n                            }\n                        });\n                    }\n                    /* auxiliary functions */ // calculate difference between two position objects\n                    var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n                        return {\n                            x: pos1.x - pos2.x,\n                            y: pos1.y - pos2.y\n                        };\n                    };\n                    // calculate average position of the nodes\n                    var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n                        var xPosSum = 0;\n                        var yPosSum = 0;\n                        nodeIdSet.forEach(function(nodeId) {\n                            xPosSum += xCoords[nodeIndexes.get(nodeId)];\n                            yPosSum += yCoords[nodeIndexes.get(nodeId)];\n                        });\n                        return {\n                            x: xPosSum / nodeIdSet.size,\n                            y: yPosSum / nodeIdSet.size\n                        };\n                    };\n                    // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n                    // this function also takes the fixed nodes and alignment constraints into account\n                    // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n                    // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n                    var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n                        // find union of two sets\n                        function setUnion(setA, setB) {\n                            var union = new Set(setA);\n                            var _iteratorNormalCompletion = true;\n                            var _didIteratorError = false;\n                            var _iteratorError = undefined;\n                            try {\n                                for(var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                                    var elem = _step.value;\n                                    union.add(elem);\n                                }\n                            } catch (err) {\n                                _didIteratorError = true;\n                                _iteratorError = err;\n                            } finally{\n                                try {\n                                    if (!_iteratorNormalCompletion && _iterator.return) {\n                                        _iterator.return();\n                                    }\n                                } finally{\n                                    if (_didIteratorError) {\n                                        throw _iteratorError;\n                                    }\n                                }\n                            }\n                            return union;\n                        }\n                        // find indegree count for each node\n                        var inDegrees = new Map();\n                        graph.forEach(function(value, key) {\n                            inDegrees.set(key, 0);\n                        });\n                        graph.forEach(function(value, key) {\n                            value.forEach(function(adjacent) {\n                                inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n                            });\n                        });\n                        var positionMap = new Map(); // keeps the position for each node\n                        var pastMap = new Map(); // keeps the predecessors(past) of a node\n                        var queue = new LinkedList();\n                        inDegrees.forEach(function(value, key) {\n                            if (value == 0) {\n                                queue.push(key);\n                                if (!fixedNodes) {\n                                    if (direction == \"horizontal\") {\n                                        positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                                    } else {\n                                        positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                                    }\n                                }\n                            } else {\n                                positionMap.set(key, Number.NEGATIVE_INFINITY);\n                            }\n                            if (fixedNodes) {\n                                pastMap.set(key, new Set([\n                                    key\n                                ]));\n                            }\n                        });\n                        // align sources of each component in enforcement phase\n                        if (fixedNodes) {\n                            componentSources.forEach(function(component) {\n                                var fixedIds = [];\n                                component.forEach(function(nodeId) {\n                                    if (fixedNodes.has(nodeId)) {\n                                        fixedIds.push(nodeId);\n                                    }\n                                });\n                                if (fixedIds.length > 0) {\n                                    var position = 0;\n                                    fixedIds.forEach(function(fixedId) {\n                                        if (direction == \"horizontal\") {\n                                            positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                                            position += positionMap.get(fixedId);\n                                        } else {\n                                            positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                                            position += positionMap.get(fixedId);\n                                        }\n                                    });\n                                    position = position / fixedIds.length;\n                                    component.forEach(function(nodeId) {\n                                        if (!fixedNodes.has(nodeId)) {\n                                            positionMap.set(nodeId, position);\n                                        }\n                                    });\n                                } else {\n                                    var _position = 0;\n                                    component.forEach(function(nodeId) {\n                                        if (direction == \"horizontal\") {\n                                            _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                                        } else {\n                                            _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                                        }\n                                    });\n                                    _position = _position / component.length;\n                                    component.forEach(function(nodeId) {\n                                        positionMap.set(nodeId, _position);\n                                    });\n                                }\n                            });\n                        }\n                        // calculate positions of the nodes\n                        var _loop = function _loop() {\n                            var currentNode = queue.shift();\n                            var neighbors = graph.get(currentNode);\n                            neighbors.forEach(function(neighbor) {\n                                if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n                                    if (fixedNodes && fixedNodes.has(neighbor.id)) {\n                                        var fixedPosition = void 0;\n                                        if (direction == \"horizontal\") {\n                                            fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                                        } else {\n                                            fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                                        }\n                                        positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n                                        if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n                                            var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n                                            pastMap.get(currentNode).forEach(function(nodeId) {\n                                                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n                                            });\n                                        }\n                                    } else {\n                                        positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n                                    }\n                                }\n                                inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n                                if (inDegrees.get(neighbor.id) == 0) {\n                                    queue.push(neighbor.id);\n                                }\n                                if (fixedNodes) {\n                                    pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n                                }\n                            });\n                        };\n                        while(queue.length != 0){\n                            _loop();\n                        }\n                        // readjust position of the nodes after enforcement\n                        if (fixedNodes) {\n                            // find indegree count for each node\n                            var sinkNodes = new Set();\n                            graph.forEach(function(value, key) {\n                                if (value.length == 0) {\n                                    sinkNodes.add(key);\n                                }\n                            });\n                            var _components = [];\n                            pastMap.forEach(function(value, key) {\n                                if (sinkNodes.has(key)) {\n                                    var isFixedComponent = false;\n                                    var _iteratorNormalCompletion2 = true;\n                                    var _didIteratorError2 = false;\n                                    var _iteratorError2 = undefined;\n                                    try {\n                                        for(var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                                            var nodeId = _step2.value;\n                                            if (fixedNodes.has(nodeId)) {\n                                                isFixedComponent = true;\n                                            }\n                                        }\n                                    } catch (err) {\n                                        _didIteratorError2 = true;\n                                        _iteratorError2 = err;\n                                    } finally{\n                                        try {\n                                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                                _iterator2.return();\n                                            }\n                                        } finally{\n                                            if (_didIteratorError2) {\n                                                throw _iteratorError2;\n                                            }\n                                        }\n                                    }\n                                    if (!isFixedComponent) {\n                                        var isExist = false;\n                                        var existAt = void 0;\n                                        _components.forEach(function(component, index) {\n                                            if (component.has([].concat(_toConsumableArray(value))[0])) {\n                                                isExist = true;\n                                                existAt = index;\n                                            }\n                                        });\n                                        if (!isExist) {\n                                            _components.push(new Set(value));\n                                        } else {\n                                            value.forEach(function(ele) {\n                                                _components[existAt].add(ele);\n                                            });\n                                        }\n                                    }\n                                }\n                            });\n                            _components.forEach(function(component, index) {\n                                var minBefore = Number.POSITIVE_INFINITY;\n                                var minAfter = Number.POSITIVE_INFINITY;\n                                var maxBefore = Number.NEGATIVE_INFINITY;\n                                var maxAfter = Number.NEGATIVE_INFINITY;\n                                var _iteratorNormalCompletion3 = true;\n                                var _didIteratorError3 = false;\n                                var _iteratorError3 = undefined;\n                                try {\n                                    for(var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n                                        var nodeId = _step3.value;\n                                        var posBefore = void 0;\n                                        if (direction == \"horizontal\") {\n                                            posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                                        } else {\n                                            posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                                        }\n                                        var posAfter = positionMap.get(nodeId);\n                                        if (posBefore < minBefore) {\n                                            minBefore = posBefore;\n                                        }\n                                        if (posBefore > maxBefore) {\n                                            maxBefore = posBefore;\n                                        }\n                                        if (posAfter < minAfter) {\n                                            minAfter = posAfter;\n                                        }\n                                        if (posAfter > maxAfter) {\n                                            maxAfter = posAfter;\n                                        }\n                                    }\n                                } catch (err) {\n                                    _didIteratorError3 = true;\n                                    _iteratorError3 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                            _iterator3.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError3) {\n                                            throw _iteratorError3;\n                                        }\n                                    }\n                                }\n                                var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n                                var _iteratorNormalCompletion4 = true;\n                                var _didIteratorError4 = false;\n                                var _iteratorError4 = undefined;\n                                try {\n                                    for(var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true){\n                                        var _nodeId = _step4.value;\n                                        positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n                                    }\n                                } catch (err) {\n                                    _didIteratorError4 = true;\n                                    _iteratorError4 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                            _iterator4.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError4) {\n                                            throw _iteratorError4;\n                                        }\n                                    }\n                                }\n                            });\n                        }\n                        return positionMap;\n                    };\n                    // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n                    // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n                    var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n                        // variables to count votes\n                        var reflectOnY = 0, notReflectOnY = 0;\n                        var reflectOnX = 0, notReflectOnX = 0;\n                        relativePlacementConstraints.forEach(function(constraint) {\n                            if (constraint.left) {\n                                xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n                            } else {\n                                yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n                            }\n                        });\n                        if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n                            for(var _i = 0; _i < nodeIndexes.size; _i++){\n                                xCoords[_i] = -1 * xCoords[_i];\n                                yCoords[_i] = -1 * yCoords[_i];\n                            }\n                        } else if (reflectOnY > notReflectOnY) {\n                            for(var _i2 = 0; _i2 < nodeIndexes.size; _i2++){\n                                xCoords[_i2] = -1 * xCoords[_i2];\n                            }\n                        } else if (reflectOnX > notReflectOnX) {\n                            for(var _i3 = 0; _i3 < nodeIndexes.size; _i3++){\n                                yCoords[_i3] = -1 * yCoords[_i3];\n                            }\n                        }\n                    };\n                    // find weakly connected components in undirected graph\n                    var findComponents = function findComponents(graph) {\n                        // find weakly connected components in dag\n                        var components = [];\n                        var queue = new LinkedList();\n                        var visited = new Set();\n                        var count = 0;\n                        graph.forEach(function(value, key) {\n                            if (!visited.has(key)) {\n                                components[count] = [];\n                                var _currentNode = key;\n                                queue.push(_currentNode);\n                                visited.add(_currentNode);\n                                components[count].push(_currentNode);\n                                while(queue.length != 0){\n                                    _currentNode = queue.shift();\n                                    var neighbors = graph.get(_currentNode);\n                                    neighbors.forEach(function(neighbor) {\n                                        if (!visited.has(neighbor.id)) {\n                                            queue.push(neighbor.id);\n                                            visited.add(neighbor.id);\n                                            components[count].push(neighbor.id);\n                                        }\n                                    });\n                                }\n                                count++;\n                            }\n                        });\n                        return components;\n                    };\n                    // return undirected version of given dag\n                    var dagToUndirected = function dagToUndirected(dag) {\n                        var undirected = new Map();\n                        dag.forEach(function(value, key) {\n                            undirected.set(key, []);\n                        });\n                        dag.forEach(function(value, key) {\n                            value.forEach(function(adjacent) {\n                                undirected.get(key).push(adjacent);\n                                undirected.get(adjacent.id).push({\n                                    id: key,\n                                    gap: adjacent.gap,\n                                    direction: adjacent.direction\n                                });\n                            });\n                        });\n                        return undirected;\n                    };\n                    // return reversed (directions inverted) version of given dag\n                    var dagToReversed = function dagToReversed(dag) {\n                        var reversed = new Map();\n                        dag.forEach(function(value, key) {\n                            reversed.set(key, []);\n                        });\n                        dag.forEach(function(value, key) {\n                            value.forEach(function(adjacent) {\n                                reversed.get(adjacent.id).push({\n                                    id: key,\n                                    gap: adjacent.gap,\n                                    direction: adjacent.direction\n                                });\n                            });\n                        });\n                        return reversed;\n                    };\n                    /****  apply transformation to the initial draft layout to better align with constrained nodes ****/ // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n                    // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n                    /* construct source and target configurations */ var targetMatrix = []; // A - target configuration\n                    var sourceMatrix = []; // B - source configuration \n                    var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n                    var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n                    var fixedNodes = new Set();\n                    var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n                    var dagUndirected = new Map(); // undirected version of the dag\n                    var components = []; // weakly connected components\n                    // fill fixedNodes collection to use later\n                    if (constraints.fixedNodeConstraint) {\n                        constraints.fixedNodeConstraint.forEach(function(nodeData) {\n                            fixedNodes.add(nodeData.nodeId);\n                        });\n                    }\n                    // construct dag from relative placement constraints \n                    if (constraints.relativePlacementConstraint) {\n                        // construct both directed and undirected version of the dag\n                        constraints.relativePlacementConstraint.forEach(function(constraint) {\n                            if (constraint.left) {\n                                if (dag.has(constraint.left)) {\n                                    dag.get(constraint.left).push({\n                                        id: constraint.right,\n                                        gap: constraint.gap,\n                                        direction: \"horizontal\"\n                                    });\n                                } else {\n                                    dag.set(constraint.left, [\n                                        {\n                                            id: constraint.right,\n                                            gap: constraint.gap,\n                                            direction: \"horizontal\"\n                                        }\n                                    ]);\n                                }\n                                if (!dag.has(constraint.right)) {\n                                    dag.set(constraint.right, []);\n                                }\n                            } else {\n                                if (dag.has(constraint.top)) {\n                                    dag.get(constraint.top).push({\n                                        id: constraint.bottom,\n                                        gap: constraint.gap,\n                                        direction: \"vertical\"\n                                    });\n                                } else {\n                                    dag.set(constraint.top, [\n                                        {\n                                            id: constraint.bottom,\n                                            gap: constraint.gap,\n                                            direction: \"vertical\"\n                                        }\n                                    ]);\n                                }\n                                if (!dag.has(constraint.bottom)) {\n                                    dag.set(constraint.bottom, []);\n                                }\n                            }\n                        });\n                        dagUndirected = dagToUndirected(dag);\n                        components = findComponents(dagUndirected);\n                    }\n                    if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n                        // first check fixed node constraint\n                        if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n                            constraints.fixedNodeConstraint.forEach(function(nodeData, i) {\n                                targetMatrix[i] = [\n                                    nodeData.position.x,\n                                    nodeData.position.y\n                                ];\n                                sourceMatrix[i] = [\n                                    xCoords[nodeIndexes.get(nodeData.nodeId)],\n                                    yCoords[nodeIndexes.get(nodeData.nodeId)]\n                                ];\n                            });\n                            standardTransformation = true;\n                        } else if (constraints.alignmentConstraint) {\n                            (function() {\n                                // then check alignment constraint\n                                var count = 0;\n                                if (constraints.alignmentConstraint.vertical) {\n                                    var verticalAlign = constraints.alignmentConstraint.vertical;\n                                    var _loop2 = function _loop2(_i4) {\n                                        var alignmentSet = new Set();\n                                        verticalAlign[_i4].forEach(function(nodeId) {\n                                            alignmentSet.add(nodeId);\n                                        });\n                                        var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                                            return fixedNodes.has(x);\n                                        }));\n                                        var xPos = void 0;\n                                        if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                                        else xPos = calculateAvgPosition(alignmentSet).x;\n                                        verticalAlign[_i4].forEach(function(nodeId) {\n                                            targetMatrix[count] = [\n                                                xPos,\n                                                yCoords[nodeIndexes.get(nodeId)]\n                                            ];\n                                            sourceMatrix[count] = [\n                                                xCoords[nodeIndexes.get(nodeId)],\n                                                yCoords[nodeIndexes.get(nodeId)]\n                                            ];\n                                            count++;\n                                        });\n                                    };\n                                    for(var _i4 = 0; _i4 < verticalAlign.length; _i4++){\n                                        _loop2(_i4);\n                                    }\n                                    standardTransformation = true;\n                                }\n                                if (constraints.alignmentConstraint.horizontal) {\n                                    var horizontalAlign = constraints.alignmentConstraint.horizontal;\n                                    var _loop3 = function _loop3(_i5) {\n                                        var alignmentSet = new Set();\n                                        horizontalAlign[_i5].forEach(function(nodeId) {\n                                            alignmentSet.add(nodeId);\n                                        });\n                                        var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                                            return fixedNodes.has(x);\n                                        }));\n                                        var yPos = void 0;\n                                        if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                                        else yPos = calculateAvgPosition(alignmentSet).y;\n                                        horizontalAlign[_i5].forEach(function(nodeId) {\n                                            targetMatrix[count] = [\n                                                xCoords[nodeIndexes.get(nodeId)],\n                                                yPos\n                                            ];\n                                            sourceMatrix[count] = [\n                                                xCoords[nodeIndexes.get(nodeId)],\n                                                yCoords[nodeIndexes.get(nodeId)]\n                                            ];\n                                            count++;\n                                        });\n                                    };\n                                    for(var _i5 = 0; _i5 < horizontalAlign.length; _i5++){\n                                        _loop3(_i5);\n                                    }\n                                    standardTransformation = true;\n                                }\n                                if (constraints.relativePlacementConstraint) {\n                                    reflectionType = true;\n                                }\n                            })();\n                        } else if (constraints.relativePlacementConstraint) {\n                            // finally check relative placement constraint\n                            // find largest component in dag\n                            var largestComponentSize = 0;\n                            var largestComponentIndex = 0;\n                            for(var _i6 = 0; _i6 < components.length; _i6++){\n                                if (components[_i6].length > largestComponentSize) {\n                                    largestComponentSize = components[_i6].length;\n                                    largestComponentIndex = _i6;\n                                }\n                            }\n                            // if largest component isn't dominant, then take the votes for reflection\n                            if (largestComponentSize < dagUndirected.size / 2) {\n                                applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                                standardTransformation = false;\n                                reflectionType = false;\n                            } else {\n                                // use largest component for transformation\n                                // construct horizontal and vertical subgraphs in the largest component\n                                var subGraphOnHorizontal = new Map();\n                                var subGraphOnVertical = new Map();\n                                var constraintsInlargestComponent = [];\n                                components[largestComponentIndex].forEach(function(nodeId) {\n                                    dag.get(nodeId).forEach(function(adjacent) {\n                                        if (adjacent.direction == \"horizontal\") {\n                                            if (subGraphOnHorizontal.has(nodeId)) {\n                                                subGraphOnHorizontal.get(nodeId).push(adjacent);\n                                            } else {\n                                                subGraphOnHorizontal.set(nodeId, [\n                                                    adjacent\n                                                ]);\n                                            }\n                                            if (!subGraphOnHorizontal.has(adjacent.id)) {\n                                                subGraphOnHorizontal.set(adjacent.id, []);\n                                            }\n                                            constraintsInlargestComponent.push({\n                                                left: nodeId,\n                                                right: adjacent.id\n                                            });\n                                        } else {\n                                            if (subGraphOnVertical.has(nodeId)) {\n                                                subGraphOnVertical.get(nodeId).push(adjacent);\n                                            } else {\n                                                subGraphOnVertical.set(nodeId, [\n                                                    adjacent\n                                                ]);\n                                            }\n                                            if (!subGraphOnVertical.has(adjacent.id)) {\n                                                subGraphOnVertical.set(adjacent.id, []);\n                                            }\n                                            constraintsInlargestComponent.push({\n                                                top: nodeId,\n                                                bottom: adjacent.id\n                                            });\n                                        }\n                                    });\n                                });\n                                applyReflectionForRelativePlacement(constraintsInlargestComponent);\n                                reflectionType = false;\n                                // calculate appropriate positioning for subgraphs\n                                var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n                                var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n                                // construct source and target configuration\n                                components[largestComponentIndex].forEach(function(nodeId, i) {\n                                    sourceMatrix[i] = [\n                                        xCoords[nodeIndexes.get(nodeId)],\n                                        yCoords[nodeIndexes.get(nodeId)]\n                                    ];\n                                    targetMatrix[i] = [];\n                                    if (positionMapHorizontal.has(nodeId)) {\n                                        targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n                                    } else {\n                                        targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n                                    }\n                                    if (positionMapVertical.has(nodeId)) {\n                                        targetMatrix[i][1] = positionMapVertical.get(nodeId);\n                                    } else {\n                                        targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n                                    }\n                                });\n                                standardTransformation = true;\n                            }\n                        }\n                        // if transformation is required, then calculate and apply transformation matrix\n                        if (standardTransformation) {\n                            /* calculate transformation matrix */ var transformationMatrix = void 0;\n                            var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n                            var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n                            // centralize transpose matrices\n                            for(var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++){\n                                targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n                                sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n                            }\n                            // do actual calculation for transformation matrix\n                            var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n                            var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n                            transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n                            /* apply found transformation matrix to obtain final draft layout */ for(var _i8 = 0; _i8 < nodeIndexes.size; _i8++){\n                                var temp1 = [\n                                    xCoords[_i8],\n                                    yCoords[_i8]\n                                ];\n                                var temp2 = [\n                                    transformationMatrix[0][0],\n                                    transformationMatrix[1][0]\n                                ];\n                                var temp3 = [\n                                    transformationMatrix[0][1],\n                                    transformationMatrix[1][1]\n                                ];\n                                xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n                                yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n                            }\n                            // applied only both alignment and rel. placement constraints exist\n                            if (reflectionType) {\n                                applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                            }\n                        }\n                    }\n                    if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n                        /****  enforce constraints on the transformed draft layout ****/ /* first enforce fixed node constraint */ if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n                            var translationAmount = {\n                                x: 0,\n                                y: 0\n                            };\n                            constraints.fixedNodeConstraint.forEach(function(nodeData, i) {\n                                var posInTheory = {\n                                    x: xCoords[nodeIndexes.get(nodeData.nodeId)],\n                                    y: yCoords[nodeIndexes.get(nodeData.nodeId)]\n                                };\n                                var posDesired = nodeData.position;\n                                var posDiff = calculatePositionDiff(posDesired, posInTheory);\n                                translationAmount.x += posDiff.x;\n                                translationAmount.y += posDiff.y;\n                            });\n                            translationAmount.x /= constraints.fixedNodeConstraint.length;\n                            translationAmount.y /= constraints.fixedNodeConstraint.length;\n                            xCoords.forEach(function(value, i) {\n                                xCoords[i] += translationAmount.x;\n                            });\n                            yCoords.forEach(function(value, i) {\n                                yCoords[i] += translationAmount.y;\n                            });\n                            constraints.fixedNodeConstraint.forEach(function(nodeData) {\n                                xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n                                yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n                            });\n                        }\n                        /* then enforce alignment constraint */ if (constraints.alignmentConstraint) {\n                            if (constraints.alignmentConstraint.vertical) {\n                                var xAlign = constraints.alignmentConstraint.vertical;\n                                var _loop4 = function _loop4(_i9) {\n                                    var alignmentSet = new Set();\n                                    xAlign[_i9].forEach(function(nodeId) {\n                                        alignmentSet.add(nodeId);\n                                    });\n                                    var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                                        return fixedNodes.has(x);\n                                    }));\n                                    var xPos = void 0;\n                                    if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                                    else xPos = calculateAvgPosition(alignmentSet).x;\n                                    alignmentSet.forEach(function(nodeId) {\n                                        if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n                                    });\n                                };\n                                for(var _i9 = 0; _i9 < xAlign.length; _i9++){\n                                    _loop4(_i9);\n                                }\n                            }\n                            if (constraints.alignmentConstraint.horizontal) {\n                                var yAlign = constraints.alignmentConstraint.horizontal;\n                                var _loop5 = function _loop5(_i10) {\n                                    var alignmentSet = new Set();\n                                    yAlign[_i10].forEach(function(nodeId) {\n                                        alignmentSet.add(nodeId);\n                                    });\n                                    var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                                        return fixedNodes.has(x);\n                                    }));\n                                    var yPos = void 0;\n                                    if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];\n                                    else yPos = calculateAvgPosition(alignmentSet).y;\n                                    alignmentSet.forEach(function(nodeId) {\n                                        if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n                                    });\n                                };\n                                for(var _i10 = 0; _i10 < yAlign.length; _i10++){\n                                    _loop5(_i10);\n                                }\n                            }\n                        }\n                        /* finally enforce relative placement constraint */ if (constraints.relativePlacementConstraint) {\n                            (function() {\n                                var nodeToDummyForVerticalAlignment = new Map();\n                                var nodeToDummyForHorizontalAlignment = new Map();\n                                var dummyToNodeForVerticalAlignment = new Map();\n                                var dummyToNodeForHorizontalAlignment = new Map();\n                                var dummyPositionsForVerticalAlignment = new Map();\n                                var dummyPositionsForHorizontalAlignment = new Map();\n                                var fixedNodesOnHorizontal = new Set();\n                                var fixedNodesOnVertical = new Set();\n                                // fill maps and sets      \n                                fixedNodes.forEach(function(nodeId) {\n                                    fixedNodesOnHorizontal.add(nodeId);\n                                    fixedNodesOnVertical.add(nodeId);\n                                });\n                                if (constraints.alignmentConstraint) {\n                                    if (constraints.alignmentConstraint.vertical) {\n                                        var verticalAlignment = constraints.alignmentConstraint.vertical;\n                                        var _loop6 = function _loop6(_i11) {\n                                            dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n                                            verticalAlignment[_i11].forEach(function(nodeId) {\n                                                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                                                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                                                if (fixedNodes.has(nodeId)) {\n                                                    fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                                                }\n                                            });\n                                            dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n                                        };\n                                        for(var _i11 = 0; _i11 < verticalAlignment.length; _i11++){\n                                            _loop6(_i11);\n                                        }\n                                    }\n                                    if (constraints.alignmentConstraint.horizontal) {\n                                        var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n                                        var _loop7 = function _loop7(_i12) {\n                                            dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n                                            horizontalAlignment[_i12].forEach(function(nodeId) {\n                                                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                                                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                                                if (fixedNodes.has(nodeId)) {\n                                                    fixedNodesOnVertical.add(\"dummy\" + _i12);\n                                                }\n                                            });\n                                            dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n                                        };\n                                        for(var _i12 = 0; _i12 < horizontalAlignment.length; _i12++){\n                                            _loop7(_i12);\n                                        }\n                                    }\n                                }\n                                // construct horizontal and vertical dags (subgraphs) from overall dag\n                                var dagOnHorizontal = new Map();\n                                var dagOnVertical = new Map();\n                                var _loop8 = function _loop8(nodeId) {\n                                    dag.get(nodeId).forEach(function(adjacent) {\n                                        var sourceId = void 0;\n                                        var targetNode = void 0;\n                                        if (adjacent[\"direction\"] == \"horizontal\") {\n                                            sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n                                            if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                                                targetNode = {\n                                                    id: nodeToDummyForVerticalAlignment.get(adjacent.id),\n                                                    gap: adjacent.gap,\n                                                    direction: adjacent.direction\n                                                };\n                                            } else {\n                                                targetNode = adjacent;\n                                            }\n                                            if (dagOnHorizontal.has(sourceId)) {\n                                                dagOnHorizontal.get(sourceId).push(targetNode);\n                                            } else {\n                                                dagOnHorizontal.set(sourceId, [\n                                                    targetNode\n                                                ]);\n                                            }\n                                            if (!dagOnHorizontal.has(targetNode.id)) {\n                                                dagOnHorizontal.set(targetNode.id, []);\n                                            }\n                                        } else {\n                                            sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n                                            if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                                                targetNode = {\n                                                    id: nodeToDummyForHorizontalAlignment.get(adjacent.id),\n                                                    gap: adjacent.gap,\n                                                    direction: adjacent.direction\n                                                };\n                                            } else {\n                                                targetNode = adjacent;\n                                            }\n                                            if (dagOnVertical.has(sourceId)) {\n                                                dagOnVertical.get(sourceId).push(targetNode);\n                                            } else {\n                                                dagOnVertical.set(sourceId, [\n                                                    targetNode\n                                                ]);\n                                            }\n                                            if (!dagOnVertical.has(targetNode.id)) {\n                                                dagOnVertical.set(targetNode.id, []);\n                                            }\n                                        }\n                                    });\n                                };\n                                var _iteratorNormalCompletion5 = true;\n                                var _didIteratorError5 = false;\n                                var _iteratorError5 = undefined;\n                                try {\n                                    for(var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true){\n                                        var nodeId = _step5.value;\n                                        _loop8(nodeId);\n                                    }\n                                // find source nodes of each component in horizontal and vertical dags\n                                } catch (err) {\n                                    _didIteratorError5 = true;\n                                    _iteratorError5 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                            _iterator5.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError5) {\n                                            throw _iteratorError5;\n                                        }\n                                    }\n                                }\n                                var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n                                var undirectedOnVertical = dagToUndirected(dagOnVertical);\n                                var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n                                var componentsOnVertical = findComponents(undirectedOnVertical);\n                                var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n                                var reversedDagOnVertical = dagToReversed(dagOnVertical);\n                                var componentSourcesOnHorizontal = [];\n                                var componentSourcesOnVertical = [];\n                                componentsOnHorizontal.forEach(function(component, index) {\n                                    componentSourcesOnHorizontal[index] = [];\n                                    component.forEach(function(nodeId) {\n                                        if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n                                            componentSourcesOnHorizontal[index].push(nodeId);\n                                        }\n                                    });\n                                });\n                                componentsOnVertical.forEach(function(component, index) {\n                                    componentSourcesOnVertical[index] = [];\n                                    component.forEach(function(nodeId) {\n                                        if (reversedDagOnVertical.get(nodeId).length == 0) {\n                                            componentSourcesOnVertical[index].push(nodeId);\n                                        }\n                                    });\n                                });\n                                // calculate appropriate positioning for subgraphs\n                                var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n                                var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n                                // update positions of the nodes based on relative placement constraints\n                                var _loop9 = function _loop9(key) {\n                                    if (dummyToNodeForVerticalAlignment.get(key)) {\n                                        dummyToNodeForVerticalAlignment.get(key).forEach(function(nodeId) {\n                                            xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n                                        });\n                                    } else {\n                                        xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n                                    }\n                                };\n                                var _iteratorNormalCompletion6 = true;\n                                var _didIteratorError6 = false;\n                                var _iteratorError6 = undefined;\n                                try {\n                                    for(var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true){\n                                        var key = _step6.value;\n                                        _loop9(key);\n                                    }\n                                } catch (err) {\n                                    _didIteratorError6 = true;\n                                    _iteratorError6 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                            _iterator6.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError6) {\n                                            throw _iteratorError6;\n                                        }\n                                    }\n                                }\n                                var _loop10 = function _loop10(key) {\n                                    if (dummyToNodeForHorizontalAlignment.get(key)) {\n                                        dummyToNodeForHorizontalAlignment.get(key).forEach(function(nodeId) {\n                                            yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n                                        });\n                                    } else {\n                                        yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n                                    }\n                                };\n                                var _iteratorNormalCompletion7 = true;\n                                var _didIteratorError7 = false;\n                                var _iteratorError7 = undefined;\n                                try {\n                                    for(var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true){\n                                        var key = _step7.value;\n                                        _loop10(key);\n                                    }\n                                } catch (err) {\n                                    _didIteratorError7 = true;\n                                    _iteratorError7 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                            _iterator7.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError7) {\n                                            throw _iteratorError7;\n                                        }\n                                    }\n                                }\n                            })();\n                        }\n                    }\n                    // assign new coordinates to nodes after constraint handling\n                    for(var _i13 = 0; _i13 < allNodes.length; _i13++){\n                        var _node = allNodes[_i13];\n                        if (_node.getChild() == null) {\n                            _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n                        }\n                    }\n                };\n                module1.exports = ConstraintHandler;\n            /***/ },\n            /***/ 551: /***/ (module1)=>{\n                module1.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_181000__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __nested_webpack_require_181000__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_181000__(45);\n        /******/ /******/ return __nested_webpack_exports__;\n    /******/ })();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFDLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsaUdBQWE7U0FDMUMsRUFLMkM7QUFDakQsR0FBRyxJQUFJLEVBQUUsU0FBU0csZ0NBQWdDO0lBQ2xELE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUksSUFBSUMsc0JBQXVCO1lBRXJDLEdBQUcsR0FBRyxJQUNOLEdBQUcsR0FBSSxDQUFDTCxTQUFRTSwwQkFBMEJDLDhCQUFtQkE7Z0JBSTdELElBQUlDLFdBQVcsQ0FBQztnQkFFaEJBLFNBQVNDLFVBQVUsR0FBR0YsOEJBQW1CQSxDQUFDO2dCQUMxQ0MsU0FBU0UsYUFBYSxHQUFHSCw4QkFBbUJBLENBQUM7Z0JBQzdDQyxTQUFTRyxRQUFRLEdBQUdKLDhCQUFtQkEsQ0FBQztnQkFDeENDLFNBQVNJLFNBQVMsR0FBR0wsOEJBQW1CQSxDQUFDO2dCQUN6Q0MsU0FBU0ssZ0JBQWdCLEdBQUdOLDhCQUFtQkEsQ0FBQztnQkFDaERDLFNBQVNNLFVBQVUsR0FBR1AsOEJBQW1CQSxDQUFDO2dCQUMxQ0MsU0FBU08sUUFBUSxHQUFHUiw4QkFBbUJBLENBQUM7Z0JBQ3hDQyxTQUFTUSxpQkFBaUIsR0FBR1QsOEJBQW1CQSxDQUFDO2dCQUVqRFAsUUFBT0QsT0FBTyxHQUFHUztZQUVqQixHQUFHLEdBQUc7WUFFTixHQUFHLEdBQUcsS0FDTixHQUFHLEdBQUksQ0FBQ1IsU0FBUU0sMEJBQTBCQywrQkFBbUJBO2dCQUk3RCxJQUFJVSxvQkFBb0JWLCtCQUFtQkEsQ0FBQyxLQUFLVSxpQkFBaUI7Z0JBRWxFLFNBQVNQLGlCQUFpQjtnQkFFMUIsMERBQTBEO2dCQUMxRCxJQUFL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QUFJQyxpQkFBaUJ6VyxXQUFXO2dCQUMzQyxNQUFNLEdBQU0sT0FBT3lXLGFBQWF6c0IsT0FBTztZQUN2QyxNQUFNLEdBQUs7WUFDWCxNQUFNLEdBQUssa0RBQWtEO1lBQzdELE1BQU0sR0FBSyxJQUFJQyxVQUFTc3NCLHdCQUF3QixDQUFDQyxTQUFTLEdBQUc7Z0JBQzdELE1BQU0sR0FBTSxzQkFBc0I7Z0JBQ2xDLE1BQU0sR0FBTSwwQkFBMEI7Z0JBQ3RDLE1BQU0sR0FBTXhzQixTQUFTLENBQUM7WUFDWDtZQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS00sbUJBQW1CLENBQUNrc0IsU0FBUyxDQUFDdnNCLFNBQVFBLFFBQU9ELE9BQU8sRUFBRVEsaUNBQW1CQTtZQUNwRixNQUFNLEdBQ04sTUFBTSxHQUFLLG1DQUFtQztZQUM5QyxNQUFNLEdBQUssT0FBT1AsUUFBT0QsT0FBTztRQUNoQyxNQUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FDTixNQUFNLEdBQUksVUFBVTtRQUNwQixNQUFNLEdBQUksdUNBQXVDO1FBQ2pELE1BQU0sR0FBSSwwRUFBMEU7UUFDcEYsTUFBTSxHQUFJLElBQUkwc0IsMEJBQW1CQSxHQUFHbHNCLGlDQUFtQkEsQ0FBQztRQUN4RCxNQUFNLEdBQ04sTUFBTSxHQUFJLE9BQU9rc0IsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL2Npcm8tbmV0d29yay13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1mY29zZS9ub2RlX21vZHVsZXMvY29zZS1iYXNlL2Nvc2UtYmFzZS5qcz8yMzBmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxheW91dC1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImxheW91dC1iYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNvc2VCYXNlXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImNvc2VCYXNlXCJdID0gZmFjdG9yeShyb290W1wibGF5b3V0QmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NTFfXykge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgY29zZUJhc2UgPSB7fTtcblxuY29zZUJhc2UubGF5b3V0QmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKTtcbmNvc2VCYXNlLkNvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG5jb3NlQmFzZS5Db1NFRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzY3KTtcbmNvc2VCYXNlLkNvU0VHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oODgwKTtcbmNvc2VCYXNlLkNvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3OCk7XG5jb3NlQmFzZS5Db1NFTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjUpO1xuY29zZUJhc2UuQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MSk7XG5jb3NlQmFzZS5Db25zdHJhaW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3NlQmFzZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dENvbnN0YW50cztcblxuZnVuY3Rpb24gQ29TRUNvbnN0YW50cygpIHt9XG5cbi8vQ29TRUNvbnN0YW50cyBpbmhlcml0cyBzdGF0aWMgcHJvcHMgaW4gRkRMYXlvdXRDb25zdGFudHNcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXRDb25zdGFudHMpIHtcbiAgQ29TRUNvbnN0YW50c1twcm9wXSA9IEZETGF5b3V0Q29uc3RhbnRzW3Byb3BdO1xufVxuXG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfVVNFX01VTFRJX0xFVkVMX1NDQUxJTkcgPSBmYWxzZTtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04gPSA2MDtcbkNvU0VDb25zdGFudHMuVElMRSA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMID0gMTA7XG5Db1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuUkVMQVhfTU9WRU1FTlRfT05fQ09OU1RSQUlOVFMgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IHRydWU7IC8vIHRoaXMgc2hvdWxkIGJlIHNldCB0byBmYWxzZSBpZiB0aGVyZSB3aWxsIGJlIGEgY29uc3RyYWludFxuLy8gVGhpcyBjb25zdGFudCBpcyBmb3IgZGlmZmVyZW50aWF0aW5nIHdoZXRoZXIgYWN0dWFsIGxheW91dCBhbGdvcml0aG0gdGhhdCB1c2VzIGNvc2UtYmFzZSB3YW50cyB0byBhcHBseSBvbmx5IGluY3JlbWVudGFsIGxheW91dCBvciBcbi8vIGFuIGluY3JlbWVudGFsIGxheW91dCBvbiB0b3Agb2YgYSByYW5kb21pemVkIGxheW91dC4gSWYgaXQgaXMgb25seSBpbmNyZW1lbnRhbCBsYXlvdXQsIHRoZW4gdGhpcyBjb25zdGFudCBzaG91bGQgYmUgdHJ1ZS5cbkNvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFQ29uc3RhbnRzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dEVkZ2U7XG5cbmZ1bmN0aW9uIENvU0VFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBGRExheW91dEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xufVxuXG5Db1NFRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0RWRnZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dEVkZ2UpIHtcbiAgQ29TRUVkZ2VbcHJvcF0gPSBGRExheW91dEVkZ2VbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUVkZ2U7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4ODA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaDtcblxuZnVuY3Rpb24gQ29TRUdyYXBoKHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCkge1xuICBMR3JhcGguY2FsbCh0aGlzLCBwYXJlbnQsIGdyYXBoTWdyLCB2R3JhcGgpO1xufVxuXG5Db1NFR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGgucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoKSB7XG4gIENvU0VHcmFwaFtwcm9wXSA9IExHcmFwaFtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGg7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Nzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MR3JhcGhNYW5hZ2VyO1xuXG5mdW5jdGlvbiBDb1NFR3JhcGhNYW5hZ2VyKGxheW91dCkge1xuICBMR3JhcGhNYW5hZ2VyLmNhbGwodGhpcywgbGF5b3V0KTtcbn1cblxuQ29TRUdyYXBoTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE1hbmFnZXIucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoTWFuYWdlcikge1xuICBDb1NFR3JhcGhNYW5hZ2VyW3Byb3BdID0gTEdyYXBoTWFuYWdlcltwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGhNYW5hZ2VyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0O1xudmFyIENvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3OCk7XG52YXIgQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODApO1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTEpO1xudmFyIENvU0VFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcpO1xudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG52YXIgQ29uc3RyYWludEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMik7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRkRMYXlvdXRDb25zdGFudHM7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxheW91dENvbnN0YW50cztcbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5Qb2ludDtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuUG9pbnREO1xudmFyIERpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRGltZW5zaW9uRDtcbnZhciBMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGF5b3V0O1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSW50ZWdlcjtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSUdlb21ldHJ5O1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MR3JhcGg7XG52YXIgVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlRyYW5zZm9ybTtcbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxpbmtlZExpc3Q7XG5cbmZ1bmN0aW9uIENvU0VMYXlvdXQoKSB7XG4gIEZETGF5b3V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy50b0JlVGlsZWQgPSB7fTsgLy8gTWVtb3JpemUgaWYgYSBub2RlIGlzIHRvIGJlIHRpbGVkIG9yIGlzIHRpbGVkXG4gIHRoaXMuY29uc3RyYWludHMgPSB7fTsgLy8ga2VlcCBsYXlvdXQgY29uc3RyYWludHNcbn1cblxuQ29TRUxheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXQpIHtcbiAgQ29TRUxheW91dFtwcm9wXSA9IEZETGF5b3V0W3Byb3BdO1xufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbSA9IG5ldyBDb1NFR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuICByZXR1cm4gZ207XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaCA9IGZ1bmN0aW9uICh2R3JhcGgpIHtcbiAgcmV0dXJuIG5ldyBDb1NFR3JhcGgobnVsbCwgdGhpcy5ncmFwaE1hbmFnZXIsIHZHcmFwaCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0VkZ2UgPSBmdW5jdGlvbiAodkVkZ2UpIHtcbiAgcmV0dXJuIG5ldyBDb1NFRWRnZShudWxsLCBudWxsLCB2RWRnZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgRkRMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzLmNhbGwodGhpcywgYXJndW1lbnRzKTtcbiAgaWYgKCF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgaWYgKENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA8IDEwKSB7XG4gICAgICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgICB9XG5cbiAgICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OO1xuICAgIHRoaXMuZ3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIO1xuICAgIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gICAgdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICAgIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuXG4gICAgLy8gdmFyaWFibGVzIGZvciB0cmVlIHJlZHVjdGlvbiBzdXBwb3J0XG4gICAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IFtdO1xuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0dyb3d0aEZpbmlzaGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IENvU0UgcmVsYXRlZCBwYXJhbWV0ZXJzIHVzZWQgYnkgc3ByaW5nIGVtYmVkZGVyLlxuQ29TRUxheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyLmNhbGwodGhpcyk7XG5cbiAgLy8gdmFyaWFibGVzIGZvciBjb29saW5nXG4gIHRoaXMuY29vbGluZ0N5Y2xlID0gMDtcbiAgdGhpcy5tYXhDb29saW5nQ3ljbGUgPSB0aGlzLm1heEl0ZXJhdGlvbnMgLyBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0Q7XG4gIHRoaXMuZmluYWxUZW1wZXJhdHVyZSA9IDAuMDQ7XG4gIHRoaXMuY29vbGluZ0FkanVzdGVyID0gMTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICBpZiAoY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50cygpO1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWwgPSAwO1xuICByZXR1cm4gdGhpcy5jbGFzc2ljTGF5b3V0KCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGFzc2ljTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5vZGVzV2l0aEdyYXZpdHkgPSB0aGlzLmNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8oKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24odGhpcy5ub2Rlc1dpdGhHcmF2aXR5KTtcbiAgdGhpcy5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjSW5jbHVzaW9uVHJlZURlcHRocygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgdGhpcy5jYWxjSWRlYWxFZGdlTGVuZ3RocygpO1xuXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHZhciBmb3Jlc3QgPSB0aGlzLmdldEZsYXRGb3Jlc3QoKTtcblxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgZmxhdCBhbmQgYSBmb3Jlc3RcbiAgICBpZiAoZm9yZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhZGlhbGx5KGZvcmVzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgbm90IGZsYXQgb3IgYSBmb3Jlc3RcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVkdWNlIHRoZSB0cmVlcyB3aGVuIGluY3JlbWVudGFsIG1vZGUgaXMgbm90IGVuYWJsZWQgYW5kIGdyYXBoIGlzIG5vdCBhIGZvcmVzdCBcbiAgICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gYWxsTm9kZXMuaGFzKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSgpO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIGluIGluY3JlbWVudGFsIG1vZGUgaWYgb25seSB0aGlzIGNvbnN0YW50IGlzIHNldCB0byB0cnVlIFxuICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY29uc3RyYWludHMpLmxlbmd0aCA+IDApIHtcbiAgICBDb25zdHJhaW50SGFuZGxlci5oYW5kbGVDb25zdHJhaW50cyh0aGlzKTtcbiAgICB0aGlzLmluaXRDb25zdHJhaW50VmFyaWFibGVzKCk7XG4gIH1cblxuICB0aGlzLmluaXRTcHJpbmdFbWJlZGRlcigpO1xuICBpZiAoQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQpIHtcbiAgICB0aGlzLnJ1blNwcmluZ0VtYmVkZGVyKCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudG90YWxJdGVyYXRpb25zKys7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID09PSB0aGlzLm1heEl0ZXJhdGlvbnMgJiYgIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID09IDAgJiYgIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMuaXNDb252ZXJnZWQoKSkge1xuICAgICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb29saW5nQ3ljbGUrKztcblxuICAgIGlmICh0aGlzLmxheW91dFF1YWxpdHkgPT0gMCkge1xuICAgICAgLy8gcXVhbGl0eSAtIFwiZHJhZnRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAxKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkZWZhdWx0XCJcbiAgICAgIHRoaXMuY29vbGluZ0FkanVzdGVyID0gdGhpcy5jb29saW5nQ3ljbGUgLyAzO1xuICAgIH1cblxuICAgIC8vIGNvb2xpbmcgc2NoZWR1bGUgaXMgYmFzZWQgb24gaHR0cDovL3d3dy5idGx1a2UuY29tL3NpbWFuZjEuaHRtbCAtPiBjb29saW5nIHNjaGVkdWxlIDNcbiAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yIC0gTWF0aC5wb3codGhpcy5jb29saW5nQ3ljbGUsIE1hdGgubG9nKDEwMCAqICh0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yIC0gdGhpcy5maW5hbFRlbXBlcmF0dXJlKSkgLyBNYXRoLmxvZyh0aGlzLm1heENvb2xpbmdDeWNsZSkpIC8gMTAwICogdGhpcy5jb29saW5nQWRqdXN0ZXIsIHRoaXMuZmluYWxUZW1wZXJhdHVyZSk7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBNYXRoLmNlaWwodGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kICogTWF0aC5zcXJ0KHRoaXMuY29vbGluZ0ZhY3RvcikpO1xuICB9XG4gIC8vIE9wZXJhdGlvbnMgd2hpbGUgdHJlZSBpcyBncm93aW5nIGFnYWluIFxuICBpZiAodGhpcy5pc1RyZWVHcm93aW5nKSB7XG4gICAgaWYgKHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zICUgMTAgPT0gMCkge1xuICAgICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICAgIHRoaXMuZ3Jvd1RyZWUodGhpcy5wcnVuZWROb2Rlc0FsbCk7XG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCAvIDI7ZWxzZSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zKys7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyBhZnRlciBncm93dGggaXMgZmluaXNoZWRcbiAgaWYgKHRoaXMuaXNHcm93dGhGaW5pc2hlZCkge1xuICAgIGlmICh0aGlzLmlzQ29udmVyZ2VkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cbiAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIC8gMiAqICgoMTAwIC0gdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMpIC8gMTAwKTtlbHNlIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgKiAoKDEwMCAtIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zKSAvIDEwMCk7XG4gICAgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIHZhciBncmlkVXBkYXRlQWxsb3dlZCA9ICF0aGlzLmlzVHJlZUdyb3dpbmcgJiYgIXRoaXMuaXNHcm93dGhGaW5pc2hlZDtcbiAgdmFyIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUgPSB0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucyAlIDEwID09IDEgJiYgdGhpcy5pc1RyZWVHcm93aW5nIHx8IHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zICUgMTAgPT0gMSAmJiB0aGlzLmlzR3Jvd3RoRmluaXNoZWQ7XG5cbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudCA9IDA7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICB0aGlzLmNhbGNTcHJpbmdGb3JjZXMoKTtcbiAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2VzKGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlcygpO1xuICB0aGlzLm1vdmVOb2RlcygpO1xuICB0aGlzLmFuaW1hdGUoKTtcblxuICByZXR1cm4gZmFsc2U7IC8vIExheW91dCBpcyBub3QgZW5kZWQgeWV0IHJldHVybiBmYWxzZVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0UG9zaXRpb25zRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHBEYXRhID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVjdCA9IGFsbE5vZGVzW2ldLnJlY3Q7XG4gICAgdmFyIGlkID0gYWxsTm9kZXNbaV0uaWQ7XG4gICAgcERhdGFbaWRdID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgeDogcmVjdC5nZXRDZW50ZXJYKCksXG4gICAgICB5OiByZWN0LmdldENlbnRlclkoKSxcbiAgICAgIHc6IHJlY3Qud2lkdGgsXG4gICAgICBoOiByZWN0LmhlaWdodFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcERhdGE7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5ydW5TcHJpbmdFbWJlZGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kID0gMjU7XG4gIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gdGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kO1xuICB2YXIgbGF5b3V0RW5kZWQgPSBmYWxzZTtcblxuICAvLyBJZiBhbWluYXRlIG9wdGlvbiBpcyAnZHVyaW5nJyBzaWduYWwgdGhhdCBsYXlvdXQgaXMgc3VwcG9zZWQgdG8gc3RhcnQgaXRlcmF0aW5nXG4gIGlmIChGRExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RhcnRlZCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFtaW5hdGUgb3B0aW9uIGlzICdkdXJpbmcnIHRpY2soKSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBpbmRleC5qc1xuICAgIHdoaWxlICghbGF5b3V0RW5kZWQpIHtcbiAgICAgIGxheW91dEVuZGVkID0gdGhpcy50aWNrKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gIH1cbn07XG5cbi8vIG92ZXJyaWRlcyBtb3ZlTm9kZXMgbWV0aG9kIGluIEZETGF5b3V0XG5Db1NFTGF5b3V0LnByb3RvdHlwZS5tb3ZlTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gIHZhciBub2RlO1xuXG4gIC8vIGNhbGN1bGF0ZSBkaXNwbGFjZW1lbnQgZm9yIGVhY2ggbm9kZSBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIG5vZGUuY2FsY3VsYXRlRGlzcGxhY2VtZW50KCk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXModGhpcy5jb25zdHJhaW50cykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMudXBkYXRlRGlzcGxhY2VtZW50cygpO1xuICB9XG5cbiAgLy8gbW92ZSBlYWNoIG5vZGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIG5vZGUubW92ZSgpO1xuICB9XG59O1xuXG4vLyBjb25zdHJhaW50IHJlbGF0ZWQgbWV0aG9kczogaW5pdENvbnN0cmFpbnRWYXJpYWJsZXMgYW5kIHVwZGF0ZURpc3BsYWNlbWVudHNcblxuLy8gaW5pdGlhbGl6ZSBjb25zdHJhaW50IHJlbGF0ZWQgdmFyaWFibGVzXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0Q29uc3RyYWludFZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmlkVG9Ob2RlTWFwID0gbmV3IE1hcCgpO1xuICB0aGlzLmZpeGVkTm9kZVNldCA9IG5ldyBTZXQoKTtcblxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIC8vIGZpbGwgaWRUb05vZGVNYXBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgdGhpcy5pZFRvTm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgZml4ZWQgbm9kZSB3ZWlnaHQgZm9yIGdpdmVuIGNvbXBvdW5kIG5vZGVcbiAgdmFyIGNhbGN1bGF0ZUNvbXBvdW5kV2VpZ2h0ID0gZnVuY3Rpb24gY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQoY29tcG91bmROb2RlKSB7XG4gICAgdmFyIG5vZGVzID0gY29tcG91bmROb2RlLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgZml4ZWROb2RlV2VpZ2h0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgICAgaWYgKHNlbGYuZml4ZWROb2RlU2V0Lmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgIGZpeGVkTm9kZVdlaWdodCArPSAxMDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpeGVkTm9kZVdlaWdodCArPSBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpeGVkTm9kZVdlaWdodDtcbiAgfTtcblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgLy8gZmlsbCBmaXhlZE5vZGVTZXRcbiAgICB0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEpIHtcbiAgICAgIHNlbGYuZml4ZWROb2RlU2V0LmFkZChub2RlRGF0YS5ub2RlSWQpO1xuICAgIH0pO1xuXG4gICAgLy8gYXNzaWduIGZpeGVkIG5vZGUgd2VpZ2h0cyB0byBjb21wb3VuZHMgaWYgdGhleSBjb250YWluIGZpeGVkIG5vZGVzXG4gICAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZml4ZWROb2RlV2VpZ2h0ID0gY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQobm9kZSk7XG4gICAgICAgIGlmIChmaXhlZE5vZGVXZWlnaHQgPiAwKSB7XG4gICAgICAgICAgbm9kZS5maXhlZE5vZGVXZWlnaHQgPSBmaXhlZE5vZGVXZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICB2YXIgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZpeGVkTm9kZXNPbkhvcml6b250YWwgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5maXhlZE5vZGVzT25WZXJ0aWNhbCA9IG5ldyBTZXQoKTtcblxuICAgIC8vIGZpbGwgbWFwcyBhbmQgc2V0c1xuICAgIHRoaXMuZml4ZWROb2RlU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChub2RlSWQpO1xuICAgICAgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQobm9kZUlkKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ25tZW50ID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2FsQWxpZ25tZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBpLCBbXSk7XG4gICAgICAgICAgdmVydGljYWxBbGlnbm1lbnRbaV0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBpKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBob3Jpem9udGFsQWxpZ25tZW50ID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9yaXpvbnRhbEFsaWdubWVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBpLCBbXSk7XG4gICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudFtpXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBpKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQoXCJkdW1teVwiICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQ29TRUNvbnN0YW50cy5SRUxBWF9NT1ZFTUVOVF9PTl9DT05TVFJBSU5UUykge1xuXG4gICAgICB0aGlzLnNodWZmbGUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGosIHgsIGk7XG4gICAgICAgIGZvciAoaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMiAqIGFycmF5Lmxlbmd0aCAvIDM7IGktLSkge1xuICAgICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICB4ID0gYXJyYXlbaV07XG4gICAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgICBhcnJheVtqXSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfTtcblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsID0gW107XG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsID0gW107XG4gICAgICB0aGlzLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbCA9IG5ldyBNYXAoKTtcblxuICAgICAgLy8gZmlsbCBhcnJheXMgYW5kIG1hcHNcbiAgICAgIHRoaXMuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIHZhciBub2RlSWRMZWZ0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5sZWZ0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQubGVmdCkgOiBjb25zdHJhaW50LmxlZnQ7XG4gICAgICAgICAgdmFyIG5vZGVJZFJpZ2h0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5yaWdodCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnJpZ2h0KSA6IGNvbnN0cmFpbnQucmlnaHQ7XG5cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5pbmNsdWRlcyhub2RlSWRMZWZ0KSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLnB1c2gobm9kZUlkTGVmdCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuc2V0KG5vZGVJZExlZnQsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZExlZnQpKSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWRMZWZ0KVswXSkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkTGVmdCkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwuaW5jbHVkZXMobm9kZUlkUmlnaHQpKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwucHVzaChub2RlSWRSaWdodCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBbXSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhub2RlSWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRSaWdodCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWRSaWdodClbMF0pLmdldENlbnRlclgoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRSaWdodCkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZExlZnQpLnB1c2goeyByaWdodDogbm9kZUlkUmlnaHQsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBIb3Jpem9udGFsLmdldChub2RlSWRSaWdodCkucHVzaCh7IGxlZnQ6IG5vZGVJZExlZnQsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGVJZFRvcCA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC50b3ApID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnRvcCkgOiBjb25zdHJhaW50LnRvcDtcbiAgICAgICAgICB2YXIgbm9kZUlkQm90dG9tID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmJvdHRvbSkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSA6IGNvbnN0cmFpbnQuYm90dG9tO1xuXG4gICAgICAgICAgaWYgKCFzZWxmLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsLmluY2x1ZGVzKG5vZGVJZFRvcCkpIHtcbiAgICAgICAgICAgIHNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwucHVzaChub2RlSWRUb3ApO1xuICAgICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBbXSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZFRvcCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQobm9kZUlkVG9wKVswXSkuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuc2V0KG5vZGVJZFRvcCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkVG9wKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwuaW5jbHVkZXMobm9kZUlkQm90dG9tKSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5wdXNoKG5vZGVJZEJvdHRvbSk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkQm90dG9tKSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWRCb3R0b20pWzBdKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkQm90dG9tLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRCb3R0b20pLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZFRvcCkucHVzaCh7IGJvdHRvbTogbm9kZUlkQm90dG9tLCBnYXA6IGNvbnN0cmFpbnQuZ2FwIH0pO1xuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZEJvdHRvbSkucHVzaCh7IHRvcDogbm9kZUlkVG9wLCBnYXA6IGNvbnN0cmFpbnQuZ2FwIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN1YkdyYXBoT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpOyAvLyBzdWJncmFwaCBmcm9tIHZlcnRpY2FsIFJQIGNvbnN0cmFpbnRzXG4gICAgICB2YXIgc3ViR3JhcGhPblZlcnRpY2FsID0gbmV3IE1hcCgpOyAvLyBzdWJncmFwaCBmcm9tIHZlcnRpY2FsIFJQIGNvbnN0cmFpbnRzXG5cbiAgICAgIC8vIGNvbnN0cnVjdCBzdWJncmFwaHMgZnJvbSByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHMgXG4gICAgICB0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgIGlmIChjb25zdHJhaW50LmxlZnQpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQubGVmdCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LmxlZnQpIDogY29uc3RyYWludC5sZWZ0O1xuICAgICAgICAgIHZhciByaWdodCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQucmlnaHQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5yaWdodCkgOiBjb25zdHJhaW50LnJpZ2h0O1xuICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMobGVmdCkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLmdldChsZWZ0KS5wdXNoKHJpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KGxlZnQsIFtyaWdodF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3ViR3JhcGhPbkhvcml6b250YWwuaGFzKHJpZ2h0KSkge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KHJpZ2h0KS5wdXNoKGxlZnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5zZXQocmlnaHQsIFtsZWZ0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0b3AgPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQudG9wKSA/IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC50b3ApIDogY29uc3RyYWludC50b3A7XG4gICAgICAgICAgdmFyIGJvdHRvbSA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5ib3R0b20pID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LmJvdHRvbSkgOiBjb25zdHJhaW50LmJvdHRvbTtcbiAgICAgICAgICBpZiAoc3ViR3JhcGhPblZlcnRpY2FsLmhhcyh0b3ApKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KHRvcCkucHVzaChib3R0b20pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KHRvcCwgW2JvdHRvbV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3ViR3JhcGhPblZlcnRpY2FsLmhhcyhib3R0b20pKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KGJvdHRvbSkucHVzaCh0b3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KGJvdHRvbSwgW3RvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCBjb21wb25lbnRzIGZyb20gYSBnaXZlbiBncmFwaCBcbiAgICAgIC8vIGFsc28gcmV0dXJucyBhbiBhcnJheSB0aGF0IGtlZXBzIHdoZXRoZXIgZWFjaCBjb21wb25lbnQgY29udGFpbnMgZml4ZWQgbm9kZVxuICAgICAgdmFyIGNvbnN0cnVjdENvbXBvbmVudHMgPSBmdW5jdGlvbiBjb25zdHJ1Y3RDb21wb25lbnRzKGdyYXBoLCBmaXhlZE5vZGVzKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBpc0ZpeGVkID0gW107XG4gICAgICAgIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdID0gW107XG4gICAgICAgICAgICBpc0ZpeGVkW2NvdW50XSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0ga2V5O1xuICAgICAgICAgICAgcXVldWUucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIGlzRml4ZWRbY291bnRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgbmVpZ2hib3JzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuZWlnaGJvcikpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgdmlzaXRlZC5hZGQobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50c1tjb3VudF0ucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBjb21wb25lbnRzOiBjb21wb25lbnRzLCBpc0ZpeGVkOiBpc0ZpeGVkIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzdWx0T25Ib3Jpem9udGFsID0gY29uc3RydWN0Q29tcG9uZW50cyhzdWJHcmFwaE9uSG9yaXpvbnRhbCwgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsKTtcbiAgICAgIHRoaXMuY29tcG9uZW50c09uSG9yaXpvbnRhbCA9IHJlc3VsdE9uSG9yaXpvbnRhbC5jb21wb25lbnRzO1xuICAgICAgdGhpcy5maXhlZENvbXBvbmVudHNPbkhvcml6b250YWwgPSByZXN1bHRPbkhvcml6b250YWwuaXNGaXhlZDtcbiAgICAgIHZhciByZXN1bHRPblZlcnRpY2FsID0gY29uc3RydWN0Q29tcG9uZW50cyhzdWJHcmFwaE9uVmVydGljYWwsIHNlbGYuZml4ZWROb2Rlc09uVmVydGljYWwpO1xuICAgICAgdGhpcy5jb21wb25lbnRzT25WZXJ0aWNhbCA9IHJlc3VsdE9uVmVydGljYWwuY29tcG9uZW50cztcbiAgICAgIHRoaXMuZml4ZWRDb21wb25lbnRzT25WZXJ0aWNhbCA9IHJlc3VsdE9uVmVydGljYWwuaXNGaXhlZDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHVwZGF0ZXMgbm9kZSBkaXNwbGFjZW1lbnRzIGJhc2VkIG9uIGNvbnN0cmFpbnRzXG5Db1NFTGF5b3V0LnByb3RvdHlwZS51cGRhdGVEaXNwbGFjZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEpIHtcbiAgICAgIHZhciBmaXhlZE5vZGUgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlRGF0YS5ub2RlSWQpO1xuICAgICAgZml4ZWROb2RlLmRpc3BsYWNlbWVudFggPSAwO1xuICAgICAgZml4ZWROb2RlLmRpc3BsYWNlbWVudFkgPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgIHZhciBhbGxWZXJ0aWNhbEFsaWdubWVudHMgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFZlcnRpY2FsQWxpZ25tZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG90YWxEaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxWZXJ0aWNhbEFsaWdubWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5maXhlZE5vZGVTZXQuaGFzKGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkpIHtcbiAgICAgICAgICAgIHRvdGFsRGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRYICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXZlcmFnZURpc3BsYWNlbWVudFggPSB0b3RhbERpc3BsYWNlbWVudFggLyBhbGxWZXJ0aWNhbEFsaWdubWVudHNbaV0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkuZGlzcGxhY2VtZW50WCA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnRYO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgdmFyIGFsbEhvcml6b250YWxBbGlnbm1lbnRzID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b3RhbERpc3BsYWNlbWVudFkgPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZml4ZWROb2RlU2V0LmhhcyhhbGxIb3Jpem9udGFsQWxpZ25tZW50c1tpXVtqXSkpIHtcbiAgICAgICAgICAgIHRvdGFsRGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRZICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50WSA9IHRvdGFsRGlzcGxhY2VtZW50WSAvIGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxIb3Jpem9udGFsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRZID0gYXZlcmFnZURpc3BsYWNlbWVudFk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcblxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlJFTEFYX01PVkVNRU5UX09OX0NPTlNUUkFJTlRTKSB7XG4gICAgICAvLyBzaHVmZmxlIGFycmF5IHRvIHJhbmRvbWl6ZSBub2RlIHByb2Nlc3Npbmcgb3JkZXJcbiAgICAgIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIDEwID09IDApIHtcbiAgICAgICAgdGhpcy5zaHVmZmxlKHRoaXMubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbCk7XG4gICAgICAgIHRoaXMuc2h1ZmZsZSh0aGlzLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICBpZiAoIXNlbGYuZml4ZWROb2Rlc09uSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgIHZhciBkaXNwbGFjZW1lbnQgPSAwO1xuICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudCA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQobm9kZUlkKVswXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGNvbnN0cmFpbnQucmlnaHQpIC0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpIC0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgICBpZiAoZGlmZiA8IGNvbnN0cmFpbnQuZ2FwKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50IC09IGNvbnN0cmFpbnQuZ2FwIC0gZGlmZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGNvbnN0cmFpbnQubGVmdCkgKyBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgKz0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWQsIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKSArIGRpc3BsYWNlbWVudCk7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYID0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIGlmICghc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IDA7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQobm9kZUlkKVswXSkuZGlzcGxhY2VtZW50WTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmJvdHRvbSkge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgLSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgLT0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLmdldChjb25zdHJhaW50LnRvcCkgKyBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgKz0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkLCBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLmdldChub2RlSWQpICsgZGlzcGxhY2VtZW50KTtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZID0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wb25lbnRzT25Ib3Jpem9udGFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNPbkhvcml6b250YWxbaV07XG4gICAgICAgIGlmICh0aGlzLmZpeGVkQ29tcG9uZW50c09uSG9yaXpvbnRhbFtpXSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSAwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdmFyIGFjdHVhbE5vZGVzID0gdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pO1xuICAgICAgICAgICAgICBzdW0gKz0gYWN0dWFsTm9kZXMubGVuZ3RoICogdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWN0dWFsTm9kZXNbMF0pLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgICAgIGNvdW50ICs9IGFjdHVhbE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1bSArPSB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50ID0gc3VtIC8gY291bnQ7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsW2ldO1xuICAgICAgICBpZiAodGhpcy5maXhlZENvbXBvbmVudHNPblZlcnRpY2FsW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSAwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB2YXIgYWN0dWFsTm9kZXMgPSB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKTtcbiAgICAgICAgICAgICAgc3VtICs9IGFjdHVhbE5vZGVzLmxlbmd0aCAqIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFjdHVhbE5vZGVzWzBdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgICAgICBjb3VudCArPSBhY3R1YWxOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXZlcmFnZURpc3BsYWNlbWVudCA9IHN1bSAvIGNvdW50O1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVMaXN0ID0gW107XG4gIHZhciBncmFwaDtcblxuICB2YXIgZ3JhcGhzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0R3JhcGhzKCk7XG4gIHZhciBzaXplID0gZ3JhcGhzLmxlbmd0aDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBncmFwaCA9IGdyYXBoc1tpXTtcblxuICAgIGdyYXBoLnVwZGF0ZUNvbm5lY3RlZCgpO1xuXG4gICAgaWYgKCFncmFwaC5pc0Nvbm5lY3RlZCkge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGguZ2V0Tm9kZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVMaXN0O1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY3JlYXRlQmVuZHBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG5cbiAgICBpZiAoIXZpc2l0ZWQuaGFzKGVkZ2UpKSB7XG4gICAgICB2YXIgc291cmNlID0gZWRnZS5nZXRTb3VyY2UoKTtcbiAgICAgIHZhciB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBpZiAoc291cmNlID09IHRhcmdldCkge1xuICAgICAgICBlZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgdGhpcy5jcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyhlZGdlKTtcbiAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWRnZUxpc3QgPSBbXTtcblxuICAgICAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdChzb3VyY2UuZ2V0RWRnZUxpc3RUb05vZGUodGFyZ2V0KSk7XG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRhcmdldC5nZXRFZGdlTGlzdFRvTm9kZShzb3VyY2UpKTtcblxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGVkZ2VMaXN0WzBdKSkge1xuICAgICAgICAgIGlmIChlZGdlTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlZGdlTGlzdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICB2YXIgbXVsdGlFZGdlID0gZWRnZUxpc3Rba107XG4gICAgICAgICAgICAgIG11bHRpRWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKG11bHRpRWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkZ2VMaXN0LmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGVkZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWQuc2l6ZSA9PSBlZGdlcy5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucG9zaXRpb25Ob2Rlc1JhZGlhbGx5ID0gZnVuY3Rpb24gKGZvcmVzdCkge1xuICAvLyBXZSB0aWxlIHRoZSB0cmVlcyB0byBhIGdyaWQgcm93IGJ5IHJvdzsgZmlyc3QgdHJlZSBzdGFydHMgYXQgKDAsMClcbiAgdmFyIGN1cnJlbnRTdGFydGluZ1BvaW50ID0gbmV3IFBvaW50KDAsIDApO1xuICB2YXIgbnVtYmVyT2ZDb2x1bW5zID0gTWF0aC5jZWlsKE1hdGguc3FydChmb3Jlc3QubGVuZ3RoKSk7XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgY3VycmVudFkgPSAwO1xuICB2YXIgY3VycmVudFggPSAwO1xuICB2YXIgcG9pbnQgPSBuZXcgUG9pbnREKDAsIDApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgJSBudW1iZXJPZkNvbHVtbnMgPT0gMCkge1xuICAgICAgLy8gU3RhcnQgb2YgYSBuZXcgcm93LCBtYWtlIHRoZSB4IGNvb3JkaW5hdGUgMCwgaW5jcmVtZW50IHRoZVxuICAgICAgLy8geSBjb29yZGluYXRlIHdpdGggdGhlIG1heCBoZWlnaHQgb2YgdGhlIHByZXZpb3VzIHJvd1xuICAgICAgY3VycmVudFggPSAwO1xuICAgICAgY3VycmVudFkgPSBoZWlnaHQ7XG5cbiAgICAgIGlmIChpICE9IDApIHtcbiAgICAgICAgY3VycmVudFkgKz0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OO1xuICAgICAgfVxuXG4gICAgICBoZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIHZhciB0cmVlID0gZm9yZXN0W2ldO1xuXG4gICAgLy8gRmluZCB0aGUgY2VudGVyIG9mIHRoZSB0cmVlXG4gICAgdmFyIGNlbnRlck5vZGUgPSBMYXlvdXQuZmluZENlbnRlck9mVHJlZSh0cmVlKTtcblxuICAgIC8vIFNldCB0aGUgc3RhcmluZyBwb2ludCBvZiB0aGUgbmV4dCB0cmVlXG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueCA9IGN1cnJlbnRYO1xuICAgIGN1cnJlbnRTdGFydGluZ1BvaW50LnkgPSBjdXJyZW50WTtcblxuICAgIC8vIERvIGEgcmFkaWFsIGxheW91dCBzdGFydGluZyB3aXRoIHRoZSBjZW50ZXJcbiAgICBwb2ludCA9IENvU0VMYXlvdXQucmFkaWFsTGF5b3V0KHRyZWUsIGNlbnRlck5vZGUsIGN1cnJlbnRTdGFydGluZ1BvaW50KTtcblxuICAgIGlmIChwb2ludC55ID4gaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKHBvaW50LnkpO1xuICAgIH1cblxuICAgIGN1cnJlbnRYID0gTWF0aC5mbG9vcihwb2ludC54ICsgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OKTtcbiAgfVxuXG4gIHRoaXMudHJhbnNmb3JtKG5ldyBQb2ludEQoTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YIC0gcG9pbnQueCAvIDIsIExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSAtIHBvaW50LnkgLyAyKSk7XG59O1xuXG5Db1NFTGF5b3V0LnJhZGlhbExheW91dCA9IGZ1bmN0aW9uICh0cmVlLCBjZW50ZXJOb2RlLCBzdGFydGluZ1BvaW50KSB7XG4gIHZhciByYWRpYWxTZXAgPSBNYXRoLm1heCh0aGlzLm1heERpYWdvbmFsSW5UcmVlKHRyZWUpLCBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04pO1xuICBDb1NFTGF5b3V0LmJyYW5jaFJhZGlhbExheW91dChjZW50ZXJOb2RlLCBudWxsLCAwLCAzNTksIDAsIHJhZGlhbFNlcCk7XG4gIHZhciBib3VuZHMgPSBMR3JhcGguY2FsY3VsYXRlQm91bmRzKHRyZWUpO1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdYKGJvdW5kcy5nZXRNaW5YKCkpO1xuICB0cmFuc2Zvcm0uc2V0RGV2aWNlT3JnWShib3VuZHMuZ2V0TWluWSgpKTtcbiAgdHJhbnNmb3JtLnNldFdvcmxkT3JnWChzdGFydGluZ1BvaW50LngpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdZKHN0YXJ0aW5nUG9pbnQueSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIG5vZGUudHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cblxuICB2YXIgYm90dG9tUmlnaHQgPSBuZXcgUG9pbnREKGJvdW5kcy5nZXRNYXhYKCksIGJvdW5kcy5nZXRNYXhZKCkpO1xuXG4gIHJldHVybiB0cmFuc2Zvcm0uaW52ZXJzZVRyYW5zZm9ybVBvaW50KGJvdHRvbVJpZ2h0KTtcbn07XG5cbkNvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudE9mTm9kZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGRpc3RhbmNlLCByYWRpYWxTZXBhcmF0aW9uKSB7XG4gIC8vIEZpcnN0LCBwb3NpdGlvbiB0aGlzIG5vZGUgYnkgZmluZGluZyBpdHMgYW5nbGUuXG4gIHZhciBoYWxmSW50ZXJ2YWwgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlICsgMSkgLyAyO1xuXG4gIGlmIChoYWxmSW50ZXJ2YWwgPCAwKSB7XG4gICAgaGFsZkludGVydmFsICs9IDE4MDtcbiAgfVxuXG4gIHZhciBub2RlQW5nbGUgPSAoaGFsZkludGVydmFsICsgc3RhcnRBbmdsZSkgJSAzNjA7XG4gIHZhciB0ZXRhID0gbm9kZUFuZ2xlICogSUdlb21ldHJ5LlRXT19QSSAvIDM2MDtcblxuICAvLyBNYWtlIHBvbGFyIHRvIGphdmEgY29yZGluYXRlIGNvbnZlcnNpb24uXG4gIHZhciBjb3NfdGV0YSA9IE1hdGguY29zKHRldGEpO1xuICB2YXIgeF8gPSBkaXN0YW5jZSAqIE1hdGguY29zKHRldGEpO1xuICB2YXIgeV8gPSBkaXN0YW5jZSAqIE1hdGguc2luKHRldGEpO1xuXG4gIG5vZGUuc2V0Q2VudGVyKHhfLCB5Xyk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpc1xuICAvLyBmdW5jdGlvbi5cbiAgdmFyIG5laWdoYm9yRWRnZXMgPSBbXTtcbiAgbmVpZ2hib3JFZGdlcyA9IG5laWdoYm9yRWRnZXMuY29uY2F0KG5vZGUuZ2V0RWRnZXMoKSk7XG4gIHZhciBjaGlsZENvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG5cbiAgaWYgKHBhcmVudE9mTm9kZSAhPSBudWxsKSB7XG4gICAgY2hpbGRDb3VudC0tO1xuICB9XG5cbiAgdmFyIGJyYW5jaENvdW50ID0gMDtcblxuICB2YXIgaW5jRWRnZXNDb3VudCA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICB2YXIgc3RhcnRJbmRleDtcblxuICB2YXIgZWRnZXMgPSBub2RlLmdldEVkZ2VzQmV0d2VlbihwYXJlbnRPZk5vZGUpO1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBlZGdlcywgcHJ1bmUgdGhlbSB1bnRpbCB0aGVyZSByZW1haW5zIG9ubHkgb25lXG4gIC8vIGVkZ2UuXG4gIHdoaWxlIChlZGdlcy5sZW5ndGggPiAxKSB7XG4gICAgLy9uZWlnaGJvckVkZ2VzLnJlbW92ZShlZGdlcy5yZW1vdmUoMCkpO1xuICAgIHZhciB0ZW1wID0gZWRnZXNbMF07XG4gICAgZWRnZXMuc3BsaWNlKDAsIDEpO1xuICAgIHZhciBpbmRleCA9IG5laWdoYm9yRWRnZXMuaW5kZXhPZih0ZW1wKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgbmVpZ2hib3JFZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpbmNFZGdlc0NvdW50LS07XG4gICAgY2hpbGRDb3VudC0tO1xuICB9XG5cbiAgaWYgKHBhcmVudE9mTm9kZSAhPSBudWxsKSB7XG4gICAgLy9hc3NlcnQgZWRnZXMubGVuZ3RoID09IDE7XG4gICAgc3RhcnRJbmRleCA9IChuZWlnaGJvckVkZ2VzLmluZGV4T2YoZWRnZXNbMF0pICsgMSkgJSBpbmNFZGdlc0NvdW50O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0SW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIHN0ZXBBbmdsZSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyBjaGlsZENvdW50O1xuXG4gIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBicmFuY2hDb3VudCAhPSBjaGlsZENvdW50OyBpID0gKytpICUgaW5jRWRnZXNDb3VudCkge1xuICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKG5vZGUpO1xuXG4gICAgLy8gRG9uJ3QgYmFjayB0cmF2ZXJzZSB0byByb290IG5vZGUgaW4gY3VycmVudCB0cmVlLlxuICAgIGlmIChjdXJyZW50TmVpZ2hib3IgPT0gcGFyZW50T2ZOb2RlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRTdGFydEFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBicmFuY2hDb3VudCAqIHN0ZXBBbmdsZSkgJSAzNjA7XG4gICAgdmFyIGNoaWxkRW5kQW5nbGUgPSAoY2hpbGRTdGFydEFuZ2xlICsgc3RlcEFuZ2xlKSAlIDM2MDtcblxuICAgIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGN1cnJlbnROZWlnaGJvciwgbm9kZSwgY2hpbGRTdGFydEFuZ2xlLCBjaGlsZEVuZEFuZ2xlLCBkaXN0YW5jZSArIHJhZGlhbFNlcGFyYXRpb24sIHJhZGlhbFNlcGFyYXRpb24pO1xuXG4gICAgYnJhbmNoQ291bnQrKztcbiAgfVxufTtcblxuQ29TRUxheW91dC5tYXhEaWFnb25hbEluVHJlZSA9IGZ1bmN0aW9uICh0cmVlKSB7XG4gIHZhciBtYXhEaWFnb25hbCA9IEludGVnZXIuTUlOX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gdHJlZVtpXTtcbiAgICB2YXIgZGlhZ29uYWwgPSBub2RlLmdldERpYWdvbmFsKCk7XG5cbiAgICBpZiAoZGlhZ29uYWwgPiBtYXhEaWFnb25hbCkge1xuICAgICAgbWF4RGlhZ29uYWwgPSBkaWFnb25hbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4RGlhZ29uYWw7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGZvcm11bGEgaXMgMiB4IChsZXZlbCArIDEpIHggaWRlYWxFZGdlTGVuZ3RoXG4gIHJldHVybiAyICogKHRoaXMubGV2ZWwgKyAxKSAqIHRoaXMuaWRlYWxFZGdlTGVuZ3RoO1xufTtcblxuLy8gVGlsaW5nIG1ldGhvZHNcblxuLy8gR3JvdXAgemVybyBkZWdyZWUgbWVtYmVycyB3aG9zZSBwYXJlbnRzIGFyZSBub3QgdG8gYmUgdGlsZWQsIGNyZWF0ZSBkdW1teSBwYXJlbnRzIHdoZXJlIG5lZWRlZCBhbmQgZmlsbCBtZW1iZXJHcm91cHMgYnkgdGhlaXIgZHVtbXAgcGFyZW50IGlkJ3NcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gYXJyYXkgb2YgW3BhcmVudF9pZCB4IG9uZURlZ3JlZU5vZGVfaWRdXG4gIHZhciB0ZW1wTWVtYmVyR3JvdXBzID0ge307IC8vIEEgdGVtcG9yYXJ5IG1hcCBvZiBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnNcbiAgdGhpcy5tZW1iZXJHcm91cHMgPSB7fTsgLy8gQSBtYXAgb2YgZHVtbXkgcGFyZW50IG5vZGUgYW5kIGl0cyB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZFxuICB0aGlzLmlkVG9EdW1teU5vZGUgPSB7fTsgLy8gQSBtYXAgb2YgaWQgdG8gZHVtbXkgbm9kZSBcblxuICB2YXIgemVyb0RlZ3JlZSA9IFtdOyAvLyBMaXN0IG9mIHplcm8gZGVncmVlIG5vZGVzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZFxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIC8vIEZpbGwgemVybyBkZWdyZWUgbGlzdFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAvLyBJZiBhIG5vZGUgaGFzIHplcm8gZGVncmVlIGFuZCBpdHMgcGFyZW50IGlzIG5vdCB0byBiZSB0aWxlZCBpZiBleGlzdHMgYWRkIHRoYXQgbm9kZSB0byB6ZXJvRGVncmVzIGxpc3RcbiAgICBpZiAodGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKG5vZGUpID09PSAwICYmIChwYXJlbnQuaWQgPT0gdW5kZWZpbmVkIHx8ICF0aGlzLmdldFRvQmVUaWxlZChwYXJlbnQpKSkge1xuICAgICAgemVyb0RlZ3JlZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG1hcCBvZiBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB6ZXJvRGVncmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB6ZXJvRGVncmVlW2ldOyAvLyBaZXJvIGRlZ3JlZSBub2RlIGl0c2VsZlxuICAgIHZhciBwX2lkID0gbm9kZS5nZXRQYXJlbnQoKS5pZDsgLy8gUGFyZW50IGlkXG5cbiAgICBpZiAodHlwZW9mIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPT09IFwidW5kZWZpbmVkXCIpIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPSBbXTtcblxuICAgIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmNvbmNhdChub2RlKTsgLy8gUHVzaCBub2RlIHRvIHRoZSBsaXN0IGJlbG9uZ3MgdG8gaXRzIHBhcmVudCBpbiB0ZW1wTWVtYmVyR3JvdXBzXG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIG5vZGVzIGF0IGEgbGV2ZWwsIGNyZWF0ZSBhIGR1bW15IGNvbXBvdW5kIGZvciB0aGVtXG4gIE9iamVjdC5rZXlzKHRlbXBNZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKHBfaWQpIHtcbiAgICBpZiAodGVtcE1lbWJlckdyb3Vwc1twX2lkXS5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZHVtbXlDb21wb3VuZElkID0gXCJEdW1teUNvbXBvdW5kX1wiICsgcF9pZDsgLy8gVGhlIGlkIG9mIGR1bW15IGNvbXBvdW5kIHdoaWNoIHdpbGwgYmUgY3JlYXRlZCBzb29uXG4gICAgICBzZWxmLm1lbWJlckdyb3Vwc1tkdW1teUNvbXBvdW5kSWRdID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXTsgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIG1lbWJlckdyb3Vwc1xuXG4gICAgICB2YXIgcGFyZW50ID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXVswXS5nZXRQYXJlbnQoKTsgLy8gVGhlIHBhcmVudCBvZiB6ZXJvIGRlZ3JlZSBub2RlcyB3aWxsIGJlIHRoZSBwYXJlbnQgb2YgbmV3IGR1bW15IGNvbXBvdW5kXG5cbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IGNvbXBvdW5kIHdpdGggY2FsY3VsYXRlZCBpZFxuICAgICAgdmFyIGR1bW15Q29tcG91bmQgPSBuZXcgQ29TRU5vZGUoc2VsZi5ncmFwaE1hbmFnZXIpO1xuICAgICAgZHVtbXlDb21wb3VuZC5pZCA9IGR1bW15Q29tcG91bmRJZDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ0xlZnQgPSBwYXJlbnQucGFkZGluZ0xlZnQgfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ1JpZ2h0ID0gcGFyZW50LnBhZGRpbmdSaWdodCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nQm90dG9tID0gcGFyZW50LnBhZGRpbmdCb3R0b20gfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ1RvcCA9IHBhcmVudC5wYWRkaW5nVG9wIHx8IDA7XG5cbiAgICAgIHNlbGYuaWRUb0R1bW15Tm9kZVtkdW1teUNvbXBvdW5kSWRdID0gZHVtbXlDb21wb3VuZDtcblxuICAgICAgdmFyIGR1bW15UGFyZW50R3JhcGggPSBzZWxmLmdldEdyYXBoTWFuYWdlcigpLmFkZChzZWxmLm5ld0dyYXBoKCksIGR1bW15Q29tcG91bmQpO1xuICAgICAgdmFyIHBhcmVudEdyYXBoID0gcGFyZW50LmdldENoaWxkKCk7XG5cbiAgICAgIC8vIEFkZCBkdW1teSBjb21wb3VuZCB0byBwYXJlbnQgdGhlIGdyYXBoXG4gICAgICBwYXJlbnRHcmFwaC5hZGQoZHVtbXlDb21wb3VuZCk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHplcm8gZGVncmVlIG5vZGUgaW4gdGhpcyBsZXZlbCByZW1vdmUgaXQgZnJvbSBpdHMgcGFyZW50IGdyYXBoIGFuZCBhZGQgaXQgdG8gdGhlIGdyYXBoIG9mIGR1bW15IHBhcmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXVtpXTtcblxuICAgICAgICBwYXJlbnRHcmFwaC5yZW1vdmUobm9kZSk7XG4gICAgICAgIGR1bW15UGFyZW50R3JhcGguYWRkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhckNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoaWxkR3JhcGhNYXAgPSB7fTtcbiAgdmFyIGlkVG9Ob2RlID0ge307XG5cbiAgLy8gR2V0IGNvbXBvdW5kIG9yZGVyaW5nIGJ5IGZpbmRpbmcgdGhlIGlubmVyIG9uZSBmaXJzdFxuICB0aGlzLnBlcmZvcm1ERlNPbkNvbXBvdW5kcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wb3VuZE9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZFRvTm9kZVt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gdGhpcy5jb21wb3VuZE9yZGVyW2ldO1xuICAgIGNoaWxkR3JhcGhNYXBbdGhpcy5jb21wb3VuZE9yZGVyW2ldLmlkXSA9IFtdLmNvbmNhdCh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKS5nZXROb2RlcygpKTtcblxuICAgIC8vIFJlbW92ZSBjaGlsZHJlbiBvZiBjb21wb3VuZHNcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUodGhpcy5jb21wb3VuZE9yZGVyW2ldLmdldENoaWxkKCkpO1xuICAgIHRoaXMuY29tcG91bmRPcmRlcltpXS5jaGlsZCA9IG51bGw7XG4gIH1cblxuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG5cbiAgLy8gVGlsZSB0aGUgcmVtb3ZlZCBjaGlsZHJlblxuICB0aGlzLnRpbGVDb21wb3VuZE1lbWJlcnMoY2hpbGRHcmFwaE1hcCwgaWRUb05vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2xlYXJaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGlsZWRaZXJvRGVncmVlUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjayA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKHRoaXMubWVtYmVyR3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBjb21wb3VuZE5vZGUgPSBzZWxmLmlkVG9EdW1teU5vZGVbaWRdOyAvLyBHZXQgdGhlIGR1bW15IGNvbXBvdW5kXG5cbiAgICB0aWxlZFplcm9EZWdyZWVQYWNrW2lkXSA9IHNlbGYudGlsZU5vZGVzKHNlbGYubWVtYmVyR3JvdXBzW2lkXSwgY29tcG91bmROb2RlLnBhZGRpbmdMZWZ0ICsgY29tcG91bmROb2RlLnBhZGRpbmdSaWdodCk7XG5cbiAgICAvLyBTZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGR1bW15IGNvbXBvdW5kIGFzIGNhbGN1bGF0ZWRcbiAgICBjb21wb3VuZE5vZGUucmVjdC53aWR0aCA9IHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLndpZHRoO1xuICAgIGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodCA9IHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmhlaWdodDtcbiAgICBjb21wb3VuZE5vZGUuc2V0Q2VudGVyKHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmNlbnRlclgsIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmNlbnRlclkpO1xuXG4gICAgLy8gY29tcG91bmQgbGVmdCBhbmQgdG9wIG1hcmdpbmdzIGZvciBsYWJlbHNcbiAgICAvLyB3aGVuIG5vZGUgbGFiZWxzIGFyZSBpbmNsdWRlZCwgdGhlc2UgdmFsdWVzIG1heSBiZSBzZXQgdG8gZGlmZmVyZW50IHZhbHVlcyBiZWxvdyBhbmQgYXJlIHVzZWQgaW4gdGlsaW5nUG9zdExheW91dCxcbiAgICAvLyBvdGhlcndpc2UgdGhleSBzdGF5IGFzIHplcm9cbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0ID0gMDtcbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSAwO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyBhbmQgc2V0IGxhYmVsIG1hcmdpbnMgZm9yIGxlZnQgYW5kIHRvcFxuICAgIGlmIChDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjb21wb3VuZE5vZGUucmVjdC53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQ7XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gY29tcG91bmROb2RlLmxhYmVsV2lkdGg7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgoY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueSAtPSAoY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChoZWlnaHQgKyBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVDb21wb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbENvbXBvdW5kTm9kZSA9IHRoaXMuY29tcG91bmRPcmRlcltpXTtcbiAgICB2YXIgaWQgPSBsQ29tcG91bmROb2RlLmlkO1xuICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gbENvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG4gICAgdmFyIGxhYmVsTWFyZ2luTGVmdCA9IGxDb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0O1xuICAgIHZhciBsYWJlbE1hcmdpblRvcCA9IGxDb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3A7XG5cbiAgICB0aGlzLmFkanVzdExvY2F0aW9ucyh0aGlzLnRpbGVkTWVtYmVyUGFja1tpZF0sIGxDb21wb3VuZE5vZGUucmVjdC54LCBsQ29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4sIGxhYmVsTWFyZ2luTGVmdCwgbGFiZWxNYXJnaW5Ub3ApO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRpbGVkUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjaztcblxuICBPYmplY3Qua2V5cyh0aWxlZFBhY2spLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmQgYnkgaXRzIGlkXG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQ7XG4gICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gY29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG4gICAgdmFyIGxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQ7XG4gICAgdmFyIGxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgd3J0IGl0cyBjb21wb3VuZFxuICAgIHNlbGYuYWRqdXN0TG9jYXRpb25zKHRpbGVkUGFja1tpZF0sIGNvbXBvdW5kTm9kZS5yZWN0LngsIGNvbXBvdW5kTm9kZS5yZWN0LnksIGhvcml6b250YWxNYXJnaW4sIHZlcnRpY2FsTWFyZ2luLCBsYWJlbE1hcmdpbkxlZnQsIGxhYmVsTWFyZ2luVG9wKTtcbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRUb0JlVGlsZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICAvL2ZpcnN0bHkgY2hlY2sgdGhlIHByZXZpb3VzIHJlc3VsdHNcbiAgaWYgKHRoaXMudG9CZVRpbGVkW2lkXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CZVRpbGVkW2lkXTtcbiAgfVxuXG4gIC8vb25seSBjb21wb3VuZCBub2RlcyBhcmUgdG8gYmUgdGlsZWRcbiAgdmFyIGNoaWxkR3JhcGggPSBub2RlLmdldENoaWxkKCk7XG4gIGlmIChjaGlsZEdyYXBoID09IG51bGwpIHtcbiAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSBjaGlsZEdyYXBoLmdldE5vZGVzKCk7IC8vIEdldCB0aGUgY2hpbGRyZW4gbm9kZXNcblxuICAvL2EgY29tcG91bmQgbm9kZSBpcyBub3QgdG8gYmUgdGlsZWQgaWYgYWxsIG9mIGl0cyBjb21wb3VuZCBjaGlsZHJlbiBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWUodGhlQ2hpbGQpID4gMCkge1xuICAgICAgdGhpcy50b0JlVGlsZWRbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy9wYXNzIHRoZSBjaGlsZHJlbiBub3QgaGF2aW5nIHRoZSBjb21wb3VuZCBzdHJ1Y3R1cmVcbiAgICBpZiAodGhlQ2hpbGQuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFt0aGVDaGlsZC5pZF0gPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRUb0JlVGlsZWQodGhlQ2hpbGQpKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdGhpcy50b0JlVGlsZWRbaWRdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSBkZXBlbmRpbmcgb2YgaXRzIGVkZ2VzIGFuZCBpbmRlcGVuZGVudCBvZiBpdHMgY2hpbGRyZW5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldE5vZGVEZWdyZWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICB2YXIgZWRnZXMgPSBub2RlLmdldEVkZ2VzKCk7XG4gIHZhciBkZWdyZWUgPSAwO1xuXG4gIC8vIEZvciB0aGUgZWRnZXMgY29ubmVjdGVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIGlmIChlZGdlLmdldFNvdXJjZSgpLmlkICE9PSBlZGdlLmdldFRhcmdldCgpLmlkKSB7XG4gICAgICBkZWdyZWUgPSBkZWdyZWUgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuLy8gR2V0IGRlZ3JlZSBvZiBhIG5vZGUgd2l0aCBpdHMgY2hpbGRyZW5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgZGVncmVlID0gdGhpcy5nZXROb2RlRGVncmVlKG5vZGUpO1xuICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgZGVncmVlICs9IHRoaXMuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbihjaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGRlZ3JlZTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnBlcmZvcm1ERlNPbkNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb21wb3VuZE9yZGVyID0gW107XG4gIHRoaXMuZmlsbENvbXBleE9yZGVyQnlERlModGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZmlsbENvbXBleE9yZGVyQnlERlMgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZC5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZmlsbENvbXBleE9yZGVyQnlERlMoY2hpbGQuZ2V0Q2hpbGQoKS5nZXROb2RlcygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0VG9CZVRpbGVkKGNoaWxkKSkge1xuICAgICAgdGhpcy5jb21wb3VuZE9yZGVyLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIHBsYWNlcyBlYWNoIHplcm8gZGVncmVlIG1lbWJlciB3cnQgZ2l2ZW4gKHgseSkgY29vcmRpbmF0ZXMgKHRvcCBsZWZ0KS5cbiovXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5hZGp1c3RMb2NhdGlvbnMgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCB4LCB5LCBjb21wb3VuZEhvcml6b250YWxNYXJnaW4sIGNvbXBvdW5kVmVydGljYWxNYXJnaW4sIGNvbXBvdW5kTGFiZWxNYXJnaW5MZWZ0LCBjb21wb3VuZExhYmVsTWFyZ2luVG9wKSB7XG4gIHggKz0gY29tcG91bmRIb3Jpem9udGFsTWFyZ2luICsgY29tcG91bmRMYWJlbE1hcmdpbkxlZnQ7XG4gIHkgKz0gY29tcG91bmRWZXJ0aWNhbE1hcmdpbiArIGNvbXBvdW5kTGFiZWxNYXJnaW5Ub3A7XG5cbiAgdmFyIGxlZnQgPSB4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcm93ID0gb3JnYW5pemF0aW9uLnJvd3NbaV07XG4gICAgeCA9IGxlZnQ7XG4gICAgdmFyIG1heEhlaWdodCA9IDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxub2RlID0gcm93W2pdO1xuXG4gICAgICBsbm9kZS5yZWN0LnggPSB4OyAvLyArIGxub2RlLnJlY3Qud2lkdGggLyAyO1xuICAgICAgbG5vZGUucmVjdC55ID0geTsgLy8gKyBsbm9kZS5yZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgIHggKz0gbG5vZGUucmVjdC53aWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgaWYgKGxub2RlLnJlY3QuaGVpZ2h0ID4gbWF4SGVpZ2h0KSBtYXhIZWlnaHQgPSBsbm9kZS5yZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICB5ICs9IG1heEhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVDb21wb3VuZE1lbWJlcnMgPSBmdW5jdGlvbiAoY2hpbGRHcmFwaE1hcCwgaWRUb05vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRpbGVkTWVtYmVyUGFjayA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKGNoaWxkR3JhcGhNYXApLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgLy8gR2V0IHRoZSBjb21wb3VuZCBub2RlXG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IGlkVG9Ob2RlW2lkXTtcblxuICAgIHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXSA9IHNlbGYudGlsZU5vZGVzKGNoaWxkR3JhcGhNYXBbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLndpZHRoO1xuICAgIGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodCA9IHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS5oZWlnaHQ7XG4gICAgY29tcG91bmROb2RlLnNldENlbnRlcihzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uY2VudGVyWCwgc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLmNlbnRlclkpO1xuXG4gICAgLy8gY29tcG91bmQgbGVmdCBhbmQgdG9wIG1hcmdpbmdzIGZvciBsYWJlbHNcbiAgICAvLyB3aGVuIG5vZGUgbGFiZWxzIGFyZSBpbmNsdWRlZCwgdGhlc2UgdmFsdWVzIG1heSBiZSBzZXQgdG8gZGlmZmVyZW50IHZhbHVlcyBiZWxvdyBhbmQgYXJlIHVzZWQgaW4gdGlsaW5nUG9zdExheW91dCxcbiAgICAvLyBvdGhlcndpc2UgdGhleSBzdGF5IGFzIHplcm9cbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0ID0gMDtcbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSAwO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyBhbmQgc2V0IGxhYmVsIG1hcmdpbnMgZm9yIGxlZnQgYW5kIHRvcFxuICAgIGlmIChDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjb21wb3VuZE5vZGUucmVjdC53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQ7XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gY29tcG91bmROb2RlLmxhYmVsV2lkdGg7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgoY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueSAtPSAoY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChoZWlnaHQgKyBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVOb2RlcyA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgpIHtcbiAgdmFyIGhvcml6b250YWxPcmcgPSB0aGlzLnRpbGVOb2Rlc0J5RmF2b3JpbmdEaW0obm9kZXMsIG1pbldpZHRoLCB0cnVlKTtcbiAgdmFyIHZlcnRpY2FsT3JnID0gdGhpcy50aWxlTm9kZXNCeUZhdm9yaW5nRGltKG5vZGVzLCBtaW5XaWR0aCwgZmFsc2UpO1xuXG4gIHZhciBob3Jpem9udGFsUmF0aW8gPSB0aGlzLmdldE9yZ1JhdGlvKGhvcml6b250YWxPcmcpO1xuICB2YXIgdmVydGljYWxSYXRpbyA9IHRoaXMuZ2V0T3JnUmF0aW8odmVydGljYWxPcmcpO1xuICB2YXIgYmVzdE9yZztcblxuICAvLyB0aGUgYmVzdCByYXRpbyBpcyB0aGUgb25lIHRoYXQgaXMgY2xvc2VyIHRvIDEgc2luY2UgdGhlIHJhdGlvcyBhcmUgYWxyZWFkeSBub3JtYWxpemVkXG4gIC8vIGFuZCB0aGUgYmVzdCBvcmdhbml6YXRpb24gaXMgdGhlIG9uZSB0aGF0IGhhcyB0aGUgYmVzdCByYXRpb1xuICBpZiAodmVydGljYWxSYXRpbyA8IGhvcml6b250YWxSYXRpbykge1xuICAgIGJlc3RPcmcgPSB2ZXJ0aWNhbE9yZztcbiAgfSBlbHNlIHtcbiAgICBiZXN0T3JnID0gaG9yaXpvbnRhbE9yZztcbiAgfVxuXG4gIHJldHVybiBiZXN0T3JnO1xufTtcblxuLy8gZ2V0IHRoZSB3aWR0aC9oZWlnaHQgcmF0aW8gb2YgdGhlIG9yZ2FuaXphdGlvbiB0aGF0IGlzIG5vcm1hbGl6ZWQgc28gdGhhdCBpdCB3aWxsIG5vdCBiZSBsZXNzIHRoYW4gMVxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0T3JnUmF0aW8gPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIC8vIGdldCBkaW1lbnNpb25zIGFuZCBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmF0aW9cbiAgdmFyIHdpZHRoID0gb3JnYW5pemF0aW9uLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3JnYW5pemF0aW9uLmhlaWdodDtcbiAgdmFyIHJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG5cbiAgLy8gaWYgdGhlIGluaXRpYWwgcmF0aW8gaXMgbGVzcyB0aGVuIDEgdGhlbiBpbnZlcnNlIGl0XG4gIGlmIChyYXRpbyA8IDEpIHtcbiAgICByYXRpbyA9IDEgLyByYXRpbztcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgbm9ybWFsaXplZCByYXRpb1xuICByZXR1cm4gcmF0aW87XG59O1xuXG4vKlxuICogQ2FsY3VsYXRlcyB0aGUgaWRlYWwgd2lkdGggZm9yIHRoZSByb3dzLiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoYXRcbiAqIGVhY2ggbm9kZSBoYXMgdGhlIHNhbWUgc2l6ZXMgYW5kIGNhbGN1bGF0ZXMgdGhlIGlkZWFsIHJvdyB3aWR0aCB0aGF0XG4gKiBhcHByb3hpbWF0ZXMgYSBzcXVhcmUgc2hhcGVkIGNvbXBsZXggYWNjb3JkaW5nbHkuIEhvd2V2ZXIsIHNpbmNlIG5vZGVzIHdvdWxkXG4gKiBoYXZlIGRpZmZlcmVudCBzaXplcyBzb21lIHJvd3Mgd291bGQgaGF2ZSBkaWZmZXJlbnQgc2l6ZXMgYW5kIHRoZSByZXN1bHRpbmdcbiAqIHNoYXBlIHdvdWxkIG5vdCBiZSBhbiBleGFjdCBzcXVhcmUuXG4gKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNJZGVhbFJvd1dpZHRoID0gZnVuY3Rpb24gKG1lbWJlcnMsIGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICAvLyBUbyBhcHByb3hpbWF0ZSBhIHNxdWFyZSBzaGFwZWQgY29tcGxleCB3ZSBuZWVkIHRvIG1ha2UgY29tcGxleCB3aWR0aCBlcXVhbCB0byBjb21wbGV4IGhlaWdodC5cbiAgLy8gVG8gYWNoaWV2ZSB0aGlzIHdlIG5lZWQgdG8gc29sdmUgdGhlIGZvbGxvd2luZyBlcXVhdGlvbiBzeXN0ZW0gZm9yIGhjOlxuICAvLyAoeCArIGJ4KSAqIGhjIC0gYnggPSAoeSArIGJ5KSAqIHZjIC0gYnksIGhjICogdmMgPSBuXG4gIC8vIHdoZXJlIHggaXMgdGhlIGF2YXJhZ2Ugd2lkdGggb2YgdGhlIG5vZGVzLCB5IGlzIHRoZSBhdmFyYWdlIGhlaWdodCBvZiBub2Rlc1xuICAvLyBieCBhbmQgYnkgYXJlIHRoZSBidWZmZXIgc2l6ZXMgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGltZW5zaW9ucyBhY2NvcmRpbmdseSxcbiAgLy8gaGMgYW5kIHZjIGFyZSB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGltZW5zaW9uc1xuICAvLyBuIGlzIG51bWJlciBvZiBtZW1iZXJzLlxuXG4gIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMO1xuICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUw7XG5cbiAgLy8gbnVtYmVyIG9mIG1lbWJlcnNcbiAgdmFyIG1lbWJlcnNTaXplID0gbWVtYmVycy5sZW5ndGg7XG5cbiAgLy8gc3VtIG9mIHRoZSB3aWR0aCBvZiBhbGwgbWVtYmVyc1xuICB2YXIgdG90YWxXaWR0aCA9IDA7XG5cbiAgLy8gc3VtIG9mIHRoZSBoZWlnaHQgb2YgYWxsIG1lbWJlcnNcbiAgdmFyIHRvdGFsSGVpZ2h0ID0gMDtcblxuICB2YXIgbWF4V2lkdGggPSAwO1xuXG4gIC8vIHRyYXZlcnNlIGFsbCBtZW1iZXJzIHRvIGNhbGN1bGF0ZSB0b3RhbCB3aWR0aCBhbmQgdG90YWwgaGVpZ2h0IGFuZCBnZXQgdGhlIG1heGltdW0gbWVtYmVycyB3aWR0aFxuICBtZW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB0b3RhbFdpZHRoICs9IG5vZGUuZ2V0V2lkdGgoKTtcbiAgICB0b3RhbEhlaWdodCArPSBub2RlLmdldEhlaWdodCgpO1xuXG4gICAgaWYgKG5vZGUuZ2V0V2lkdGgoKSA+IG1heFdpZHRoKSB7XG4gICAgICBtYXhXaWR0aCA9IG5vZGUuZ2V0V2lkdGgoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGF2ZXJhZ2Ugd2lkdGggb2YgdGhlIG1lbWJlcnNcbiAgdmFyIGF2ZXJhZ2VXaWR0aCA9IHRvdGFsV2lkdGggLyBtZW1iZXJzU2l6ZTtcblxuICAvLyBhdmVyYWdlIGhlaWdodCBvZiB0aGUgbWVtYmVyc1xuICB2YXIgYXZlcmFnZUhlaWdodCA9IHRvdGFsSGVpZ2h0IC8gbWVtYmVyc1NpemU7XG5cbiAgLy8gc29sdmluZyB0aGUgaW5pdGlhbCBlcXVhdGlvbiBzeXN0ZW0gZm9yIHRoZSBoYyB5aWVsZHMgdGhlIGZvbGxvd2luZyBzZWNvbmQgZGVncmVlIGVxdWF0aW9uOlxuICAvLyBoY14yICogKHgrYngpICsgaGMgKiAoYnkgLSBieCkgLSBuICogKHkgKyBieSkgPSAwXG5cbiAgLy8gdGhlIGRlbHRhIHZhbHVlIHRvIHNvbHZlIHRoZSBlcXVhdGlvbiBhYm92ZSBmb3IgaGNcbiAgdmFyIGRlbHRhID0gTWF0aC5wb3codmVydGljYWxQYWRkaW5nIC0gaG9yaXpvbnRhbFBhZGRpbmcsIDIpICsgNCAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykgKiAoYXZlcmFnZUhlaWdodCArIHZlcnRpY2FsUGFkZGluZykgKiBtZW1iZXJzU2l6ZTtcblxuICAvLyBzb2x2ZSB0aGUgZXF1YXRpb24gdXNpbmcgZGVsdGEgdmFsdWUgdG8gY2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGNvdW50XG4gIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIGFuIGlkZWFsIHJvd1xuICB2YXIgaG9yaXpvbnRhbENvdW50RG91YmxlID0gKGhvcml6b250YWxQYWRkaW5nIC0gdmVydGljYWxQYWRkaW5nICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykpO1xuICAvLyByb3VuZCB0aGUgY2FsY3VsYXRlZCBob3Jpem9udGFsIGNvdW50IHVwIG9yIGRvd24gYWNjb3JkaW5nIHRvIHRoZSBmYXZvcmVkIGRpbWVuc2lvblxuICB2YXIgaG9yaXpvbnRhbENvdW50O1xuXG4gIGlmIChmYXZvckhvcml6b250YWxEaW0pIHtcbiAgICBob3Jpem9udGFsQ291bnQgPSBNYXRoLmNlaWwoaG9yaXpvbnRhbENvdW50RG91YmxlKTtcbiAgICAvLyBpZiBob3Jpem9udGFsQ291bnQgY291bnQgaXMgbm90IGEgZmxvYXQgdmFsdWUgdGhlbiBib3RoIG9mIHJvdW5kaW5nIHRvIGZsb29yIGFuZCBjZWlsXG4gICAgLy8gd2lsbCB5aWVsZCB0aGUgc2FtZSB2YWx1ZXMuIEluc3RlYWQgb2YgcmVwZWF0aW5nIHRoZSBzYW1lIGNhbGN1bGF0aW9uIHRyeSBnb2luZyB1cFxuICAgIC8vIHdoaWxlIGZhdm9yaW5nIGhvcml6b250YWwgZGltZW5zaW9uIGluIHN1Y2ggY2FzZXNcbiAgICBpZiAoaG9yaXpvbnRhbENvdW50ID09IGhvcml6b250YWxDb3VudERvdWJsZSkge1xuICAgICAgaG9yaXpvbnRhbENvdW50Kys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhvcml6b250YWxDb3VudCA9IE1hdGguZmxvb3IoaG9yaXpvbnRhbENvdW50RG91YmxlKTtcbiAgfVxuXG4gIC8vIGlkZWFsIHdpZHRoIHRvIGJlIGNhbGN1bGF0ZWRcbiAgdmFyIGlkZWFsV2lkdGggPSBob3Jpem9udGFsQ291bnQgKiAoYXZlcmFnZVdpZHRoICsgaG9yaXpvbnRhbFBhZGRpbmcpIC0gaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgLy8gaWYgbWF4IHdpZHRoIGlzIGJpZ2dlciB0aGFuIGNhbGN1bGF0ZWQgaWRlYWwgd2lkdGggcmVzZXQgaWRlYWwgd2lkdGggdG8gaXRcbiAgaWYgKG1heFdpZHRoID4gaWRlYWxXaWR0aCkge1xuICAgIGlkZWFsV2lkdGggPSBtYXhXaWR0aDtcbiAgfVxuXG4gIC8vIGFkZCB0aGUgbGVmdC1yaWdodCBtYXJnaW5zIHRvIHRoZSBpZGVhbCByb3cgd2lkdGhcbiAgaWRlYWxXaWR0aCArPSBob3Jpem9udGFsUGFkZGluZyAqIDI7XG5cbiAgLy8gcmV0dXJuIHRoZSBpZGVhbCByb3cgd2lkdGgxXG4gIHJldHVybiBpZGVhbFdpZHRoO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZU5vZGVzQnlGYXZvcmluZ0RpbSA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgsIGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICB2YXIgdmVydGljYWxQYWRkaW5nID0gQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTDtcbiAgdmFyIGhvcml6b250YWxQYWRkaW5nID0gQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19IT1JJWk9OVEFMO1xuICB2YXIgdGlsaW5nQ29tcGFyZUJ5ID0gQ29TRUNvbnN0YW50cy5USUxJTkdfQ09NUEFSRV9CWTtcbiAgdmFyIG9yZ2FuaXphdGlvbiA9IHtcbiAgICByb3dzOiBbXSxcbiAgICByb3dXaWR0aDogW10sXG4gICAgcm93SGVpZ2h0OiBbXSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IG1pbldpZHRoLCAvLyBhc3N1bWUgbWluSGVpZ2h0IGVxdWFscyB0byBtaW5XaWR0aFxuICAgIHZlcnRpY2FsUGFkZGluZzogdmVydGljYWxQYWRkaW5nLFxuICAgIGhvcml6b250YWxQYWRkaW5nOiBob3Jpem9udGFsUGFkZGluZyxcbiAgICBjZW50ZXJYOiAwLFxuICAgIGNlbnRlclk6IDBcbiAgfTtcblxuICBpZiAodGlsaW5nQ29tcGFyZUJ5KSB7XG4gICAgb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGggPSB0aGlzLmNhbGNJZGVhbFJvd1dpZHRoKG5vZGVzLCBmYXZvckhvcml6b250YWxEaW0pO1xuICB9XG5cbiAgdmFyIGdldE5vZGVBcmVhID0gZnVuY3Rpb24gZ2V0Tm9kZUFyZWEobikge1xuICAgIHJldHVybiBuLnJlY3Qud2lkdGggKiBuLnJlY3QuaGVpZ2h0O1xuICB9O1xuXG4gIHZhciBhcmVhQ29tcGFyZUZjbiA9IGZ1bmN0aW9uIGFyZWFDb21wYXJlRmNuKG4xLCBuMikge1xuICAgIHJldHVybiBnZXROb2RlQXJlYShuMikgLSBnZXROb2RlQXJlYShuMSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgbm9kZXMgaW4gZGVzY2VuZGluZyBvcmRlciBvZiB0aGVpciBhcmVhc1xuICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChuMSwgbjIpIHtcbiAgICB2YXIgY21wQnkgPSBhcmVhQ29tcGFyZUZjbjtcbiAgICBpZiAob3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICAgIGNtcEJ5ID0gdGlsaW5nQ29tcGFyZUJ5O1xuICAgICAgcmV0dXJuIGNtcEJ5KG4xLmlkLCBuMi5pZCk7XG4gICAgfVxuICAgIHJldHVybiBjbXBCeShuMSwgbjIpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIG9yZ2FuaXphdGlvbiAtPiBjYWxjdWxhdGUgY29tcG91bmQgY2VudGVyXG4gIHZhciBzdW1DZW50ZXJYID0gMDtcbiAgdmFyIHN1bUNlbnRlclkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBzdW1DZW50ZXJYICs9IGxOb2RlLmdldENlbnRlclgoKTtcbiAgICBzdW1DZW50ZXJZICs9IGxOb2RlLmdldENlbnRlclkoKTtcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5jZW50ZXJYID0gc3VtQ2VudGVyWCAvIG5vZGVzLmxlbmd0aDtcbiAgb3JnYW5pemF0aW9uLmNlbnRlclkgPSBzdW1DZW50ZXJZIC8gbm9kZXMubGVuZ3RoO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IHRpbGUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIDAsIG1pbldpZHRoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FuQWRkSG9yaXpvbnRhbChvcmdhbml6YXRpb24sIGxOb2RlLnJlY3Qud2lkdGgsIGxOb2RlLnJlY3QuaGVpZ2h0KSkge1xuICAgICAgdmFyIHJvd0luZGV4ID0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoIC0gMTtcbiAgICAgIGlmICghb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICAgICAgcm93SW5kZXggPSB0aGlzLmdldFNob3J0ZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aCwgbWluV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMuc2hpZnRUb0xhc3RSb3cob3JnYW5pemF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBvcmdhbml6YXRpb247XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbnNlcnROb2RlVG9Sb3cgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCBub2RlLCByb3dJbmRleCwgbWluV2lkdGgpIHtcbiAgdmFyIG1pbkNvbXBvdW5kU2l6ZSA9IG1pbldpZHRoO1xuXG4gIC8vIEFkZCBuZXcgcm93IGlmIG5lZWRlZFxuICBpZiAocm93SW5kZXggPT0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoKSB7XG4gICAgdmFyIHNlY29uZERpbWVuc2lvbiA9IFtdO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd3MucHVzaChzZWNvbmREaW1lbnNpb24pO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aC5wdXNoKG1pbkNvbXBvdW5kU2l6ZSk7XG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodC5wdXNoKDApO1xuICB9XG5cbiAgLy8gVXBkYXRlIHJvdyB3aWR0aFxuICB2YXIgdyA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gKyBub2RlLnJlY3Qud2lkdGg7XG5cbiAgaWYgKG9yZ2FuaXphdGlvbi5yb3dzW3Jvd0luZGV4XS5sZW5ndGggPiAwKSB7XG4gICAgdyArPSBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG4gIH1cblxuICBvcmdhbml6YXRpb24ucm93V2lkdGhbcm93SW5kZXhdID0gdztcbiAgLy8gVXBkYXRlIGNvbXBvdW5kIHdpZHRoXG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggPCB3KSB7XG4gICAgb3JnYW5pemF0aW9uLndpZHRoID0gdztcbiAgfVxuXG4gIC8vIFVwZGF0ZSBoZWlnaHRcbiAgdmFyIGggPSBub2RlLnJlY3QuaGVpZ2h0O1xuICBpZiAocm93SW5kZXggPiAwKSBoICs9IG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgdmFyIGV4dHJhSGVpZ2h0ID0gMDtcbiAgaWYgKGggPiBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSkge1xuICAgIGV4dHJhSGVpZ2h0ID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF07XG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0gPSBoO1xuICAgIGV4dHJhSGVpZ2h0ID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0gLSBleHRyYUhlaWdodDtcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5oZWlnaHQgKz0gZXh0cmFIZWlnaHQ7XG5cbiAgLy8gSW5zZXJ0IG5vZGVcbiAgb3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLnB1c2gobm9kZSk7XG59O1xuXG4vL1NjYW5zIHRoZSByb3dzIG9mIGFuIG9yZ2FuaXphdGlvbiBhbmQgcmV0dXJucyB0aGUgb25lIHdpdGggdGhlIG1pbiB3aWR0aFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0U2hvcnRlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvcmdhbml6YXRpb24ucm93V2lkdGhbaV0gPCBtaW4pIHtcbiAgICAgIHIgPSBpO1xuICAgICAgbWluID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWF4IHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRMb25nZXN0Um93SW5kZXggPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciByID0gLTE7XG4gIHZhciBtYXggPSBOdW1iZXIuTUlOX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcblxuICAgIGlmIChvcmdhbml6YXRpb24ucm93V2lkdGhbaV0gPiBtYXgpIHtcbiAgICAgIHIgPSBpO1xuICAgICAgbWF4ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGFkZGluZyBleHRyYSB3aWR0aCB0byB0aGUgb3JnYW5pemF0aW9uIHZpb2xhdGVzXG4qIHRoZSBhc3BlY3QgcmF0aW8oMSkgb3Igbm90LlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbkFkZEhvcml6b250YWwgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCBleHRyYVdpZHRoLCBleHRyYUhlaWdodCkge1xuXG4gIC8vIGlmIHRoZXJlIGlzIGFuIGlkZWFsIHJvdyB3aWR0aCBzcGVjaWZpZWQgdXNlIGl0IGluc3RlYWQgb2YgY2hlY2tpbmcgdGhlIGFzcGVjdCByYXRpb1xuICBpZiAob3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICB2YXIgbGFzdFJvd0luZGV4ID0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoIC0gMTtcbiAgICB2YXIgbGFzdFJvd1dpZHRoID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RSb3dJbmRleF07XG5cbiAgICAvLyBjaGVjayBhbmQgcmV0dXJuIGlmIGlkZWFsIHJvdyB3aWR0aCB3aWxsIGJlIGV4Y2VlZCBpZiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcm93XG4gICAgcmV0dXJuIGxhc3RSb3dXaWR0aCArIGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcgPD0gb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGg7XG4gIH1cblxuICB2YXIgc3JpID0gdGhpcy5nZXRTaG9ydGVzdFJvd0luZGV4KG9yZ2FuaXphdGlvbik7XG5cbiAgaWYgKHNyaSA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbc3JpXTtcblxuICBpZiAobWluICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nICsgZXh0cmFXaWR0aCA8PSBvcmdhbml6YXRpb24ud2lkdGgpIHJldHVybiB0cnVlO1xuXG4gIHZhciBoRGlmZiA9IDA7XG5cbiAgLy8gQWRkaW5nIHRvIGFuIGV4aXN0aW5nIHJvd1xuICBpZiAob3JnYW5pemF0aW9uLnJvd0hlaWdodFtzcmldIDwgZXh0cmFIZWlnaHQpIHtcbiAgICBpZiAoc3JpID4gMCkgaERpZmYgPSBleHRyYUhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmcgLSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3NyaV07XG4gIH1cblxuICB2YXIgYWRkX3RvX3Jvd19yYXRpbztcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCAtIG1pbiA+PSBleHRyYVdpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nKSB7XG4gICAgYWRkX3RvX3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gKG1pbiArIGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcpO1xuICB9IGVsc2Uge1xuICAgIGFkZF90b19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIG9yZ2FuaXphdGlvbi53aWR0aDtcbiAgfVxuXG4gIC8vIEFkZGluZyBhIG5ldyByb3cgZm9yIHRoaXMgbm9kZVxuICBoRGlmZiA9IGV4dHJhSGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcbiAgdmFyIGFkZF9uZXdfcm93X3JhdGlvO1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIDwgZXh0cmFXaWR0aCkge1xuICAgIGFkZF9uZXdfcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBleHRyYVdpZHRoO1xuICB9IGVsc2Uge1xuICAgIGFkZF9uZXdfcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBvcmdhbml6YXRpb24ud2lkdGg7XG4gIH1cblxuICBpZiAoYWRkX25ld19yb3dfcmF0aW8gPCAxKSBhZGRfbmV3X3Jvd19yYXRpbyA9IDEgLyBhZGRfbmV3X3Jvd19yYXRpbztcblxuICBpZiAoYWRkX3RvX3Jvd19yYXRpbyA8IDEpIGFkZF90b19yb3dfcmF0aW8gPSAxIC8gYWRkX3RvX3Jvd19yYXRpbztcblxuICByZXR1cm4gYWRkX3RvX3Jvd19yYXRpbyA8IGFkZF9uZXdfcm93X3JhdGlvO1xufTtcblxuLy9JZiBtb3ZpbmcgdGhlIGxhc3Qgbm9kZSBmcm9tIHRoZSBsb25nZXN0IHJvdyBhbmQgYWRkaW5nIGl0IHRvIHRoZSBsYXN0XG4vL3JvdyBtYWtlcyB0aGUgYm91bmRpbmcgYm94IHNtYWxsZXIsIGRvIGl0LlxuQ29TRUxheW91dC5wcm90b3R5cGUuc2hpZnRUb0xhc3RSb3cgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciBsb25nZXN0ID0gdGhpcy5nZXRMb25nZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcbiAgdmFyIGxhc3QgPSBvcmdhbml6YXRpb24ucm93V2lkdGgubGVuZ3RoIC0gMTtcbiAgdmFyIHJvdyA9IG9yZ2FuaXphdGlvbi5yb3dzW2xvbmdlc3RdO1xuICB2YXIgbm9kZSA9IHJvd1tyb3cubGVuZ3RoIC0gMV07XG5cbiAgdmFyIGRpZmYgPSBub2RlLndpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuXG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBvbiB0aGUgbGFzdCByb3dcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCAtIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSA+IGRpZmYgJiYgbG9uZ2VzdCAhPSBsYXN0KSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvbmdlc3Qgcm93XG4gICAgcm93LnNwbGljZSgtMSwgMSk7XG5cbiAgICAvLyBQdXNoIGl0IHRvIHRoZSBsYXN0IHJvd1xuICAgIG9yZ2FuaXphdGlvbi5yb3dzW2xhc3RdLnB1c2gobm9kZSk7XG5cbiAgICBvcmdhbml6YXRpb24ucm93V2lkdGhbbG9uZ2VzdF0gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbG9uZ2VzdF0gLSBkaWZmO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSArIGRpZmY7XG4gICAgb3JnYW5pemF0aW9uLndpZHRoID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2luc3RhbmNlLmdldExvbmdlc3RSb3dJbmRleChvcmdhbml6YXRpb24pXTtcblxuICAgIC8vIFVwZGF0ZSBoZWlnaHRzIG9mIHRoZSBvcmdhbml6YXRpb25cbiAgICB2YXIgbWF4SGVpZ2h0ID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJvd1tpXS5oZWlnaHQgPiBtYXhIZWlnaHQpIG1heEhlaWdodCA9IHJvd1tpXS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmIChsb25nZXN0ID4gMCkgbWF4SGVpZ2h0ICs9IG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgICB2YXIgcHJldlRvdGFsID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSArIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF07XG5cbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdID0gbWF4SGVpZ2h0O1xuICAgIGlmIChvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdIDwgbm9kZS5oZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nKSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdID0gbm9kZS5oZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuXG4gICAgdmFyIGZpbmFsVG90YWwgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdICsgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XTtcbiAgICBvcmdhbml6YXRpb24uaGVpZ2h0ICs9IGZpbmFsVG90YWwgLSBwcmV2VG90YWw7XG5cbiAgICB0aGlzLnNoaWZ0VG9MYXN0Um93KG9yZ2FuaXphdGlvbik7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGluZ1ByZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKENvU0VDb25zdGFudHMuVElMRSkge1xuICAgIC8vIEZpbmQgemVybyBkZWdyZWUgbm9kZXMgYW5kIGNyZWF0ZSBhIGNvbXBvdW5kIGZvciBlYWNoIGxldmVsXG4gICAgdGhpcy5ncm91cFplcm9EZWdyZWVNZW1iZXJzKCk7XG4gICAgLy8gVGlsZSBhbmQgY2xlYXIgY2hpbGRyZW4gb2YgZWFjaCBjb21wb3VuZFxuICAgIHRoaXMuY2xlYXJDb21wb3VuZHMoKTtcbiAgICAvLyBTZXBhcmF0ZWx5IHRpbGUgYW5kIGNsZWFyIHplcm8gZGVncmVlIG5vZGVzIGZvciBlYWNoIGxldmVsXG4gICAgdGhpcy5jbGVhclplcm9EZWdyZWVNZW1iZXJzKCk7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGluZ1Bvc3RMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChDb1NFQ29uc3RhbnRzLlRJTEUpIHtcbiAgICB0aGlzLnJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycygpO1xuICAgIHRoaXMucmVwb3B1bGF0ZUNvbXBvdW5kcygpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogVHJlZSBSZWR1Y3Rpb24gbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlZHVjZSB0cmVlcyBcbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlZHVjZVRyZWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJ1bmVkTm9kZXNBbGwgPSBbXTtcbiAgdmFyIGNvbnRhaW5zTGVhZiA9IHRydWU7XG4gIHZhciBub2RlO1xuXG4gIHdoaWxlIChjb250YWluc0xlYWYpIHtcbiAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcFRlbXAgPSBbXTtcbiAgICBjb250YWluc0xlYWYgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldEVkZ2VzKCkubGVuZ3RoID09IDEgJiYgIW5vZGUuZ2V0RWRnZXMoKVswXS5pc0ludGVyR3JhcGggJiYgbm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgICAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkge1xuICAgICAgICAgIHZhciBvdGhlckVuZCA9IG5vZGUuZ2V0RWRnZXMoKVswXS5nZXRPdGhlckVuZChub2RlKTtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IG5ldyBEaW1lbnNpb25EKG5vZGUuZ2V0Q2VudGVyWCgpIC0gb3RoZXJFbmQuZ2V0Q2VudGVyWCgpLCBub2RlLmdldENlbnRlclkoKSAtIG90aGVyRW5kLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLnB1c2goW25vZGUsIG5vZGUuZ2V0RWRnZXMoKVswXSwgbm9kZS5nZXRPd25lcigpLCByZWxhdGl2ZVBvc2l0aW9uXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLnB1c2goW25vZGUsIG5vZGUuZ2V0RWRnZXMoKVswXSwgbm9kZS5nZXRPd25lcigpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbnNMZWFmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zTGVhZiA9PSB0cnVlKSB7XG4gICAgICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXAgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0uZ2V0RWRnZXMoKS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwLnB1c2gocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdKTtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0uZ2V0T3duZXIoKS5yZW1vdmUocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJ1bmVkTm9kZXNBbGwucHVzaChwcnVuZWROb2Rlc0luU3RlcCk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbEVkZ2VzKCk7XG4gICAgfVxuICB9XG4gIHRoaXMucHJ1bmVkTm9kZXNBbGwgPSBwcnVuZWROb2Rlc0FsbDtcbn07XG5cbi8vIEdyb3cgdHJlZSBvbmUgc3RlcCBcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdyb3dUcmVlID0gZnVuY3Rpb24gKHBydW5lZE5vZGVzQWxsKSB7XG4gIHZhciBsZW5ndGhPZlBydW5lZE5vZGVzSW5TdGVwID0gcHJ1bmVkTm9kZXNBbGwubGVuZ3RoO1xuICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbFtsZW5ndGhPZlBydW5lZE5vZGVzSW5TdGVwIC0gMV07XG5cbiAgdmFyIG5vZGVEYXRhO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBydW5lZE5vZGVzSW5TdGVwLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZURhdGEgPSBwcnVuZWROb2Rlc0luU3RlcFtpXTtcblxuICAgIHRoaXMuZmluZFBsYWNlZm9yUHJ1bmVkTm9kZShub2RlRGF0YSk7XG5cbiAgICBub2RlRGF0YVsyXS5hZGQobm9kZURhdGFbMF0pO1xuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVsxXSwgbm9kZURhdGFbMV0uc291cmNlLCBub2RlRGF0YVsxXS50YXJnZXQpO1xuICB9XG5cbiAgcHJ1bmVkTm9kZXNBbGwuc3BsaWNlKHBydW5lZE5vZGVzQWxsLmxlbmd0aCAtIDEsIDEpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbn07XG5cbi8vIEZpbmQgYW4gYXBwcm9wcmlhdGUgcG9zaXRpb24gdG8gcmVwbGFjZSBwcnVuZWQgbm9kZSwgdGhpcyBtZXRob2QgY2FuIGJlIGltcHJvdmVkXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maW5kUGxhY2Vmb3JQcnVuZWROb2RlID0gZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG5cbiAgdmFyIGdyaWRGb3JQcnVuZWROb2RlO1xuICB2YXIgbm9kZVRvQ29ubmVjdDtcbiAgdmFyIHBydW5lZE5vZGUgPSBub2RlRGF0YVswXTtcbiAgaWYgKHBydW5lZE5vZGUgPT0gbm9kZURhdGFbMV0uc291cmNlKSB7XG4gICAgbm9kZVRvQ29ubmVjdCA9IG5vZGVEYXRhWzFdLnRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0uc291cmNlO1xuICB9XG5cbiAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpICsgbm9kZURhdGFbM10uZ2V0V2lkdGgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgKyBub2RlRGF0YVszXS5nZXRIZWlnaHQoKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YXJ0R3JpZFggPSBub2RlVG9Db25uZWN0LnN0YXJ0WDtcbiAgICB2YXIgZmluaXNoR3JpZFggPSBub2RlVG9Db25uZWN0LmZpbmlzaFg7XG4gICAgdmFyIHN0YXJ0R3JpZFkgPSBub2RlVG9Db25uZWN0LnN0YXJ0WTtcbiAgICB2YXIgZmluaXNoR3JpZFkgPSBub2RlVG9Db25uZWN0LmZpbmlzaFk7XG5cbiAgICB2YXIgdXBOb2RlQ291bnQgPSAwO1xuICAgIHZhciBkb3duTm9kZUNvdW50ID0gMDtcbiAgICB2YXIgcmlnaHROb2RlQ291bnQgPSAwO1xuICAgIHZhciBsZWZ0Tm9kZUNvdW50ID0gMDtcbiAgICB2YXIgY29udHJvbFJlZ2lvbnMgPSBbdXBOb2RlQ291bnQsIHJpZ2h0Tm9kZUNvdW50LCBkb3duTm9kZUNvdW50LCBsZWZ0Tm9kZUNvdW50XTtcblxuICAgIGlmIChzdGFydEdyaWRZID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFg7IGkgPD0gZmluaXNoR3JpZFg7IGkrKykge1xuICAgICAgICBjb250cm9sUmVnaW9uc1swXSArPSB0aGlzLmdyaWRbaV1bc3RhcnRHcmlkWSAtIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZXS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmluaXNoR3JpZFggPCB0aGlzLmdyaWQubGVuZ3RoIC0gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgICBjb250cm9sUmVnaW9uc1sxXSArPSB0aGlzLmdyaWRbZmluaXNoR3JpZFggKyAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbZmluaXNoR3JpZFhdW2ldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaW5pc2hHcmlkWSA8IHRoaXMuZ3JpZFswXS5sZW5ndGggLSAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWDsgaSA8PSBmaW5pc2hHcmlkWDsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzJdICs9IHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWSArIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0R3JpZFggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWTsgaSA8PSBmaW5pc2hHcmlkWTsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzNdICs9IHRoaXMuZ3JpZFtzdGFydEdyaWRYIC0gMV1baV0ubGVuZ3RoICsgdGhpcy5ncmlkW3N0YXJ0R3JpZFhdW2ldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtaW4gPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWluQ291bnQ7XG4gICAgdmFyIG1pbkluZGV4O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29udHJvbFJlZ2lvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChjb250cm9sUmVnaW9uc1tqXSA8IG1pbikge1xuICAgICAgICBtaW4gPSBjb250cm9sUmVnaW9uc1tqXTtcbiAgICAgICAgbWluQ291bnQgPSAxO1xuICAgICAgICBtaW5JbmRleCA9IGo7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zW2pdID09IG1pbikge1xuICAgICAgICBtaW5Db3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW5Db3VudCA9PSAzICYmIG1pbiA9PSAwKSB7XG4gICAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluQ291bnQgPT0gMiAmJiBtaW4gPT0gMCkge1xuICAgICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIpO1xuICAgICAgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCkge1xuICAgICAgICA7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1pbkNvdW50ID09IDQgJiYgbWluID09IDApIHtcbiAgICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KTtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gcmFuZG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IG1pbkluZGV4O1xuICAgIH1cblxuICAgIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAwKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgLSBub2RlVG9Db25uZWN0LmdldEhlaWdodCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldEhlaWdodCgpIC8gMik7XG4gICAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAxKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSArIG5vZGVUb0Nvbm5lY3QuZ2V0V2lkdGgoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRXaWR0aCgpIC8gMiwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkpO1xuICAgIH0gZWxzZSBpZiAoZ3JpZEZvclBydW5lZE5vZGUgPT0gMikge1xuICAgICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCksIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpICsgbm9kZVRvQ29ubmVjdC5nZXRIZWlnaHQoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRIZWlnaHQoKSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0V2lkdGgoKSAvIDIgLSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC0gcHJ1bmVkTm9kZS5nZXRXaWR0aCgpIC8gMiwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFTGF5b3V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dE5vZGU7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSU1hdGg7XG5cbmZ1bmN0aW9uIENvU0VOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZS5jYWxsKHRoaXMsIGdtLCBsb2MsIHNpemUsIHZOb2RlKTtcbn1cblxuQ29TRU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGRExheW91dE5vZGUucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXROb2RlKSB7XG4gIENvU0VOb2RlW3Byb3BdID0gRkRMYXlvdXROb2RlW3Byb3BdO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUuY2FsY3VsYXRlRGlzcGxhY2VtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGF5b3V0ID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0TGF5b3V0KCk7XG4gIC8vIHRoaXMgY2hlY2sgaXMgZm9yIGNvbXBvdW5kIG5vZGVzIHRoYXQgY29udGFpbiBmaXhlZCBub2Rlc1xuICBpZiAodGhpcy5nZXRDaGlsZCgpICE9IG51bGwgJiYgdGhpcy5maXhlZE5vZGVXZWlnaHQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFggKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVggKyB0aGlzLnJlcHVsc2lvbkZvcmNlWCArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVgpIC8gdGhpcy5maXhlZE5vZGVXZWlnaHQ7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRZICs9IGxheW91dC5jb29saW5nRmFjdG9yICogKHRoaXMuc3ByaW5nRm9yY2VZICsgdGhpcy5yZXB1bHNpb25Gb3JjZVkgKyB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZKSAvIHRoaXMuZml4ZWROb2RlV2VpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5ub09mQ2hpbGRyZW47XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRYKSA+IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFggPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50ICogSU1hdGguc2lnbih0aGlzLmRpc3BsYWNlbWVudFgpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WSkgPiBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRZID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCAqIElNYXRoLnNpZ24odGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuXG4gIC8vIG5vbi1lbXB0eSBjb21wb3VuZCBub2RlLCBwcm9wb2dhdGUgbW92ZW1lbnQgdG8gY2hpbGRyZW4gYXMgd2VsbFxuICBpZiAodGhpcy5jaGlsZCAmJiB0aGlzLmNoaWxkLmdldE5vZGVzKCkubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbih0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuID0gZnVuY3Rpb24gKGRYLCBkWSkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgdmFyIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRpc3BsYWNlbWVudFggKz0gZFg7XG4gICAgICBub2RlLmRpc3BsYWNlbWVudFkgKz0gZFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbihkWCwgZFkpO1xuICAgIH1cbiAgfVxufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcblxuICAvLyBhIHNpbXBsZSBub2RlIG9yIGFuIGVtcHR5IGNvbXBvdW5kIG5vZGUsIG1vdmUgaXRcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCB8fCB0aGlzLmNoaWxkLmdldE5vZGVzKCkubGVuZ3RoID09IDApIHtcbiAgICB0aGlzLm1vdmVCeSh0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG5cbiAgICBsYXlvdXQudG90YWxEaXNwbGFjZW1lbnQgKz0gTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRYKSArIE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cblxuICB0aGlzLnNwcmluZ0ZvcmNlWCA9IDA7XG4gIHRoaXMuc3ByaW5nRm9yY2VZID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVggPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVggPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5zZXRQcmVkMSA9IGZ1bmN0aW9uIChwcmVkMSkge1xuICB0aGlzLnByZWQxID0gcHJlZDE7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0UHJlZDEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQyO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLm5leHQgPSBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByb2Nlc3NlZCA9IGZ1bmN0aW9uIChwcm9jZXNzZWQpIHtcbiAgdGhpcy5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuaXNQcm9jZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcm9jZXNzZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VOb2RlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTAyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDYpO1xudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGlua2VkTGlzdDtcbnZhciBNYXRyaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTWF0cml4O1xudmFyIFNWRCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5TVkQ7XG5cbmZ1bmN0aW9uIENvbnN0cmFpbnRIYW5kbGVyKCkge31cblxuQ29uc3RyYWludEhhbmRsZXIuaGFuZGxlQ29uc3RyYWludHMgPSBmdW5jdGlvbiAobGF5b3V0KSB7XG4gIC8vICBsZXQgbGF5b3V0ID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0TGF5b3V0KCk7XG5cbiAgLy8gZ2V0IGNvbnN0cmFpbnRzIGZyb20gbGF5b3V0XG4gIHZhciBjb25zdHJhaW50cyA9IHt9O1xuICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ID0gbGF5b3V0LmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQ7XG4gIGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludDtcbiAgY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50ID0gbGF5b3V0LmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDtcblxuICB2YXIgaWRUb05vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBub2RlSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgdmFyIHhDb29yZHMgPSBbXTtcbiAgdmFyIHlDb29yZHMgPSBbXTtcblxuICB2YXIgYWxsTm9kZXMgPSBsYXlvdXQuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgLy8gZmlsbCBpbmRleCBtYXAgYW5kIGNvb3JkaW5hdGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgbm9kZUluZGV4ZXMuc2V0KG5vZGUuaWQsIGluZGV4KyspO1xuICAgICAgeENvb3Jkcy5wdXNoKG5vZGUuZ2V0Q2VudGVyWCgpKTtcbiAgICAgIHlDb29yZHMucHVzaChub2RlLmdldENlbnRlclkoKSk7XG4gICAgICBpZFRvTm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgZXhpc3RzIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50IHdpdGhvdXQgZ2FwIHZhbHVlLCBzZXQgaXQgdG8gZGVmYXVsdCBcbiAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICBpZiAoIWNvbnN0cmFpbnQuZ2FwICYmIGNvbnN0cmFpbnQuZ2FwICE9IDApIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIGNvbnN0cmFpbnQuZ2FwID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgaWRUb05vZGVNYXAuZ2V0KGNvbnN0cmFpbnQubGVmdCkuZ2V0V2lkdGgoKSAvIDIgKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC5yaWdodCkuZ2V0V2lkdGgoKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3RyYWludC5nYXAgPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC50b3ApLmdldEhlaWdodCgpIC8gMiArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LmJvdHRvbSkuZ2V0SGVpZ2h0KCkgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiBhdXhpbGlhcnkgZnVuY3Rpb25zICovXG5cbiAgLy8gY2FsY3VsYXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gcG9zaXRpb24gb2JqZWN0c1xuICB2YXIgY2FsY3VsYXRlUG9zaXRpb25EaWZmID0gZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25EaWZmKHBvczEsIHBvczIpIHtcbiAgICByZXR1cm4geyB4OiBwb3MxLnggLSBwb3MyLngsIHk6IHBvczEueSAtIHBvczIueSB9O1xuICB9O1xuXG4gIC8vIGNhbGN1bGF0ZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBub2Rlc1xuICB2YXIgY2FsY3VsYXRlQXZnUG9zaXRpb24gPSBmdW5jdGlvbiBjYWxjdWxhdGVBdmdQb3NpdGlvbihub2RlSWRTZXQpIHtcbiAgICB2YXIgeFBvc1N1bSA9IDA7XG4gICAgdmFyIHlQb3NTdW0gPSAwO1xuICAgIG5vZGVJZFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgIHhQb3NTdW0gKz0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgICB5UG9zU3VtICs9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgeDogeFBvc1N1bSAvIG5vZGVJZFNldC5zaXplLCB5OiB5UG9zU3VtIC8gbm9kZUlkU2V0LnNpemUgfTtcbiAgfTtcblxuICAvLyBmaW5kIGFuIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciB0aGUgbm9kZXMgaW4gYSBnaXZlbiBncmFwaCBhY2NvcmRpbmcgdG8gcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG4gIC8vIHRoaXMgZnVuY3Rpb24gYWxzbyB0YWtlcyB0aGUgZml4ZWQgbm9kZXMgYW5kIGFsaWdubWVudCBjb25zdHJhaW50cyBpbnRvIGFjY291bnRcbiAgLy8gZ3JhcGg6IGRhZyB0byBiZSBldmFsdWF0ZWQsIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLCBcbiAgLy8gZml4ZWROb2Rlczogc2V0IG9mIGZpeGVkIG5vZGVzIHRvIGNvbnNpZGVyIGR1cmluZyBldmFsdWF0aW9uLCBkdW1teVBvc2l0aW9uczogYXBwcm9wcmlhdGUgY29vcmRpbmF0ZXMgb2YgdGhlIGR1bW15IG5vZGVzICBcbiAgdmFyIGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQgPSBmdW5jdGlvbiBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGdyYXBoLCBkaXJlY3Rpb24sIGZpeGVkTm9kZXMsIGR1bW15UG9zaXRpb25zLCBjb21wb25lbnRTb3VyY2VzKSB7XG5cbiAgICAvLyBmaW5kIHVuaW9uIG9mIHR3byBzZXRzXG4gICAgZnVuY3Rpb24gc2V0VW5pb24oc2V0QSwgc2V0Qikge1xuICAgICAgdmFyIHVuaW9uID0gbmV3IFNldChzZXRBKTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBzZXRCW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBlbGVtID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB1bmlvbi5hZGQoZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5pb247XG4gICAgfVxuXG4gICAgLy8gZmluZCBpbmRlZ3JlZSBjb3VudCBmb3IgZWFjaCBub2RlXG4gICAgdmFyIGluRGVncmVlcyA9IG5ldyBNYXAoKTtcblxuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGluRGVncmVlcy5zZXQoa2V5LCAwKTtcbiAgICB9KTtcbiAgICBncmFwaC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICBpbkRlZ3JlZXMuc2V0KGFkamFjZW50LmlkLCBpbkRlZ3JlZXMuZ2V0KGFkamFjZW50LmlkKSArIDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgcG9zaXRpb25NYXAgPSBuZXcgTWFwKCk7IC8vIGtlZXBzIHRoZSBwb3NpdGlvbiBmb3IgZWFjaCBub2RlXG4gICAgdmFyIHBhc3RNYXAgPSBuZXcgTWFwKCk7IC8vIGtlZXBzIHRoZSBwcmVkZWNlc3NvcnMocGFzdCkgb2YgYSBub2RlXG4gICAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICBpbkRlZ3JlZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlID09IDApIHtcbiAgICAgICAgcXVldWUucHVzaChrZXkpO1xuICAgICAgICBpZiAoIWZpeGVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBub2RlSW5kZXhlcy5oYXMoa2V5KSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGtleSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBub2RlSW5kZXhlcy5oYXMoa2V5KSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb25NYXAuc2V0KGtleSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAgIHBhc3RNYXAuc2V0KGtleSwgbmV3IFNldChba2V5XSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYWxpZ24gc291cmNlcyBvZiBlYWNoIGNvbXBvbmVudCBpbiBlbmZvcmNlbWVudCBwaGFzZVxuICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICBjb21wb25lbnRTb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgZml4ZWRJZHMgPSBbXTtcbiAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBmaXhlZElkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpeGVkSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgICAgICAgIGZpeGVkSWRzLmZvckVhY2goZnVuY3Rpb24gKGZpeGVkSWQpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGZpeGVkSWQsIG5vZGVJbmRleGVzLmhhcyhmaXhlZElkKSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGZpeGVkSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChmaXhlZElkKSk7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uTWFwLmdldChmaXhlZElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChmaXhlZElkLCBub2RlSW5kZXhlcy5oYXMoZml4ZWRJZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChmaXhlZElkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoZml4ZWRJZCkpO1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBwb3NpdGlvbk1hcC5nZXQoZml4ZWRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIGZpeGVkSWRzLmxlbmd0aDtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBpZiAoIWZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KG5vZGVJZCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcG9zaXRpb24gPSAwO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgX3Bvc2l0aW9uICs9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9wb3NpdGlvbiArPSBub2RlSW5kZXhlcy5oYXMobm9kZUlkKSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gX3Bvc2l0aW9uIC8gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBfcG9zaXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb25zIG9mIHRoZSBub2Rlc1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGdyYXBoLmdldChjdXJyZW50Tm9kZSk7XG4gICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uTWFwLmdldChuZWlnaGJvci5pZCkgPCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKSB7XG4gICAgICAgICAgaWYgKGZpeGVkTm9kZXMgJiYgZml4ZWROb2Rlcy5oYXMobmVpZ2hib3IuaWQpKSB7XG4gICAgICAgICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgZml4ZWRQb3NpdGlvbiA9IG5vZGVJbmRleGVzLmhhcyhuZWlnaGJvci5pZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChuZWlnaGJvci5pZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpeGVkUG9zaXRpb24gPSBub2RlSW5kZXhlcy5oYXMobmVpZ2hib3IuaWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobmVpZ2hib3IuaWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChuZWlnaGJvci5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobmVpZ2hib3IuaWQsIGZpeGVkUG9zaXRpb24pOyAvLyBUT0RPOiBtYXkgZG8gdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICAgICAgaWYgKGZpeGVkUG9zaXRpb24gPCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gcG9zaXRpb25NYXAuZ2V0KGN1cnJlbnROb2RlKSArIG5laWdoYm9yLmdhcCAtIGZpeGVkUG9zaXRpb247XG4gICAgICAgICAgICAgIHBhc3RNYXAuZ2V0KGN1cnJlbnROb2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBwb3NpdGlvbk1hcC5nZXQobm9kZUlkKSAtIGRpZmYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KG5laWdoYm9yLmlkLCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5EZWdyZWVzLnNldChuZWlnaGJvci5pZCwgaW5EZWdyZWVzLmdldChuZWlnaGJvci5pZCkgLSAxKTtcbiAgICAgICAgaWYgKGluRGVncmVlcy5nZXQobmVpZ2hib3IuaWQpID09IDApIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZml4ZWROb2Rlcykge1xuICAgICAgICAgIHBhc3RNYXAuc2V0KG5laWdoYm9yLmlkLCBzZXRVbmlvbihwYXN0TWFwLmdldChjdXJyZW50Tm9kZSksIHBhc3RNYXAuZ2V0KG5laWdoYm9yLmlkKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cblxuICAgIC8vIHJlYWRqdXN0IHBvc2l0aW9uIG9mIHRoZSBub2RlcyBhZnRlciBlbmZvcmNlbWVudFxuICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAvLyBmaW5kIGluZGVncmVlIGNvdW50IGZvciBlYWNoIG5vZGVcbiAgICAgIHZhciBzaW5rTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgc2lua05vZGVzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9jb21wb25lbnRzID0gW107XG4gICAgICBwYXN0TWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHNpbmtOb2Rlcy5oYXMoa2V5KSkge1xuICAgICAgICAgIHZhciBpc0ZpeGVkQ29tcG9uZW50ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGVJZCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIGlzRml4ZWRDb21wb25lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNGaXhlZENvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGlzRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBleGlzdEF0ID0gdm9pZCAwO1xuICAgICAgICAgICAgX2NvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmhhcyhbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHZhbHVlKSlbMF0pKSB7XG4gICAgICAgICAgICAgICAgaXNFeGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhpc3RBdCA9IGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaXNFeGlzdCkge1xuICAgICAgICAgICAgICBfY29tcG9uZW50cy5wdXNoKG5ldyBTZXQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgIF9jb21wb25lbnRzW2V4aXN0QXRdLmFkZChlbGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBtaW5CZWZvcmUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciBtaW5BZnRlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1heEJlZm9yZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1heEFmdGVyID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBjb21wb25lbnRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBwb3NCZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgIHBvc0JlZm9yZSA9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvc0JlZm9yZSA9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3NBZnRlciA9IHBvc2l0aW9uTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKHBvc0JlZm9yZSA8IG1pbkJlZm9yZSkge1xuICAgICAgICAgICAgICBtaW5CZWZvcmUgPSBwb3NCZWZvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zQmVmb3JlID4gbWF4QmVmb3JlKSB7XG4gICAgICAgICAgICAgIG1heEJlZm9yZSA9IHBvc0JlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NBZnRlciA8IG1pbkFmdGVyKSB7XG4gICAgICAgICAgICAgIG1pbkFmdGVyID0gcG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zQWZ0ZXIgPiBtYXhBZnRlcikge1xuICAgICAgICAgICAgICBtYXhBZnRlciA9IHBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmYgPSAobWluQmVmb3JlICsgbWF4QmVmb3JlKSAvIDIgLSAobWluQWZ0ZXIgKyBtYXhBZnRlcikgLyAyO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBjb21wb25lbnRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfbm9kZUlkID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoX25vZGVJZCwgcG9zaXRpb25NYXAuZ2V0KF9ub2RlSWQpICsgZGlmZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbk1hcDtcbiAgfTtcblxuICAvLyBmaW5kIHRyYW5zZm9ybWF0aW9uIGJhc2VkIG9uIHJlbC4gcGxhY2VtZW50IGNvbnN0cmFpbnRzIGlmIHRoZXJlIGFyZSBib3RoIGFsaWdubWVudCBhbmQgcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHNcbiAgLy8gb3IgaWYgdGhlcmUgYXJlIG9ubHkgcmVsLiBwbGFjZW1lbnQgY29udHJhaW50cyB3aGVyZSB0aGUgbGFyZ2VzdCBjb21wb25lbnQgaXNuJ3Qgc3VmZmljaWVudGx5IGxhcmdlXG4gIHZhciBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudCA9IGZ1bmN0aW9uIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludHMpIHtcbiAgICAvLyB2YXJpYWJsZXMgdG8gY291bnQgdm90ZXNcbiAgICB2YXIgcmVmbGVjdE9uWSA9IDAsXG4gICAgICAgIG5vdFJlZmxlY3RPblkgPSAwO1xuICAgIHZhciByZWZsZWN0T25YID0gMCxcbiAgICAgICAgbm90UmVmbGVjdE9uWCA9IDA7XG5cbiAgICByZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChjb25zdHJhaW50LmxlZnQpIHtcbiAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoY29uc3RyYWludC5sZWZ0KV0gLSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LnJpZ2h0KV0gPj0gMCA/IHJlZmxlY3RPblkrKyA6IG5vdFJlZmxlY3RPblkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQudG9wKV0gLSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LmJvdHRvbSldID49IDAgPyByZWZsZWN0T25YKysgOiBub3RSZWZsZWN0T25YKys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocmVmbGVjdE9uWSA+IG5vdFJlZmxlY3RPblkgJiYgcmVmbGVjdE9uWCA+IG5vdFJlZmxlY3RPblgpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlSW5kZXhlcy5zaXplOyBfaSsrKSB7XG4gICAgICAgIHhDb29yZHNbX2ldID0gLTEgKiB4Q29vcmRzW19pXTtcbiAgICAgICAgeUNvb3Jkc1tfaV0gPSAtMSAqIHlDb29yZHNbX2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmbGVjdE9uWSA+IG5vdFJlZmxlY3RPblkpIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVJbmRleGVzLnNpemU7IF9pMisrKSB7XG4gICAgICAgIHhDb29yZHNbX2kyXSA9IC0xICogeENvb3Jkc1tfaTJdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmbGVjdE9uWCA+IG5vdFJlZmxlY3RPblgpIHtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVJbmRleGVzLnNpemU7IF9pMysrKSB7XG4gICAgICAgIHlDb29yZHNbX2kzXSA9IC0xICogeUNvb3Jkc1tfaTNdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBmaW5kIHdlYWtseSBjb25uZWN0ZWQgY29tcG9uZW50cyBpbiB1bmRpcmVjdGVkIGdyYXBoXG4gIHZhciBmaW5kQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRDb21wb25lbnRzKGdyYXBoKSB7XG4gICAgLy8gZmluZCB3ZWFrbHkgY29ubmVjdGVkIGNvbXBvbmVudHMgaW4gZGFnXG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICBncmFwaC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgY29tcG9uZW50c1tjb3VudF0gPSBbXTtcbiAgICAgICAgdmFyIF9jdXJyZW50Tm9kZSA9IGtleTtcbiAgICAgICAgcXVldWUucHVzaChfY3VycmVudE5vZGUpO1xuICAgICAgICB2aXNpdGVkLmFkZChfY3VycmVudE5vZGUpO1xuICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKF9jdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgX2N1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KF9jdXJyZW50Tm9kZSk7XG4gICAgICAgICAgbmVpZ2hib3JzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm9yKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5laWdoYm9yLmlkKSkge1xuICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgICAgdmlzaXRlZC5hZGQobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9O1xuXG4gIC8vIHJldHVybiB1bmRpcmVjdGVkIHZlcnNpb24gb2YgZ2l2ZW4gZGFnXG4gIHZhciBkYWdUb1VuZGlyZWN0ZWQgPSBmdW5jdGlvbiBkYWdUb1VuZGlyZWN0ZWQoZGFnKSB7XG4gICAgdmFyIHVuZGlyZWN0ZWQgPSBuZXcgTWFwKCk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdW5kaXJlY3RlZC5zZXQoa2V5LCBbXSk7XG4gICAgfSk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgdW5kaXJlY3RlZC5nZXQoa2V5KS5wdXNoKGFkamFjZW50KTtcbiAgICAgICAgdW5kaXJlY3RlZC5nZXQoYWRqYWNlbnQuaWQpLnB1c2goeyBpZDoga2V5LCBnYXA6IGFkamFjZW50LmdhcCwgZGlyZWN0aW9uOiBhZGphY2VudC5kaXJlY3Rpb24gfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB1bmRpcmVjdGVkO1xuICB9O1xuXG4gIC8vIHJldHVybiByZXZlcnNlZCAoZGlyZWN0aW9ucyBpbnZlcnRlZCkgdmVyc2lvbiBvZiBnaXZlbiBkYWdcbiAgdmFyIGRhZ1RvUmV2ZXJzZWQgPSBmdW5jdGlvbiBkYWdUb1JldmVyc2VkKGRhZykge1xuICAgIHZhciByZXZlcnNlZCA9IG5ldyBNYXAoKTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXZlcnNlZC5zZXQoa2V5LCBbXSk7XG4gICAgfSk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgcmV2ZXJzZWQuZ2V0KGFkamFjZW50LmlkKS5wdXNoKHsgaWQ6IGtleSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gIH07XG5cbiAgLyoqKiogIGFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBpbml0aWFsIGRyYWZ0IGxheW91dCB0byBiZXR0ZXIgYWxpZ24gd2l0aCBjb25zdHJhaW5lZCBub2RlcyAqKioqL1xuICAvLyBzb2x2ZSB0aGUgT3J0aG9nb25hbCBQcm9jcnVzdGVhbiBQcm9ibGVtIHRvIHJvdGF0ZSBhbmQvb3IgcmVmbGVjdCBpbml0aWFsIGRyYWZ0IGxheW91dFxuICAvLyBoZXJlIHdlIGZvbGxvdyB0aGUgc29sdXRpb24gaW4gQ2hhcHRlciAyMC4yIG9mIEJvcmcsIEkuICYgR3JvZW5lbiwgUC4gKDIwMDUpIE1vZGVybiBNdWx0aWRpbWVuc2lvbmFsIFNjYWxpbmc6IFRoZW9yeSBhbmQgQXBwbGljYXRpb25zIFxuXG4gIC8qIGNvbnN0cnVjdCBzb3VyY2UgYW5kIHRhcmdldCBjb25maWd1cmF0aW9ucyAqL1xuXG4gIHZhciB0YXJnZXRNYXRyaXggPSBbXTsgLy8gQSAtIHRhcmdldCBjb25maWd1cmF0aW9uXG4gIHZhciBzb3VyY2VNYXRyaXggPSBbXTsgLy8gQiAtIHNvdXJjZSBjb25maWd1cmF0aW9uIFxuICB2YXIgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlOyAvLyBmYWxzZSBmb3Igbm8gdHJhbnNmb3JtYXRpb24sIHRydWUgZm9yIHN0YW5kYXJ0IChQcm9jcnVzdGVzKSB0cmFuc2Zvcm1hdGlvbiAocm90YXRpb24gYW5kL29yIHJlZmxlY3Rpb24pXG4gIHZhciByZWZsZWN0aW9uVHlwZSA9IGZhbHNlOyAvLyBmYWxzZS90cnVlIGZvciByZWZsZWN0aW9uIGNoZWNrLCAncmVmbGVjdE9uWCcsICdyZWZsZWN0T25ZJyBvciAncmVmbGVjdE9uQm90aCcgZm9yIHJlZmxlY3Rpb24gdHlwZSBpZiBuZWNlc3NhcnlcbiAgdmFyIGZpeGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIHZhciBkYWcgPSBuZXcgTWFwKCk7IC8vIGFkamFjZW5jeSBsaXN0IHRvIGtlZXAgZGlyZWN0ZWQgYWN5Y2xpYyBncmFwaCAoZGFnKSB0aGF0IGNvbnNpc3RzIG9mIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50c1xuICB2YXIgZGFnVW5kaXJlY3RlZCA9IG5ldyBNYXAoKTsgLy8gdW5kaXJlY3RlZCB2ZXJzaW9uIG9mIHRoZSBkYWdcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTsgLy8gd2Vha2x5IGNvbm5lY3RlZCBjb21wb25lbnRzXG5cbiAgLy8gZmlsbCBmaXhlZE5vZGVzIGNvbGxlY3Rpb24gdG8gdXNlIGxhdGVyXG4gIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgZml4ZWROb2Rlcy5hZGQobm9kZURhdGEubm9kZUlkKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBkYWcgZnJvbSByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHMgXG4gIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAvLyBjb25zdHJ1Y3QgYm90aCBkaXJlY3RlZCBhbmQgdW5kaXJlY3RlZCB2ZXJzaW9uIG9mIHRoZSBkYWdcbiAgICBjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICBpZiAoZGFnLmhhcyhjb25zdHJhaW50LmxlZnQpKSB7XG4gICAgICAgICAgZGFnLmdldChjb25zdHJhaW50LmxlZnQpLnB1c2goeyBpZDogY29uc3RyYWludC5yaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQubGVmdCwgW3sgaWQ6IGNvbnN0cmFpbnQucmlnaHQsIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGFnLmhhcyhjb25zdHJhaW50LnJpZ2h0KSkge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC5yaWdodCwgW10pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGFnLmhhcyhjb25zdHJhaW50LnRvcCkpIHtcbiAgICAgICAgICBkYWcuZ2V0KGNvbnN0cmFpbnQudG9wKS5wdXNoKHsgaWQ6IGNvbnN0cmFpbnQuYm90dG9tLCBnYXA6IGNvbnN0cmFpbnQuZ2FwLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQudG9wLCBbeyBpZDogY29uc3RyYWludC5ib3R0b20sIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiIH1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhZy5oYXMoY29uc3RyYWludC5ib3R0b20pKSB7XG4gICAgICAgICAgZGFnLnNldChjb25zdHJhaW50LmJvdHRvbSwgW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkYWdVbmRpcmVjdGVkID0gZGFnVG9VbmRpcmVjdGVkKGRhZyk7XG4gICAgY29tcG9uZW50cyA9IGZpbmRDb21wb25lbnRzKGRhZ1VuZGlyZWN0ZWQpO1xuICB9XG5cbiAgaWYgKENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBmaXhlZCBub2RlIGNvbnN0cmFpbnRcbiAgICBpZiAoY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludCAmJiBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEsIGkpIHtcbiAgICAgICAgdGFyZ2V0TWF0cml4W2ldID0gW25vZGVEYXRhLnBvc2l0aW9uLngsIG5vZGVEYXRhLnBvc2l0aW9uLnldO1xuICAgICAgICBzb3VyY2VNYXRyaXhbaV0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldXTtcbiAgICAgIH0pO1xuICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGVuIGNoZWNrIGFsaWdubWVudCBjb25zdHJhaW50XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB7XG4gICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuXG4gICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihfaTQpIHtcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduW19pNF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhbGlnbm1lbnRTZXQpKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIHhQb3MgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB4UG9zID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeFBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueDtcblxuICAgICAgICAgICAgdmVydGljYWxBbGlnbltfaTRdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB0YXJnZXRNYXRyaXhbY291bnRdID0gW3hQb3MsIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICAgICAgc291cmNlTWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHZlcnRpY2FsQWxpZ24ubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgX2xvb3AyKF9pNCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgICAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMyhfaTUpIHtcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ25bX2k1XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgeVBvcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHlQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB5UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS55O1xuXG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ25bX2k1XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeVBvc107XG4gICAgICAgICAgICAgIHNvdXJjZU1hdHJpeFtjb3VudF0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBob3Jpem9udGFsQWxpZ24ubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICAgICAgX2xvb3AzKF9pNSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgICByZWZsZWN0aW9uVHlwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgIC8vIGZpbmFsbHkgY2hlY2sgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRcbiAgICAgIC8vIGZpbmQgbGFyZ2VzdCBjb21wb25lbnQgaW4gZGFnXG4gICAgICB2YXIgbGFyZ2VzdENvbXBvbmVudFNpemUgPSAwO1xuICAgICAgdmFyIGxhcmdlc3RDb21wb25lbnRJbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBjb21wb25lbnRzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbX2k2XS5sZW5ndGggPiBsYXJnZXN0Q29tcG9uZW50U2l6ZSkge1xuICAgICAgICAgIGxhcmdlc3RDb21wb25lbnRTaXplID0gY29tcG9uZW50c1tfaTZdLmxlbmd0aDtcbiAgICAgICAgICBsYXJnZXN0Q29tcG9uZW50SW5kZXggPSBfaTY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGxhcmdlc3QgY29tcG9uZW50IGlzbid0IGRvbWluYW50LCB0aGVuIHRha2UgdGhlIHZvdGVzIGZvciByZWZsZWN0aW9uXG4gICAgICBpZiAobGFyZ2VzdENvbXBvbmVudFNpemUgPCBkYWdVbmRpcmVjdGVkLnNpemUgLyAyKSB7XG4gICAgICAgIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCk7XG4gICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSBmYWxzZTtcbiAgICAgICAgcmVmbGVjdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXJnZXN0IGNvbXBvbmVudCBmb3IgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgLy8gY29uc3RydWN0IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHN1YmdyYXBocyBpbiB0aGUgbGFyZ2VzdCBjb21wb25lbnRcbiAgICAgICAgdmFyIHN1YkdyYXBoT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgc3ViR3JhcGhPblZlcnRpY2FsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQgPSBbXTtcblxuICAgICAgICBjb21wb25lbnRzW2xhcmdlc3RDb21wb25lbnRJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgZGFnLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgICAgICBpZiAoYWRqYWNlbnQuZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLmdldChub2RlSWQpLnB1c2goYWRqYWNlbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChub2RlSWQsIFthZGphY2VudF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc3ViR3JhcGhPbkhvcml6b250YWwuaGFzKGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChhZGphY2VudC5pZCwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzSW5sYXJnZXN0Q29tcG9uZW50LnB1c2goeyBsZWZ0OiBub2RlSWQsIHJpZ2h0OiBhZGphY2VudC5pZCB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KG5vZGVJZCkucHVzaChhZGphY2VudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPblZlcnRpY2FsLnNldChub2RlSWQsIFthZGphY2VudF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc3ViR3JhcGhPblZlcnRpY2FsLmhhcyhhZGphY2VudC5pZCkpIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KGFkamFjZW50LmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQucHVzaCh7IHRvcDogbm9kZUlkLCBib3R0b206IGFkamFjZW50LmlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudCk7XG4gICAgICAgIHJlZmxlY3Rpb25UeXBlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciBzdWJncmFwaHNcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwSG9yaXpvbnRhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoc3ViR3JhcGhPbkhvcml6b250YWwsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwVmVydGljYWwgPSBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KHN1YkdyYXBoT25WZXJ0aWNhbCwgXCJ2ZXJ0aWNhbFwiKTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3Qgc291cmNlIGFuZCB0YXJnZXQgY29uZmlndXJhdGlvblxuICAgICAgICBjb21wb25lbnRzW2xhcmdlc3RDb21wb25lbnRJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkLCBpKSB7XG4gICAgICAgICAgc291cmNlTWF0cml4W2ldID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXV07XG4gICAgICAgICAgdGFyZ2V0TWF0cml4W2ldID0gW107XG4gICAgICAgICAgaWYgKHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzBdID0gcG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRNYXRyaXhbaV1bMF0gPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvc2l0aW9uTWFwVmVydGljYWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVsxXSA9IHBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVsxXSA9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdHJhbnNmb3JtYXRpb24gaXMgcmVxdWlyZWQsIHRoZW4gY2FsY3VsYXRlIGFuZCBhcHBseSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICBpZiAoc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgLyogY2FsY3VsYXRlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCAqL1xuICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRhcmdldE1hdHJpeFRyYW5zcG9zZSA9IE1hdHJpeC50cmFuc3Bvc2UodGFyZ2V0TWF0cml4KTsgLy8gQSdcbiAgICAgIHZhciBzb3VyY2VNYXRyaXhUcmFuc3Bvc2UgPSBNYXRyaXgudHJhbnNwb3NlKHNvdXJjZU1hdHJpeCk7IC8vIEInXG5cbiAgICAgIC8vIGNlbnRyYWxpemUgdHJhbnNwb3NlIG1hdHJpY2VzXG4gICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCB0YXJnZXRNYXRyaXhUcmFuc3Bvc2UubGVuZ3RoOyBfaTcrKykge1xuICAgICAgICB0YXJnZXRNYXRyaXhUcmFuc3Bvc2VbX2k3XSA9IE1hdHJpeC5tdWx0R2FtbWEodGFyZ2V0TWF0cml4VHJhbnNwb3NlW19pN10pO1xuICAgICAgICBzb3VyY2VNYXRyaXhUcmFuc3Bvc2VbX2k3XSA9IE1hdHJpeC5tdWx0R2FtbWEoc291cmNlTWF0cml4VHJhbnNwb3NlW19pN10pO1xuICAgICAgfVxuXG4gICAgICAvLyBkbyBhY3R1YWwgY2FsY3VsYXRpb24gZm9yIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAgdmFyIHRlbXBNYXRyaXggPSBNYXRyaXgubXVsdE1hdCh0YXJnZXRNYXRyaXhUcmFuc3Bvc2UsIE1hdHJpeC50cmFuc3Bvc2Uoc291cmNlTWF0cml4VHJhbnNwb3NlKSk7IC8vIHRlbXBNYXRyaXggPSBBJ0JcbiAgICAgIHZhciBTVkRSZXN1bHQgPSBTVkQuc3ZkKHRlbXBNYXRyaXgpOyAvLyBTVkQoQSdCKSA9IFVTVicsIHN2ZCBmdW5jdGlvbiByZXR1cm5zIFUsIFMgYW5kIFYgXG4gICAgICB0cmFuc2Zvcm1hdGlvbk1hdHJpeCA9IE1hdHJpeC5tdWx0TWF0KFNWRFJlc3VsdC5WLCBNYXRyaXgudHJhbnNwb3NlKFNWRFJlc3VsdC5VKSk7IC8vIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gVCA9IFZVJ1xuXG4gICAgICAvKiBhcHBseSBmb3VuZCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gb2J0YWluIGZpbmFsIGRyYWZ0IGxheW91dCAqL1xuICAgICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2k4KyspIHtcbiAgICAgICAgdmFyIHRlbXAxID0gW3hDb29yZHNbX2k4XSwgeUNvb3Jkc1tfaThdXTtcbiAgICAgICAgdmFyIHRlbXAyID0gW3RyYW5zZm9ybWF0aW9uTWF0cml4WzBdWzBdLCB0cmFuc2Zvcm1hdGlvbk1hdHJpeFsxXVswXV07XG4gICAgICAgIHZhciB0ZW1wMyA9IFt0cmFuc2Zvcm1hdGlvbk1hdHJpeFswXVsxXSwgdHJhbnNmb3JtYXRpb25NYXRyaXhbMV1bMV1dO1xuICAgICAgICB4Q29vcmRzW19pOF0gPSBNYXRyaXguZG90UHJvZHVjdCh0ZW1wMSwgdGVtcDIpO1xuICAgICAgICB5Q29vcmRzW19pOF0gPSBNYXRyaXguZG90UHJvZHVjdCh0ZW1wMSwgdGVtcDMpO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBsaWVkIG9ubHkgYm90aCBhbGlnbm1lbnQgYW5kIHJlbC4gcGxhY2VtZW50IGNvbnN0cmFpbnRzIGV4aXN0XG4gICAgICBpZiAocmVmbGVjdGlvblR5cGUpIHtcbiAgICAgICAgYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTKSB7XG4gICAgLyoqKiogIGVuZm9yY2UgY29uc3RyYWludHMgb24gdGhlIHRyYW5zZm9ybWVkIGRyYWZ0IGxheW91dCAqKioqL1xuXG4gICAgLyogZmlyc3QgZW5mb3JjZSBmaXhlZCBub2RlIGNvbnN0cmFpbnQgKi9cblxuICAgIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ICYmIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRyYW5zbGF0aW9uQW1vdW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhLCBpKSB7XG4gICAgICAgIHZhciBwb3NJblRoZW9yeSA9IHsgeDogeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0sIHk6IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldIH07XG4gICAgICAgIHZhciBwb3NEZXNpcmVkID0gbm9kZURhdGEucG9zaXRpb247XG4gICAgICAgIHZhciBwb3NEaWZmID0gY2FsY3VsYXRlUG9zaXRpb25EaWZmKHBvc0Rlc2lyZWQsIHBvc0luVGhlb3J5KTtcbiAgICAgICAgdHJhbnNsYXRpb25BbW91bnQueCArPSBwb3NEaWZmLng7XG4gICAgICAgIHRyYW5zbGF0aW9uQW1vdW50LnkgKz0gcG9zRGlmZi55O1xuICAgICAgfSk7XG4gICAgICB0cmFuc2xhdGlvbkFtb3VudC54IC89IGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoO1xuICAgICAgdHJhbnNsYXRpb25BbW91bnQueSAvPSBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aDtcblxuICAgICAgeENvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB4Q29vcmRzW2ldICs9IHRyYW5zbGF0aW9uQW1vdW50Lng7XG4gICAgICB9KTtcblxuICAgICAgeUNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB5Q29vcmRzW2ldICs9IHRyYW5zbGF0aW9uQW1vdW50Lnk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSA9IG5vZGVEYXRhLnBvc2l0aW9uLng7XG4gICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldID0gbm9kZURhdGEucG9zaXRpb24ueTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIHRoZW4gZW5mb3JjZSBhbGlnbm1lbnQgY29uc3RyYWludCAqL1xuXG4gICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB7XG4gICAgICAgIHZhciB4QWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuXG4gICAgICAgIHZhciBfbG9vcDQgPSBmdW5jdGlvbiBfbG9vcDQoX2k5KSB7XG4gICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB4QWxpZ25bX2k5XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgeFBvcyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB4UG9zID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeFBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueDtcblxuICAgICAgICAgIGFsaWdubWVudFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSB4UG9zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IHhBbGlnbi5sZW5ndGg7IF9pOSsrKSB7XG4gICAgICAgICAgX2xvb3A0KF9pOSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgdmFyIHlBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcblxuICAgICAgICB2YXIgX2xvb3A1ID0gZnVuY3Rpb24gX2xvb3A1KF9pMTApIHtcbiAgICAgICAgICB2YXIgYWxpZ25tZW50U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIHlBbGlnbltfaTEwXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgeVBvcyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB5UG9zID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeVBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueTtcblxuICAgICAgICAgIGFsaWdubWVudFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSB5UG9zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgeUFsaWduLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgICAgX2xvb3A1KF9pMTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogZmluYWxseSBlbmZvcmNlIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50ICovXG5cbiAgICBpZiAoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVBvc2l0aW9uc0ZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZml4ZWROb2Rlc09uSG9yaXpvbnRhbCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGZpeGVkTm9kZXNPblZlcnRpY2FsID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIGZpbGwgbWFwcyBhbmQgc2V0cyAgICAgIFxuICAgICAgICBmaXhlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIGZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKG5vZGVJZCk7XG4gICAgICAgICAgZml4ZWROb2Rlc09uVmVydGljYWwuYWRkKG5vZGVJZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEFsaWdubWVudCA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgICAgIHZhciBfbG9vcDYgPSBmdW5jdGlvbiBfbG9vcDYoX2kxMSkge1xuICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTExLCBbXSk7XG4gICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50W19pMTFdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KG5vZGVJZCwgXCJkdW1teVwiICsgX2kxMSk7XG4gICAgICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoXCJkdW1teVwiICsgX2kxMSkucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgICBmaXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChcImR1bW15XCIgKyBfaTExKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBkdW1teVBvc2l0aW9uc0ZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTExLCB4Q29vcmRzW25vZGVJbmRleGVzLmdldCh2ZXJ0aWNhbEFsaWdubWVudFtfaTExXVswXSldKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgdmVydGljYWxBbGlnbm1lbnQubGVuZ3RoOyBfaTExKyspIHtcbiAgICAgICAgICAgICAgX2xvb3A2KF9pMTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWdubWVudCA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcblxuICAgICAgICAgICAgdmFyIF9sb29wNyA9IGZ1bmN0aW9uIF9sb29wNyhfaTEyKSB7XG4gICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQoXCJkdW1teVwiICsgX2kxMiwgW10pO1xuICAgICAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50W19pMTJdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBfaTEyKTtcbiAgICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIF9pMTIpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgICAgZml4ZWROb2Rlc09uVmVydGljYWwuYWRkKFwiZHVtbXlcIiArIF9pMTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGR1bW15UG9zaXRpb25zRm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQoXCJkdW1teVwiICsgX2kxMiwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaG9yaXpvbnRhbEFsaWdubWVudFtfaTEyXVswXSldKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgaG9yaXpvbnRhbEFsaWdubWVudC5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgICAgICAgICBfbG9vcDcoX2kxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3RydWN0IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRhZ3MgKHN1YmdyYXBocykgZnJvbSBvdmVyYWxsIGRhZ1xuICAgICAgICB2YXIgZGFnT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZGFnT25WZXJ0aWNhbCA9IG5ldyBNYXAoKTtcblxuICAgICAgICB2YXIgX2xvb3A4ID0gZnVuY3Rpb24gX2xvb3A4KG5vZGVJZCkge1xuICAgICAgICAgIGRhZy5nZXQobm9kZUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYWRqYWNlbnRbXCJkaXJlY3Rpb25cIl0gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgc291cmNlSWQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQobm9kZUlkKSA6IG5vZGVJZDtcbiAgICAgICAgICAgICAgaWYgKG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSB7IGlkOiBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBhZGphY2VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGFnT25Ib3Jpem9udGFsLmhhcyhzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPbkhvcml6b250YWwuZ2V0KHNvdXJjZUlkKS5wdXNoKHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhZ09uSG9yaXpvbnRhbC5zZXQoc291cmNlSWQsIFt0YXJnZXROb2RlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYWdPbkhvcml6b250YWwuaGFzKHRhcmdldE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25Ib3Jpem9udGFsLnNldCh0YXJnZXROb2RlLmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdXJjZUlkID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpIDogbm9kZUlkO1xuICAgICAgICAgICAgICBpZiAobm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0geyBpZDogbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBhZGphY2VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGFnT25WZXJ0aWNhbC5oYXMoc291cmNlSWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5nZXQoc291cmNlSWQpLnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5zZXQoc291cmNlSWQsIFt0YXJnZXROb2RlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYWdPblZlcnRpY2FsLmhhcyh0YXJnZXROb2RlLmlkKSkge1xuICAgICAgICAgICAgICAgIGRhZ09uVmVydGljYWwuc2V0KHRhcmdldE5vZGUuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBkYWcua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUlkID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDgobm9kZUlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmaW5kIHNvdXJjZSBub2RlcyBvZiBlYWNoIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkYWdzXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmRpcmVjdGVkT25Ib3Jpem9udGFsID0gZGFnVG9VbmRpcmVjdGVkKGRhZ09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciB1bmRpcmVjdGVkT25WZXJ0aWNhbCA9IGRhZ1RvVW5kaXJlY3RlZChkYWdPblZlcnRpY2FsKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHNPbkhvcml6b250YWwgPSBmaW5kQ29tcG9uZW50cyh1bmRpcmVjdGVkT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHNPblZlcnRpY2FsID0gZmluZENvbXBvbmVudHModW5kaXJlY3RlZE9uVmVydGljYWwpO1xuICAgICAgICB2YXIgcmV2ZXJzZWREYWdPbkhvcml6b250YWwgPSBkYWdUb1JldmVyc2VkKGRhZ09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciByZXZlcnNlZERhZ09uVmVydGljYWwgPSBkYWdUb1JldmVyc2VkKGRhZ09uVmVydGljYWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50U291cmNlc09uSG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICB2YXIgY29tcG9uZW50U291cmNlc09uVmVydGljYWwgPSBbXTtcblxuICAgICAgICBjb21wb25lbnRzT25Ib3Jpem9udGFsLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsW2luZGV4XSA9IFtdO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlZERhZ09uSG9yaXpvbnRhbC5nZXQobm9kZUlkKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsW2luZGV4XS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudHNPblZlcnRpY2FsLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbFtpbmRleF0gPSBbXTtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZWREYWdPblZlcnRpY2FsLmdldChub2RlSWQpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsW2luZGV4XS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhcHByb3ByaWF0ZSBwb3NpdGlvbmluZyBmb3Igc3ViZ3JhcGhzXG4gICAgICAgIHZhciBwb3NpdGlvbk1hcEhvcml6b250YWwgPSBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGRhZ09uSG9yaXpvbnRhbCwgXCJob3Jpem9udGFsXCIsIGZpeGVkTm9kZXNPbkhvcml6b250YWwsIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQsIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWwpO1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBWZXJ0aWNhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZGFnT25WZXJ0aWNhbCwgXCJ2ZXJ0aWNhbFwiLCBmaXhlZE5vZGVzT25WZXJ0aWNhbCwgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50LCBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgYmFzZWQgb24gcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG5cbiAgICAgICAgdmFyIF9sb29wOSA9IGZ1bmN0aW9uIF9sb29wOShrZXkpIHtcbiAgICAgICAgICBpZiAoZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoa2V5KSkge1xuICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjYgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSBwb3NpdGlvbk1hcEhvcml6b250YWwua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA2OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gKF9zdGVwNiA9IF9pdGVyYXRvcjYubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDkoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I2ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbG9vcDEwID0gZnVuY3Rpb24gX2xvb3AxMChrZXkpIHtcbiAgICAgICAgICBpZiAoZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChrZXkpKSB7XG4gICAgICAgICAgICBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGtleSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5Q29vcmRzW25vZGVJbmRleGVzLmdldChrZXkpXSA9IHBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjcgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBwb3NpdGlvbk1hcFZlcnRpY2FsLmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IChfc3RlcDcgPSBfaXRlcmF0b3I3Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwNy52YWx1ZTtcblxuICAgICAgICAgICAgX2xvb3AxMChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjcgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lnbiBuZXcgY29vcmRpbmF0ZXMgdG8gbm9kZXMgYWZ0ZXIgY29uc3RyYWludCBoYW5kbGluZ1xuICBmb3IgKHZhciBfaTEzID0gMDsgX2kxMyA8IGFsbE5vZGVzLmxlbmd0aDsgX2kxMysrKSB7XG4gICAgdmFyIF9ub2RlID0gYWxsTm9kZXNbX2kxM107XG4gICAgaWYgKF9ub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgX25vZGUuc2V0Q2VudGVyKHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KF9ub2RlLmlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KF9ub2RlLmlkKV0pO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50SGFuZGxlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU1MTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTUxX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTUxX18iLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsImNvc2VCYXNlIiwibGF5b3V0QmFzZSIsIkNvU0VDb25zdGFudHMiLCJDb1NFRWRnZSIsIkNvU0VHcmFwaCIsIkNvU0VHcmFwaE1hbmFnZXIiLCJDb1NFTGF5b3V0IiwiQ29TRU5vZGUiLCJDb25zdHJhaW50SGFuZGxlciIsIkZETGF5b3V0Q29uc3RhbnRzIiwicHJvcCIsIkRFRkFVTFRfVVNFX01VTFRJX0xFVkVMX1NDQUxJTkciLCJERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OIiwiREVGQVVMVF9FREdFX0xFTkdUSCIsIkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04iLCJUSUxFIiwiVElMSU5HX1BBRERJTkdfVkVSVElDQUwiLCJUSUxJTkdfUEFERElOR19IT1JJWk9OVEFMIiwiVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkciLCJFTkZPUkNFX0NPTlNUUkFJTlRTIiwiQVBQTFlfTEFZT1VUIiwiUkVMQVhfTU9WRU1FTlRfT05fQ09OU1RSQUlOVFMiLCJUUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCIsIlBVUkVfSU5DUkVNRU5UQUwiLCJERUZBVUxUX0lOQ1JFTUVOVEFMIiwiRkRMYXlvdXRFZGdlIiwic291cmNlIiwidGFyZ2V0IiwidkVkZ2UiLCJjYWxsIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiTEdyYXBoIiwicGFyZW50IiwiZ3JhcGhNZ3IiLCJ2R3JhcGgiLCJMR3JhcGhNYW5hZ2VyIiwibGF5b3V0IiwiRkRMYXlvdXQiLCJMYXlvdXRDb25zdGFudHMiLCJQb2ludCIsIlBvaW50RCIsIkRpbWVuc2lvbkQiLCJMYXlvdXQiLCJJbnRlZ2VyIiwiSUdlb21ldHJ5IiwiVHJhbnNmb3JtIiwiTGlua2VkTGlzdCIsInRvQmVUaWxlZCIsImNvbnN0cmFpbnRzIiwibmV3R3JhcGhNYW5hZ2VyIiwiZ20iLCJncmFwaE1hbmFnZXIiLCJuZXdHcmFwaCIsIm5ld05vZGUiLCJ2Tm9kZSIsIm5ld0VkZ2UiLCJpbml0UGFyYW1ldGVycyIsImFyZ3VtZW50cyIsImlzU3ViTGF5b3V0IiwiaWRlYWxFZGdlTGVuZ3RoIiwidXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiIsIkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OIiwiZ3Jhdml0eUNvbnN0YW50IiwiREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIIiwiY29tcG91bmRHcmF2aXR5Q29uc3RhbnQiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEgiLCJncmF2aXR5UmFuZ2VGYWN0b3IiLCJERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwiY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwicHJ1bmVkTm9kZXNBbGwiLCJncm93VHJlZUl0ZXJhdGlvbnMiLCJhZnRlckdyb3d0aEl0ZXJhdGlvbnMiLCJpc1RyZWVHcm93aW5nIiwiaXNHcm93dGhGaW5pc2hlZCIsImluaXRTcHJpbmdFbWJlZGRlciIsImNvb2xpbmdDeWNsZSIsIm1heENvb2xpbmdDeWNsZSIsIm1heEl0ZXJhdGlvbnMiLCJDT05WRVJHRU5DRV9DSEVDS19QRVJJT0QiLCJmaW5hbFRlbXBlcmF0dXJlIiwiY29vbGluZ0FkanVzdGVyIiwiY3JlYXRlQmVuZHNBc05lZWRlZCIsIkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRCIsImNyZWF0ZUJlbmRwb2ludHMiLCJyZXNldEFsbEVkZ2VzIiwibGV2ZWwiLCJjbGFzc2ljTGF5b3V0Iiwibm9kZXNXaXRoR3Jhdml0eSIsImNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8iLCJzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcyIsImNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMiLCJjYWxjSW5jbHVzaW9uVHJlZURlcHRocyIsImdldFJvb3QiLCJjYWxjRXN0aW1hdGVkU2l6ZSIsImNhbGNJZGVhbEVkZ2VMZW5ndGhzIiwiaW5jcmVtZW50YWwiLCJmb3Jlc3QiLCJnZXRGbGF0Rm9yZXN0IiwibGVuZ3RoIiwicG9zaXRpb25Ob2Rlc1JhZGlhbGx5IiwicmVkdWNlVHJlZXMiLCJyZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uIiwiYWxsTm9kZXMiLCJTZXQiLCJnZXRBbGxOb2RlcyIsImludGVyc2VjdGlvbiIsImZpbHRlciIsIngiLCJoYXMiLCJwb3NpdGlvbk5vZGVzUmFuZG9tbHkiLCJrZXlzIiwiaGFuZGxlQ29uc3RyYWludHMiLCJpbml0Q29uc3RyYWludFZhcmlhYmxlcyIsInJ1blNwcmluZ0VtYmVkZGVyIiwidGljayIsInRvdGFsSXRlcmF0aW9ucyIsImlzQ29udmVyZ2VkIiwibGF5b3V0UXVhbGl0eSIsImNvb2xpbmdGYWN0b3IiLCJNYXRoIiwibWF4IiwiaW5pdGlhbENvb2xpbmdGYWN0b3IiLCJwb3ciLCJsb2ciLCJhbmltYXRpb25QZXJpb2QiLCJjZWlsIiwiaW5pdGlhbEFuaW1hdGlvblBlcmlvZCIsInNxcnQiLCJ1cGRhdGVCb3VuZHMiLCJ1cGRhdGVHcmlkIiwiZ3Jvd1RyZWUiLCJERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIiwiZ3JpZFVwZGF0ZUFsbG93ZWQiLCJmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlIiwidG90YWxEaXNwbGFjZW1lbnQiLCJjYWxjU3ByaW5nRm9yY2VzIiwiY2FsY1JlcHVsc2lvbkZvcmNlcyIsImNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzIiwibW92ZU5vZGVzIiwiYW5pbWF0ZSIsImdldFBvc2l0aW9uc0RhdGEiLCJwRGF0YSIsImkiLCJyZWN0IiwiaWQiLCJnZXRDZW50ZXJYIiwieSIsImdldENlbnRlclkiLCJ3Iiwid2lkdGgiLCJoIiwiaGVpZ2h0IiwibGF5b3V0RW5kZWQiLCJBTklNQVRFIiwiZW1pdCIsImxOb2RlcyIsIm5vZGUiLCJjYWxjdWxhdGVEaXNwbGFjZW1lbnQiLCJ1cGRhdGVEaXNwbGFjZW1lbnRzIiwibW92ZSIsInNlbGYiLCJpZFRvTm9kZU1hcCIsIk1hcCIsImZpeGVkTm9kZVNldCIsInNldCIsImNhbGN1bGF0ZUNvbXBvdW5kV2VpZ2h0IiwiY29tcG91bmROb2RlIiwibm9kZXMiLCJnZXRDaGlsZCIsImdldE5vZGVzIiwiZml4ZWROb2RlV2VpZ2h0IiwiZml4ZWROb2RlQ29uc3RyYWludCIsImZvckVhY2giLCJub2RlRGF0YSIsImFkZCIsIm5vZGVJZCIsInJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCIsIm5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQiLCJub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQiLCJkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50IiwiZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50IiwiZml4ZWROb2Rlc09uSG9yaXpvbnRhbCIsImZpeGVkTm9kZXNPblZlcnRpY2FsIiwiYWxpZ25tZW50Q29uc3RyYWludCIsInZlcnRpY2FsIiwidmVydGljYWxBbGlnbm1lbnQiLCJnZXQiLCJwdXNoIiwiaG9yaXpvbnRhbCIsImhvcml6b250YWxBbGlnbm1lbnQiLCJzaHVmZmxlIiwiYXJyYXkiLCJqIiwiZmxvb3IiLCJyYW5kb20iLCJub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsIiwibm9kZXNJblJlbGF0aXZlVmVydGljYWwiLCJub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBIb3Jpem9udGFsIiwibm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwiLCJub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsIiwibm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwiLCJjb25zdHJhaW50IiwibGVmdCIsIm5vZGVJZExlZnQiLCJub2RlSWRSaWdodCIsInJpZ2h0IiwiaW5jbHVkZXMiLCJnYXAiLCJub2RlSWRUb3AiLCJ0b3AiLCJub2RlSWRCb3R0b20iLCJib3R0b20iLCJzdWJHcmFwaE9uSG9yaXpvbnRhbCIsInN1YkdyYXBoT25WZXJ0aWNhbCIsImNvbnN0cnVjdENvbXBvbmVudHMiLCJncmFwaCIsImZpeGVkTm9kZXMiLCJjb21wb25lbnRzIiwiaXNGaXhlZCIsInF1ZXVlIiwidmlzaXRlZCIsImNvdW50IiwidmFsdWUiLCJrZXkiLCJjdXJyZW50Tm9kZSIsInNoaWZ0IiwibmVpZ2hib3JzIiwibmVpZ2hib3IiLCJyZXN1bHRPbkhvcml6b250YWwiLCJjb21wb25lbnRzT25Ib3Jpem9udGFsIiwiZml4ZWRDb21wb25lbnRzT25Ib3Jpem9udGFsIiwicmVzdWx0T25WZXJ0aWNhbCIsImNvbXBvbmVudHNPblZlcnRpY2FsIiwiZml4ZWRDb21wb25lbnRzT25WZXJ0aWNhbCIsImZpeGVkTm9kZSIsImRpc3BsYWNlbWVudFgiLCJkaXNwbGFjZW1lbnRZIiwiYWxsVmVydGljYWxBbGlnbm1lbnRzIiwidG90YWxEaXNwbGFjZW1lbnRYIiwiYXZlcmFnZURpc3BsYWNlbWVudFgiLCJhbGxIb3Jpem9udGFsQWxpZ25tZW50cyIsInRvdGFsRGlzcGxhY2VtZW50WSIsImF2ZXJhZ2VEaXNwbGFjZW1lbnRZIiwiZGlzcGxhY2VtZW50IiwiZGlmZiIsImNvbXBvbmVudCIsInN1bSIsImFjdHVhbE5vZGVzIiwiYXZlcmFnZURpc3BsYWNlbWVudCIsIm5vZGVMaXN0IiwiZ3JhcGhzIiwiZ2V0R3JhcGhzIiwic2l6ZSIsInVwZGF0ZUNvbm5lY3RlZCIsImlzQ29ubmVjdGVkIiwiY29uY2F0IiwiZWRnZXMiLCJnZXRBbGxFZGdlcyIsImVkZ2UiLCJnZXRTb3VyY2UiLCJnZXRUYXJnZXQiLCJnZXRCZW5kcG9pbnRzIiwiY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMiLCJlZGdlTGlzdCIsImdldEVkZ2VMaXN0VG9Ob2RlIiwiayIsIm11bHRpRWRnZSIsImN1cnJlbnRTdGFydGluZ1BvaW50IiwibnVtYmVyT2ZDb2x1bW5zIiwiY3VycmVudFkiLCJjdXJyZW50WCIsInBvaW50IiwidHJlZSIsImNlbnRlck5vZGUiLCJmaW5kQ2VudGVyT2ZUcmVlIiwicmFkaWFsTGF5b3V0IiwidHJhbnNmb3JtIiwiV09STERfQ0VOVEVSX1giLCJXT1JMRF9DRU5URVJfWSIsInN0YXJ0aW5nUG9pbnQiLCJyYWRpYWxTZXAiLCJtYXhEaWFnb25hbEluVHJlZSIsImJyYW5jaFJhZGlhbExheW91dCIsImJvdW5kcyIsImNhbGN1bGF0ZUJvdW5kcyIsInNldERldmljZU9yZ1giLCJnZXRNaW5YIiwic2V0RGV2aWNlT3JnWSIsImdldE1pblkiLCJzZXRXb3JsZE9yZ1giLCJzZXRXb3JsZE9yZ1kiLCJib3R0b21SaWdodCIsImdldE1heFgiLCJnZXRNYXhZIiwiaW52ZXJzZVRyYW5zZm9ybVBvaW50IiwicGFyZW50T2ZOb2RlIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiZGlzdGFuY2UiLCJyYWRpYWxTZXBhcmF0aW9uIiwiaGFsZkludGVydmFsIiwibm9kZUFuZ2xlIiwidGV0YSIsIlRXT19QSSIsImNvc190ZXRhIiwiY29zIiwieF8iLCJ5XyIsInNpbiIsInNldENlbnRlciIsIm5laWdoYm9yRWRnZXMiLCJnZXRFZGdlcyIsImNoaWxkQ291bnQiLCJicmFuY2hDb3VudCIsImluY0VkZ2VzQ291bnQiLCJzdGFydEluZGV4IiwiZ2V0RWRnZXNCZXR3ZWVuIiwidGVtcCIsInNwbGljZSIsImluZGV4IiwiaW5kZXhPZiIsInN0ZXBBbmdsZSIsImFicyIsImN1cnJlbnROZWlnaGJvciIsImdldE90aGVyRW5kIiwiY2hpbGRTdGFydEFuZ2xlIiwiY2hpbGRFbmRBbmdsZSIsIm1heERpYWdvbmFsIiwiTUlOX1ZBTFVFIiwiZGlhZ29uYWwiLCJnZXREaWFnb25hbCIsImNhbGNSZXB1bHNpb25SYW5nZSIsImdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMiLCJ0ZW1wTWVtYmVyR3JvdXBzIiwibWVtYmVyR3JvdXBzIiwiaWRUb0R1bW15Tm9kZSIsInplcm9EZWdyZWUiLCJnZXRQYXJlbnQiLCJnZXROb2RlRGVncmVlV2l0aENoaWxkcmVuIiwidW5kZWZpbmVkIiwiZ2V0VG9CZVRpbGVkIiwicF9pZCIsImR1bW15Q29tcG91bmRJZCIsImR1bW15Q29tcG91bmQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nVG9wIiwiZHVtbXlQYXJlbnRHcmFwaCIsImdldEdyYXBoTWFuYWdlciIsInBhcmVudEdyYXBoIiwicmVtb3ZlIiwiY2xlYXJDb21wb3VuZHMiLCJjaGlsZEdyYXBoTWFwIiwiaWRUb05vZGUiLCJwZXJmb3JtREZTT25Db21wb3VuZHMiLCJjb21wb3VuZE9yZGVyIiwiY2hpbGQiLCJyZXNldEFsbE5vZGVzIiwidGlsZUNvbXBvdW5kTWVtYmVycyIsImNsZWFyWmVyb0RlZ3JlZU1lbWJlcnMiLCJ0aWxlZFplcm9EZWdyZWVQYWNrIiwidGlsZU5vZGVzIiwiY2VudGVyWCIsImNlbnRlclkiLCJsYWJlbE1hcmdpbkxlZnQiLCJsYWJlbE1hcmdpblRvcCIsIk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyIsImxhYmVsV2lkdGgiLCJsYWJlbFBvc0hvcml6b250YWwiLCJzZXRXaWR0aCIsImxhYmVsSGVpZ2h0IiwibGFiZWxQb3NWZXJ0aWNhbCIsInNldEhlaWdodCIsInJlcG9wdWxhdGVDb21wb3VuZHMiLCJsQ29tcG91bmROb2RlIiwiaG9yaXpvbnRhbE1hcmdpbiIsInZlcnRpY2FsTWFyZ2luIiwiYWRqdXN0TG9jYXRpb25zIiwidGlsZWRNZW1iZXJQYWNrIiwicmVwb3B1bGF0ZVplcm9EZWdyZWVNZW1iZXJzIiwidGlsZWRQYWNrIiwiY2hpbGRHcmFwaCIsImNoaWxkcmVuIiwidGhlQ2hpbGQiLCJnZXROb2RlRGVncmVlIiwiZGVncmVlIiwiZmlsbENvbXBleE9yZGVyQnlERlMiLCJvcmdhbml6YXRpb24iLCJjb21wb3VuZEhvcml6b250YWxNYXJnaW4iLCJjb21wb3VuZFZlcnRpY2FsTWFyZ2luIiwiY29tcG91bmRMYWJlbE1hcmdpbkxlZnQiLCJjb21wb3VuZExhYmVsTWFyZ2luVG9wIiwicm93cyIsInJvdyIsIm1heEhlaWdodCIsImxub2RlIiwiaG9yaXpvbnRhbFBhZGRpbmciLCJ2ZXJ0aWNhbFBhZGRpbmciLCJtaW5XaWR0aCIsImhvcml6b250YWxPcmciLCJ0aWxlTm9kZXNCeUZhdm9yaW5nRGltIiwidmVydGljYWxPcmciLCJob3Jpem9udGFsUmF0aW8iLCJnZXRPcmdSYXRpbyIsInZlcnRpY2FsUmF0aW8iLCJiZXN0T3JnIiwicmF0aW8iLCJjYWxjSWRlYWxSb3dXaWR0aCIsIm1lbWJlcnMiLCJmYXZvckhvcml6b250YWxEaW0iLCJtZW1iZXJzU2l6ZSIsInRvdGFsV2lkdGgiLCJ0b3RhbEhlaWdodCIsIm1heFdpZHRoIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJhdmVyYWdlV2lkdGgiLCJhdmVyYWdlSGVpZ2h0IiwiZGVsdGEiLCJob3Jpem9udGFsQ291bnREb3VibGUiLCJob3Jpem9udGFsQ291bnQiLCJpZGVhbFdpZHRoIiwidGlsaW5nQ29tcGFyZUJ5IiwiVElMSU5HX0NPTVBBUkVfQlkiLCJyb3dXaWR0aCIsInJvd0hlaWdodCIsImlkZWFsUm93V2lkdGgiLCJnZXROb2RlQXJlYSIsIm4iLCJhcmVhQ29tcGFyZUZjbiIsIm4xIiwibjIiLCJzb3J0IiwiY21wQnkiLCJzdW1DZW50ZXJYIiwic3VtQ2VudGVyWSIsImxOb2RlIiwiaW5zZXJ0Tm9kZVRvUm93IiwiY2FuQWRkSG9yaXpvbnRhbCIsInJvd0luZGV4IiwiZ2V0U2hvcnRlc3RSb3dJbmRleCIsInNoaWZ0VG9MYXN0Um93IiwibWluQ29tcG91bmRTaXplIiwic2Vjb25kRGltZW5zaW9uIiwiZXh0cmFIZWlnaHQiLCJyIiwibWluIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiZ2V0TG9uZ2VzdFJvd0luZGV4IiwiZXh0cmFXaWR0aCIsImxhc3RSb3dJbmRleCIsImxhc3RSb3dXaWR0aCIsInNyaSIsImhEaWZmIiwiYWRkX3RvX3Jvd19yYXRpbyIsImFkZF9uZXdfcm93X3JhdGlvIiwibG9uZ2VzdCIsImxhc3QiLCJpbnN0YW5jZSIsInByZXZUb3RhbCIsImZpbmFsVG90YWwiLCJ0aWxpbmdQcmVMYXlvdXQiLCJ0aWxpbmdQb3N0TGF5b3V0IiwiY29udGFpbnNMZWFmIiwicHJ1bmVkTm9kZXNJblN0ZXBUZW1wIiwiaXNJbnRlckdyYXBoIiwib3RoZXJFbmQiLCJyZWxhdGl2ZVBvc2l0aW9uIiwiZ2V0T3duZXIiLCJwcnVuZWROb2Rlc0luU3RlcCIsImxlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAiLCJmaW5kUGxhY2Vmb3JQcnVuZWROb2RlIiwiZ3JpZEZvclBydW5lZE5vZGUiLCJub2RlVG9Db25uZWN0IiwicHJ1bmVkTm9kZSIsInN0YXJ0R3JpZFgiLCJzdGFydFgiLCJmaW5pc2hHcmlkWCIsImZpbmlzaFgiLCJzdGFydEdyaWRZIiwic3RhcnRZIiwiZmluaXNoR3JpZFkiLCJmaW5pc2hZIiwidXBOb2RlQ291bnQiLCJkb3duTm9kZUNvdW50IiwicmlnaHROb2RlQ291bnQiLCJsZWZ0Tm9kZUNvdW50IiwiY29udHJvbFJlZ2lvbnMiLCJncmlkIiwibWluQ291bnQiLCJtaW5JbmRleCIsIkZETGF5b3V0Tm9kZSIsIklNYXRoIiwibG9jIiwiZ2V0TGF5b3V0Iiwic3ByaW5nRm9yY2VYIiwicmVwdWxzaW9uRm9yY2VYIiwiZ3Jhdml0YXRpb25Gb3JjZVgiLCJzcHJpbmdGb3JjZVkiLCJyZXB1bHNpb25Gb3JjZVkiLCJncmF2aXRhdGlvbkZvcmNlWSIsIm5vT2ZDaGlsZHJlbiIsIm1heE5vZGVEaXNwbGFjZW1lbnQiLCJzaWduIiwicHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbiIsImRYIiwiZFkiLCJtb3ZlQnkiLCJzZXRQcmVkMSIsInByZWQxIiwiZ2V0UHJlZDEiLCJnZXRQcmVkMiIsInByZWQyIiwic2V0TmV4dCIsIm5leHQiLCJnZXROZXh0Iiwic2V0UHJvY2Vzc2VkIiwicHJvY2Vzc2VkIiwiaXNQcm9jZXNzZWQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJhcnIyIiwiZnJvbSIsIk1hdHJpeCIsIlNWRCIsIm5vZGVJbmRleGVzIiwieENvb3JkcyIsInlDb29yZHMiLCJjYWxjdWxhdGVQb3NpdGlvbkRpZmYiLCJwb3MxIiwicG9zMiIsImNhbGN1bGF0ZUF2Z1Bvc2l0aW9uIiwibm9kZUlkU2V0IiwieFBvc1N1bSIsInlQb3NTdW0iLCJmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50IiwiZGlyZWN0aW9uIiwiZHVtbXlQb3NpdGlvbnMiLCJjb21wb25lbnRTb3VyY2VzIiwic2V0VW5pb24iLCJzZXRBIiwic2V0QiIsInVuaW9uIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zdGVwIiwiZG9uZSIsImVsZW0iLCJlcnIiLCJyZXR1cm4iLCJpbkRlZ3JlZXMiLCJhZGphY2VudCIsInBvc2l0aW9uTWFwIiwicGFzdE1hcCIsIk5FR0FUSVZFX0lORklOSVRZIiwiZml4ZWRJZHMiLCJwb3NpdGlvbiIsImZpeGVkSWQiLCJfcG9zaXRpb24iLCJfbG9vcCIsImZpeGVkUG9zaXRpb24iLCJzaW5rTm9kZXMiLCJfY29tcG9uZW50cyIsImlzRml4ZWRDb21wb25lbnQiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiIsIl9kaWRJdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJpc0V4aXN0IiwiZXhpc3RBdCIsImVsZSIsIm1pbkJlZm9yZSIsIlBPU0lUSVZFX0lORklOSVRZIiwibWluQWZ0ZXIiLCJtYXhCZWZvcmUiLCJtYXhBZnRlciIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zIiwiX2RpZEl0ZXJhdG9yRXJyb3IzIiwiX2l0ZXJhdG9yRXJyb3IzIiwiX2l0ZXJhdG9yMyIsIl9zdGVwMyIsInBvc0JlZm9yZSIsInBvc0FmdGVyIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQiLCJfZGlkSXRlcmF0b3JFcnJvcjQiLCJfaXRlcmF0b3JFcnJvcjQiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwiX25vZGVJZCIsImFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50IiwicmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50cyIsInJlZmxlY3RPblkiLCJub3RSZWZsZWN0T25ZIiwicmVmbGVjdE9uWCIsIm5vdFJlZmxlY3RPblgiLCJfaSIsIl9pMiIsIl9pMyIsImZpbmRDb21wb25lbnRzIiwiX2N1cnJlbnROb2RlIiwiZGFnVG9VbmRpcmVjdGVkIiwiZGFnIiwidW5kaXJlY3RlZCIsImRhZ1RvUmV2ZXJzZWQiLCJyZXZlcnNlZCIsInRhcmdldE1hdHJpeCIsInNvdXJjZU1hdHJpeCIsInN0YW5kYXJkVHJhbnNmb3JtYXRpb24iLCJyZWZsZWN0aW9uVHlwZSIsImRhZ1VuZGlyZWN0ZWQiLCJ2ZXJ0aWNhbEFsaWduIiwiX2xvb3AyIiwiX2k0IiwiYWxpZ25tZW50U2V0IiwieFBvcyIsInZhbHVlcyIsImhvcml6b250YWxBbGlnbiIsIl9sb29wMyIsIl9pNSIsInlQb3MiLCJsYXJnZXN0Q29tcG9uZW50U2l6ZSIsImxhcmdlc3RDb21wb25lbnRJbmRleCIsIl9pNiIsImNvbnN0cmFpbnRzSW5sYXJnZXN0Q29tcG9uZW50IiwicG9zaXRpb25NYXBIb3Jpem9udGFsIiwicG9zaXRpb25NYXBWZXJ0aWNhbCIsInRyYW5zZm9ybWF0aW9uTWF0cml4IiwidGFyZ2V0TWF0cml4VHJhbnNwb3NlIiwidHJhbnNwb3NlIiwic291cmNlTWF0cml4VHJhbnNwb3NlIiwiX2k3IiwibXVsdEdhbW1hIiwidGVtcE1hdHJpeCIsIm11bHRNYXQiLCJTVkRSZXN1bHQiLCJzdmQiLCJWIiwiVSIsIl9pOCIsInRlbXAxIiwidGVtcDIiLCJ0ZW1wMyIsImRvdFByb2R1Y3QiLCJ0cmFuc2xhdGlvbkFtb3VudCIsInBvc0luVGhlb3J5IiwicG9zRGVzaXJlZCIsInBvc0RpZmYiLCJ4QWxpZ24iLCJfbG9vcDQiLCJfaTkiLCJ5QWxpZ24iLCJfbG9vcDUiLCJfaTEwIiwiZHVtbXlQb3NpdGlvbnNGb3JWZXJ0aWNhbEFsaWdubWVudCIsImR1bW15UG9zaXRpb25zRm9ySG9yaXpvbnRhbEFsaWdubWVudCIsIl9sb29wNiIsIl9pMTEiLCJfbG9vcDciLCJfaTEyIiwiZGFnT25Ib3Jpem9udGFsIiwiZGFnT25WZXJ0aWNhbCIsIl9sb29wOCIsInNvdXJjZUlkIiwidGFyZ2V0Tm9kZSIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241IiwiX2RpZEl0ZXJhdG9yRXJyb3I1IiwiX2l0ZXJhdG9yRXJyb3I1IiwiX2l0ZXJhdG9yNSIsIl9zdGVwNSIsInVuZGlyZWN0ZWRPbkhvcml6b250YWwiLCJ1bmRpcmVjdGVkT25WZXJ0aWNhbCIsInJldmVyc2VkRGFnT25Ib3Jpem9udGFsIiwicmV2ZXJzZWREYWdPblZlcnRpY2FsIiwiY29tcG9uZW50U291cmNlc09uSG9yaXpvbnRhbCIsImNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsIiwiX2xvb3A5IiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYiLCJfZGlkSXRlcmF0b3JFcnJvcjYiLCJfaXRlcmF0b3JFcnJvcjYiLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwiX2xvb3AxMCIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243IiwiX2RpZEl0ZXJhdG9yRXJyb3I3IiwiX2l0ZXJhdG9yRXJyb3I3IiwiX2l0ZXJhdG9yNyIsIl9zdGVwNyIsIl9pMTMiLCJfbm9kZSIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js":
/*!******************************************************************************!*\
  !*** ./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js ***!
  \******************************************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(this, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_561__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_561__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_561__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_561__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_561__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_561__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_561__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_561__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_561__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_561__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_561__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_561__(__nested_webpack_require_561__.s = 28);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function LayoutConstants() {}\n            /**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */ LayoutConstants.QUALITY = 1;\n            /**\r\n * Default parameters\r\n */ LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\n            LayoutConstants.DEFAULT_INCREMENTAL = false;\n            LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\n            LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\n            LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\n            LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n            // -----------------------------------------------------------------------------\n            // Section: General other constants\n            // -----------------------------------------------------------------------------\n            /*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */ LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n            /*\r\n * Whether to consider labels in node dimensions or not\r\n */ LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n            /*\r\n * Default dimension of a non-compound node.\r\n */ LayoutConstants.SIMPLE_NODE_SIZE = 40;\n            /*\r\n * Default dimension of a non-compound node.\r\n */ LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n            /*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */ LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n            /*\r\n * Minimum length that an edge should take during layout\r\n */ LayoutConstants.MIN_EDGE_LENGTH = 1;\n            /*\r\n * World boundaries that layout operates on\r\n */ LayoutConstants.WORLD_BOUNDARY = 1000000;\n            /*\r\n * World boundaries that random positioning can be performed with\r\n */ LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n            /*\r\n * Coordinates of the world center\r\n */ LayoutConstants.WORLD_CENTER_X = 1200;\n            LayoutConstants.WORLD_CENTER_Y = 900;\n            module1.exports = LayoutConstants;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_5686__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_5686__(2);\n            var IGeometry = __nested_webpack_require_5686__(8);\n            var IMath = __nested_webpack_require_5686__(9);\n            function LEdge(source, target, vEdge) {\n                LGraphObject.call(this, vEdge);\n                this.isOverlapingSourceAndTarget = false;\n                this.vGraphObject = vEdge;\n                this.bendpoints = [];\n                this.source = source;\n                this.target = target;\n            }\n            LEdge.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LEdge[prop] = LGraphObject[prop];\n            }\n            LEdge.prototype.getSource = function() {\n                return this.source;\n            };\n            LEdge.prototype.getTarget = function() {\n                return this.target;\n            };\n            LEdge.prototype.isInterGraph = function() {\n                return this.isInterGraph;\n            };\n            LEdge.prototype.getLength = function() {\n                return this.length;\n            };\n            LEdge.prototype.isOverlapingSourceAndTarget = function() {\n                return this.isOverlapingSourceAndTarget;\n            };\n            LEdge.prototype.getBendpoints = function() {\n                return this.bendpoints;\n            };\n            LEdge.prototype.getLca = function() {\n                return this.lca;\n            };\n            LEdge.prototype.getSourceInLca = function() {\n                return this.sourceInLca;\n            };\n            LEdge.prototype.getTargetInLca = function() {\n                return this.targetInLca;\n            };\n            LEdge.prototype.getOtherEnd = function(node) {\n                if (this.source === node) {\n                    return this.target;\n                } else if (this.target === node) {\n                    return this.source;\n                } else {\n                    throw \"Node is not incident with this edge\";\n                }\n            };\n            LEdge.prototype.getOtherEndInGraph = function(node, graph) {\n                var otherEnd = this.getOtherEnd(node);\n                var root = graph.getGraphManager().getRoot();\n                while(true){\n                    if (otherEnd.getOwner() == graph) {\n                        return otherEnd;\n                    }\n                    if (otherEnd.getOwner() == root) {\n                        break;\n                    }\n                    otherEnd = otherEnd.getOwner().getParent();\n                }\n                return null;\n            };\n            LEdge.prototype.updateLength = function() {\n                var clipPointCoordinates = new Array(4);\n                this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n                if (!this.isOverlapingSourceAndTarget) {\n                    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n                    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n                    if (Math.abs(this.lengthX) < 1.0) {\n                        this.lengthX = IMath.sign(this.lengthX);\n                    }\n                    if (Math.abs(this.lengthY) < 1.0) {\n                        this.lengthY = IMath.sign(this.lengthY);\n                    }\n                    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n                }\n            };\n            LEdge.prototype.updateLengthSimple = function() {\n                this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n                this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n                if (Math.abs(this.lengthX) < 1.0) {\n                    this.lengthX = IMath.sign(this.lengthX);\n                }\n                if (Math.abs(this.lengthY) < 1.0) {\n                    this.lengthY = IMath.sign(this.lengthY);\n                }\n                this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n            };\n            module1.exports = LEdge;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function LGraphObject(vGraphObject) {\n                this.vGraphObject = vGraphObject;\n            }\n            module1.exports = LGraphObject;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_10226__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_10226__(2);\n            var Integer = __nested_webpack_require_10226__(10);\n            var RectangleD = __nested_webpack_require_10226__(13);\n            var LayoutConstants = __nested_webpack_require_10226__(0);\n            var RandomSeed = __nested_webpack_require_10226__(16);\n            var PointD = __nested_webpack_require_10226__(5);\n            function LNode(gm, loc, size, vNode) {\n                //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n                if (size == null && vNode == null) {\n                    vNode = loc;\n                }\n                LGraphObject.call(this, vNode);\n                //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n                if (gm.graphManager != null) gm = gm.graphManager;\n                this.estimatedSize = Integer.MIN_VALUE;\n                this.inclusionTreeDepth = Integer.MAX_VALUE;\n                this.vGraphObject = vNode;\n                this.edges = [];\n                this.graphManager = gm;\n                if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);\n                else this.rect = new RectangleD();\n            }\n            LNode.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LNode[prop] = LGraphObject[prop];\n            }\n            LNode.prototype.getEdges = function() {\n                return this.edges;\n            };\n            LNode.prototype.getChild = function() {\n                return this.child;\n            };\n            LNode.prototype.getOwner = function() {\n                //  if (this.owner != null) {\n                //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n                //      throw \"assert failed\";\n                //    }\n                //  }\n                return this.owner;\n            };\n            LNode.prototype.getWidth = function() {\n                return this.rect.width;\n            };\n            LNode.prototype.setWidth = function(width) {\n                this.rect.width = width;\n            };\n            LNode.prototype.getHeight = function() {\n                return this.rect.height;\n            };\n            LNode.prototype.setHeight = function(height) {\n                this.rect.height = height;\n            };\n            LNode.prototype.getCenterX = function() {\n                return this.rect.x + this.rect.width / 2;\n            };\n            LNode.prototype.getCenterY = function() {\n                return this.rect.y + this.rect.height / 2;\n            };\n            LNode.prototype.getCenter = function() {\n                return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n            };\n            LNode.prototype.getLocation = function() {\n                return new PointD(this.rect.x, this.rect.y);\n            };\n            LNode.prototype.getRect = function() {\n                return this.rect;\n            };\n            LNode.prototype.getDiagonal = function() {\n                return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n            };\n            /**\n * This method returns half the diagonal length of this node.\n */ LNode.prototype.getHalfTheDiagonal = function() {\n                return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n            };\n            LNode.prototype.setRect = function(upperLeft, dimension) {\n                this.rect.x = upperLeft.x;\n                this.rect.y = upperLeft.y;\n                this.rect.width = dimension.width;\n                this.rect.height = dimension.height;\n            };\n            LNode.prototype.setCenter = function(cx, cy) {\n                this.rect.x = cx - this.rect.width / 2;\n                this.rect.y = cy - this.rect.height / 2;\n            };\n            LNode.prototype.setLocation = function(x, y) {\n                this.rect.x = x;\n                this.rect.y = y;\n            };\n            LNode.prototype.moveBy = function(dx, dy) {\n                this.rect.x += dx;\n                this.rect.y += dy;\n            };\n            LNode.prototype.getEdgeListToNode = function(to) {\n                var edgeList = [];\n                var edge;\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (edge.target == to) {\n                        if (edge.source != self) throw \"Incorrect edge source!\";\n                        edgeList.push(edge);\n                    }\n                });\n                return edgeList;\n            };\n            LNode.prototype.getEdgesBetween = function(other) {\n                var edgeList = [];\n                var edge;\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n                    if (edge.target == other || edge.source == other) {\n                        edgeList.push(edge);\n                    }\n                });\n                return edgeList;\n            };\n            LNode.prototype.getNeighborsList = function() {\n                var neighbors = new Set();\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (edge.source == self) {\n                        neighbors.add(edge.target);\n                    } else {\n                        if (edge.target != self) {\n                            throw \"Incorrect incidency!\";\n                        }\n                        neighbors.add(edge.source);\n                    }\n                });\n                return neighbors;\n            };\n            LNode.prototype.withChildren = function() {\n                var withNeighborsList = new Set();\n                var childNode;\n                var children;\n                withNeighborsList.add(this);\n                if (this.child != null) {\n                    var nodes = this.child.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        childNode = nodes[i];\n                        children = childNode.withChildren();\n                        children.forEach(function(node) {\n                            withNeighborsList.add(node);\n                        });\n                    }\n                }\n                return withNeighborsList;\n            };\n            LNode.prototype.getNoOfChildren = function() {\n                var noOfChildren = 0;\n                var childNode;\n                if (this.child == null) {\n                    noOfChildren = 1;\n                } else {\n                    var nodes = this.child.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        childNode = nodes[i];\n                        noOfChildren += childNode.getNoOfChildren();\n                    }\n                }\n                if (noOfChildren == 0) {\n                    noOfChildren = 1;\n                }\n                return noOfChildren;\n            };\n            LNode.prototype.getEstimatedSize = function() {\n                if (this.estimatedSize == Integer.MIN_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.estimatedSize;\n            };\n            LNode.prototype.calcEstimatedSize = function() {\n                if (this.child == null) {\n                    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n                } else {\n                    this.estimatedSize = this.child.calcEstimatedSize();\n                    this.rect.width = this.estimatedSize;\n                    this.rect.height = this.estimatedSize;\n                    return this.estimatedSize;\n                }\n            };\n            LNode.prototype.scatter = function() {\n                var randomCenterX;\n                var randomCenterY;\n                var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n                var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n                this.rect.x = randomCenterX;\n                this.rect.y = randomCenterY;\n            };\n            LNode.prototype.updateBounds = function() {\n                if (this.getChild() == null) {\n                    throw \"assert failed\";\n                }\n                if (this.getChild().getNodes().length != 0) {\n                    // wrap the children nodes by re-arranging the boundaries\n                    var childGraph = this.getChild();\n                    childGraph.updateBounds(true);\n                    this.rect.x = childGraph.getLeft();\n                    this.rect.y = childGraph.getTop();\n                    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n                    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n                    // Update compound bounds considering its label properties    \n                    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                        var width = childGraph.getRight() - childGraph.getLeft();\n                        var height = childGraph.getBottom() - childGraph.getTop();\n                        if (this.labelWidth) {\n                            if (this.labelPosHorizontal == \"left\") {\n                                this.rect.x -= this.labelWidth;\n                                this.setWidth(width + this.labelWidth);\n                            } else if (this.labelPosHorizontal == \"center\" && this.labelWidth > width) {\n                                this.rect.x -= (this.labelWidth - width) / 2;\n                                this.setWidth(this.labelWidth);\n                            } else if (this.labelPosHorizontal == \"right\") {\n                                this.setWidth(width + this.labelWidth);\n                            }\n                        }\n                        if (this.labelHeight) {\n                            if (this.labelPosVertical == \"top\") {\n                                this.rect.y -= this.labelHeight;\n                                this.setHeight(height + this.labelHeight);\n                            } else if (this.labelPosVertical == \"center\" && this.labelHeight > height) {\n                                this.rect.y -= (this.labelHeight - height) / 2;\n                                this.setHeight(this.labelHeight);\n                            } else if (this.labelPosVertical == \"bottom\") {\n                                this.setHeight(height + this.labelHeight);\n                            }\n                        }\n                    }\n                }\n            };\n            LNode.prototype.getInclusionTreeDepth = function() {\n                if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.inclusionTreeDepth;\n            };\n            LNode.prototype.transform = function(trans) {\n                var left = this.rect.x;\n                if (left > LayoutConstants.WORLD_BOUNDARY) {\n                    left = LayoutConstants.WORLD_BOUNDARY;\n                } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n                    left = -LayoutConstants.WORLD_BOUNDARY;\n                }\n                var top = this.rect.y;\n                if (top > LayoutConstants.WORLD_BOUNDARY) {\n                    top = LayoutConstants.WORLD_BOUNDARY;\n                } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n                    top = -LayoutConstants.WORLD_BOUNDARY;\n                }\n                var leftTop = new PointD(left, top);\n                var vLeftTop = trans.inverseTransformPoint(leftTop);\n                this.setLocation(vLeftTop.x, vLeftTop.y);\n            };\n            LNode.prototype.getLeft = function() {\n                return this.rect.x;\n            };\n            LNode.prototype.getRight = function() {\n                return this.rect.x + this.rect.width;\n            };\n            LNode.prototype.getTop = function() {\n                return this.rect.y;\n            };\n            LNode.prototype.getBottom = function() {\n                return this.rect.y + this.rect.height;\n            };\n            LNode.prototype.getParent = function() {\n                if (this.owner == null) {\n                    return null;\n                }\n                return this.owner.getParent();\n            };\n            module1.exports = LNode;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_23243__) {\n            \"use strict\";\n            var LayoutConstants = __nested_webpack_require_23243__(0);\n            function FDLayoutConstants() {}\n            //FDLayoutConstants inherits static props in LayoutConstants\n            for(var prop in LayoutConstants){\n                FDLayoutConstants[prop] = LayoutConstants[prop];\n            }\n            FDLayoutConstants.MAX_ITERATIONS = 2500;\n            FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n            FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\n            FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\n            FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\n            FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\n            FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\n            FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\n            FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\n            FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\n            FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n            FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\n            FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\n            FDLayoutConstants.MIN_EDGE_LENGTH = 1;\n            FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n            module1.exports = FDLayoutConstants;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function PointD(x, y) {\n                if (x == null && y == null) {\n                    this.x = 0;\n                    this.y = 0;\n                } else {\n                    this.x = x;\n                    this.y = y;\n                }\n            }\n            PointD.prototype.getX = function() {\n                return this.x;\n            };\n            PointD.prototype.getY = function() {\n                return this.y;\n            };\n            PointD.prototype.setX = function(x) {\n                this.x = x;\n            };\n            PointD.prototype.setY = function(y) {\n                this.y = y;\n            };\n            PointD.prototype.getDifference = function(pt) {\n                return new DimensionD(this.x - pt.x, this.y - pt.y);\n            };\n            PointD.prototype.getCopy = function() {\n                return new PointD(this.x, this.y);\n            };\n            PointD.prototype.translate = function(dim) {\n                this.x += dim.width;\n                this.y += dim.height;\n                return this;\n            };\n            module1.exports = PointD;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_26425__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_26425__(2);\n            var Integer = __nested_webpack_require_26425__(10);\n            var LayoutConstants = __nested_webpack_require_26425__(0);\n            var LGraphManager = __nested_webpack_require_26425__(7);\n            var LNode = __nested_webpack_require_26425__(3);\n            var LEdge = __nested_webpack_require_26425__(1);\n            var RectangleD = __nested_webpack_require_26425__(13);\n            var Point1 = __nested_webpack_require_26425__(12);\n            var LinkedList = __nested_webpack_require_26425__(11);\n            function LGraph(parent, obj2, vGraph) {\n                LGraphObject.call(this, vGraph);\n                this.estimatedSize = Integer.MIN_VALUE;\n                this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n                this.edges = [];\n                this.nodes = [];\n                this.isConnected = false;\n                this.parent = parent;\n                if (obj2 != null && obj2 instanceof LGraphManager) {\n                    this.graphManager = obj2;\n                } else if (obj2 != null && obj2 instanceof Layout) {\n                    this.graphManager = obj2.graphManager;\n                }\n            }\n            LGraph.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LGraph[prop] = LGraphObject[prop];\n            }\n            LGraph.prototype.getNodes = function() {\n                return this.nodes;\n            };\n            LGraph.prototype.getEdges = function() {\n                return this.edges;\n            };\n            LGraph.prototype.getGraphManager = function() {\n                return this.graphManager;\n            };\n            LGraph.prototype.getParent = function() {\n                return this.parent;\n            };\n            LGraph.prototype.getLeft = function() {\n                return this.left;\n            };\n            LGraph.prototype.getRight = function() {\n                return this.right;\n            };\n            LGraph.prototype.getTop = function() {\n                return this.top;\n            };\n            LGraph.prototype.getBottom = function() {\n                return this.bottom;\n            };\n            LGraph.prototype.isConnected = function() {\n                return this.isConnected;\n            };\n            LGraph.prototype.add = function(obj1, sourceNode, targetNode) {\n                if (sourceNode == null && targetNode == null) {\n                    var newNode = obj1;\n                    if (this.graphManager == null) {\n                        throw \"Graph has no graph mgr!\";\n                    }\n                    if (this.getNodes().indexOf(newNode) > -1) {\n                        throw \"Node already in graph!\";\n                    }\n                    newNode.owner = this;\n                    this.getNodes().push(newNode);\n                    return newNode;\n                } else {\n                    var newEdge = obj1;\n                    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n                        throw \"Source or target not in graph!\";\n                    }\n                    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n                        throw \"Both owners must be this graph!\";\n                    }\n                    if (sourceNode.owner != targetNode.owner) {\n                        return null;\n                    }\n                    // set source and target\n                    newEdge.source = sourceNode;\n                    newEdge.target = targetNode;\n                    // set as intra-graph edge\n                    newEdge.isInterGraph = false;\n                    // add to graph edge list\n                    this.getEdges().push(newEdge);\n                    // add to incidency lists\n                    sourceNode.edges.push(newEdge);\n                    if (targetNode != sourceNode) {\n                        targetNode.edges.push(newEdge);\n                    }\n                    return newEdge;\n                }\n            };\n            LGraph.prototype.remove = function(obj) {\n                var node = obj;\n                if (obj instanceof LNode) {\n                    if (node == null) {\n                        throw \"Node is null!\";\n                    }\n                    if (!(node.owner != null && node.owner == this)) {\n                        throw \"Owner graph is invalid!\";\n                    }\n                    if (this.graphManager == null) {\n                        throw \"Owner graph manager is invalid!\";\n                    }\n                    // remove incident edges first (make a copy to do it safely)\n                    var edgesToBeRemoved = node.edges.slice();\n                    var edge;\n                    var s = edgesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        edge = edgesToBeRemoved[i];\n                        if (edge.isInterGraph) {\n                            this.graphManager.remove(edge);\n                        } else {\n                            edge.source.owner.remove(edge);\n                        }\n                    }\n                    // now the node itself\n                    var index = this.nodes.indexOf(node);\n                    if (index == -1) {\n                        throw \"Node not in owner node list!\";\n                    }\n                    this.nodes.splice(index, 1);\n                } else if (obj instanceof LEdge) {\n                    var edge = obj;\n                    if (edge == null) {\n                        throw \"Edge is null!\";\n                    }\n                    if (!(edge.source != null && edge.target != null)) {\n                        throw \"Source and/or target is null!\";\n                    }\n                    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n                        throw \"Source and/or target owner is invalid!\";\n                    }\n                    var sourceIndex = edge.source.edges.indexOf(edge);\n                    var targetIndex = edge.target.edges.indexOf(edge);\n                    if (!(sourceIndex > -1 && targetIndex > -1)) {\n                        throw \"Source and/or target doesn't know this edge!\";\n                    }\n                    edge.source.edges.splice(sourceIndex, 1);\n                    if (edge.target != edge.source) {\n                        edge.target.edges.splice(targetIndex, 1);\n                    }\n                    var index = edge.source.owner.getEdges().indexOf(edge);\n                    if (index == -1) {\n                        throw \"Not in owner's edge list!\";\n                    }\n                    edge.source.owner.getEdges().splice(index, 1);\n                }\n            };\n            LGraph.prototype.updateLeftTop = function() {\n                var top = Integer.MAX_VALUE;\n                var left = Integer.MAX_VALUE;\n                var nodeTop;\n                var nodeLeft;\n                var margin;\n                var nodes = this.getNodes();\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    nodeTop = lNode.getTop();\n                    nodeLeft = lNode.getLeft();\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                }\n                // Do we have any nodes in this graph?\n                if (top == Integer.MAX_VALUE) {\n                    return null;\n                }\n                if (nodes[0].getParent().paddingLeft != undefined) {\n                    margin = nodes[0].getParent().paddingLeft;\n                } else {\n                    margin = this.margin;\n                }\n                this.left = left - margin;\n                this.top = top - margin;\n                // Apply the margins and return the result\n                return new Point1(this.left, this.top);\n            };\n            LGraph.prototype.updateBounds = function(recursive) {\n                // calculate bounds\n                var left = Integer.MAX_VALUE;\n                var right = -Integer.MAX_VALUE;\n                var top = Integer.MAX_VALUE;\n                var bottom = -Integer.MAX_VALUE;\n                var nodeLeft;\n                var nodeRight;\n                var nodeTop;\n                var nodeBottom;\n                var margin;\n                var nodes = this.nodes;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    if (recursive && lNode.child != null) {\n                        lNode.updateBounds();\n                    }\n                    nodeLeft = lNode.getLeft();\n                    nodeRight = lNode.getRight();\n                    nodeTop = lNode.getTop();\n                    nodeBottom = lNode.getBottom();\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                        right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                        bottom = nodeBottom;\n                    }\n                }\n                var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n                if (left == Integer.MAX_VALUE) {\n                    this.left = this.parent.getLeft();\n                    this.right = this.parent.getRight();\n                    this.top = this.parent.getTop();\n                    this.bottom = this.parent.getBottom();\n                }\n                if (nodes[0].getParent().paddingLeft != undefined) {\n                    margin = nodes[0].getParent().paddingLeft;\n                } else {\n                    margin = this.margin;\n                }\n                this.left = boundingRect.x - margin;\n                this.right = boundingRect.x + boundingRect.width + margin;\n                this.top = boundingRect.y - margin;\n                this.bottom = boundingRect.y + boundingRect.height + margin;\n            };\n            LGraph.calculateBounds = function(nodes) {\n                var left = Integer.MAX_VALUE;\n                var right = -Integer.MAX_VALUE;\n                var top = Integer.MAX_VALUE;\n                var bottom = -Integer.MAX_VALUE;\n                var nodeLeft;\n                var nodeRight;\n                var nodeTop;\n                var nodeBottom;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    nodeLeft = lNode.getLeft();\n                    nodeRight = lNode.getRight();\n                    nodeTop = lNode.getTop();\n                    nodeBottom = lNode.getBottom();\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                        right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                        bottom = nodeBottom;\n                    }\n                }\n                var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n                return boundingRect;\n            };\n            LGraph.prototype.getInclusionTreeDepth = function() {\n                if (this == this.graphManager.getRoot()) {\n                    return 1;\n                } else {\n                    return this.parent.getInclusionTreeDepth();\n                }\n            };\n            LGraph.prototype.getEstimatedSize = function() {\n                if (this.estimatedSize == Integer.MIN_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.estimatedSize;\n            };\n            LGraph.prototype.calcEstimatedSize = function() {\n                var size = 0;\n                var nodes = this.nodes;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    size += lNode.calcEstimatedSize();\n                }\n                if (size == 0) {\n                    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n                } else {\n                    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n                }\n                return this.estimatedSize;\n            };\n            LGraph.prototype.updateConnected = function() {\n                var self = this;\n                if (this.nodes.length == 0) {\n                    this.isConnected = true;\n                    return;\n                }\n                var queue = new LinkedList();\n                var visited = new Set();\n                var currentNode = this.nodes[0];\n                var neighborEdges;\n                var currentNeighbor;\n                var childrenOfNode = currentNode.withChildren();\n                childrenOfNode.forEach(function(node) {\n                    queue.push(node);\n                    visited.add(node);\n                });\n                while(queue.length !== 0){\n                    currentNode = queue.shift();\n                    // Traverse all neighbors of this node\n                    neighborEdges = currentNode.getEdges();\n                    var size = neighborEdges.length;\n                    for(var i = 0; i < size; i++){\n                        var neighborEdge = neighborEdges[i];\n                        currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n                        // Add unvisited neighbors to the list to visit\n                        if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n                            var childrenOfNeighbor = currentNeighbor.withChildren();\n                            childrenOfNeighbor.forEach(function(node) {\n                                queue.push(node);\n                                visited.add(node);\n                            });\n                        }\n                    }\n                }\n                this.isConnected = false;\n                if (visited.size >= this.nodes.length) {\n                    var noOfVisitedInThisGraph = 0;\n                    visited.forEach(function(visitedNode) {\n                        if (visitedNode.owner == self) {\n                            noOfVisitedInThisGraph++;\n                        }\n                    });\n                    if (noOfVisitedInThisGraph == this.nodes.length) {\n                        this.isConnected = true;\n                    }\n                }\n            };\n            module1.exports = LGraph;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_41561__) {\n            \"use strict\";\n            var LGraph;\n            var LEdge = __nested_webpack_require_41561__(1);\n            function LGraphManager(layout) {\n                LGraph = __nested_webpack_require_41561__(6); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n                this.layout = layout;\n                this.graphs = [];\n                this.edges = [];\n            }\n            LGraphManager.prototype.addRoot = function() {\n                var ngraph = this.layout.newGraph();\n                var nnode = this.layout.newNode(null);\n                var root = this.add(ngraph, nnode);\n                this.setRootGraph(root);\n                return this.rootGraph;\n            };\n            LGraphManager.prototype.add = function(newGraph, parentNode, newEdge, sourceNode, targetNode) {\n                //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n                if (newEdge == null && sourceNode == null && targetNode == null) {\n                    if (newGraph == null) {\n                        throw \"Graph is null!\";\n                    }\n                    if (parentNode == null) {\n                        throw \"Parent node is null!\";\n                    }\n                    if (this.graphs.indexOf(newGraph) > -1) {\n                        throw \"Graph already in this graph mgr!\";\n                    }\n                    this.graphs.push(newGraph);\n                    if (newGraph.parent != null) {\n                        throw \"Already has a parent!\";\n                    }\n                    if (parentNode.child != null) {\n                        throw \"Already has a child!\";\n                    }\n                    newGraph.parent = parentNode;\n                    parentNode.child = newGraph;\n                    return newGraph;\n                } else {\n                    //change the order of the parameters\n                    targetNode = newEdge;\n                    sourceNode = parentNode;\n                    newEdge = newGraph;\n                    var sourceGraph = sourceNode.getOwner();\n                    var targetGraph = targetNode.getOwner();\n                    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n                        throw \"Source not in this graph mgr!\";\n                    }\n                    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n                        throw \"Target not in this graph mgr!\";\n                    }\n                    if (sourceGraph == targetGraph) {\n                        newEdge.isInterGraph = false;\n                        return sourceGraph.add(newEdge, sourceNode, targetNode);\n                    } else {\n                        newEdge.isInterGraph = true;\n                        // set source and target\n                        newEdge.source = sourceNode;\n                        newEdge.target = targetNode;\n                        // add edge to inter-graph edge list\n                        if (this.edges.indexOf(newEdge) > -1) {\n                            throw \"Edge already in inter-graph edge list!\";\n                        }\n                        this.edges.push(newEdge);\n                        // add edge to source and target incidency lists\n                        if (!(newEdge.source != null && newEdge.target != null)) {\n                            throw \"Edge source and/or target is null!\";\n                        }\n                        if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n                            throw \"Edge already in source and/or target incidency list!\";\n                        }\n                        newEdge.source.edges.push(newEdge);\n                        newEdge.target.edges.push(newEdge);\n                        return newEdge;\n                    }\n                }\n            };\n            LGraphManager.prototype.remove = function(lObj) {\n                if (lObj instanceof LGraph) {\n                    var graph = lObj;\n                    if (graph.getGraphManager() != this) {\n                        throw \"Graph not in this graph mgr\";\n                    }\n                    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n                        throw \"Invalid parent node!\";\n                    }\n                    // first the edges (make a copy to do it safely)\n                    var edgesToBeRemoved = [];\n                    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n                    var edge;\n                    var s = edgesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        edge = edgesToBeRemoved[i];\n                        graph.remove(edge);\n                    }\n                    // then the nodes (make a copy to do it safely)\n                    var nodesToBeRemoved = [];\n                    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n                    var node;\n                    s = nodesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        node = nodesToBeRemoved[i];\n                        graph.remove(node);\n                    }\n                    // check if graph is the root\n                    if (graph == this.rootGraph) {\n                        this.setRootGraph(null);\n                    }\n                    // now remove the graph itself\n                    var index = this.graphs.indexOf(graph);\n                    this.graphs.splice(index, 1);\n                    // also reset the parent of the graph\n                    graph.parent = null;\n                } else if (lObj instanceof LEdge) {\n                    edge = lObj;\n                    if (edge == null) {\n                        throw \"Edge is null!\";\n                    }\n                    if (!edge.isInterGraph) {\n                        throw \"Not an inter-graph edge!\";\n                    }\n                    if (!(edge.source != null && edge.target != null)) {\n                        throw \"Source and/or target is null!\";\n                    }\n                    // remove edge from source and target nodes' incidency lists\n                    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n                        throw \"Source and/or target doesn't know this edge!\";\n                    }\n                    var index = edge.source.edges.indexOf(edge);\n                    edge.source.edges.splice(index, 1);\n                    index = edge.target.edges.indexOf(edge);\n                    edge.target.edges.splice(index, 1);\n                    // remove edge from owner graph manager's inter-graph edge list\n                    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n                        throw \"Edge owner graph or owner graph manager is null!\";\n                    }\n                    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n                        throw \"Not in owner graph manager's edge list!\";\n                    }\n                    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n                    edge.source.owner.getGraphManager().edges.splice(index, 1);\n                }\n            };\n            LGraphManager.prototype.updateBounds = function() {\n                this.rootGraph.updateBounds(true);\n            };\n            LGraphManager.prototype.getGraphs = function() {\n                return this.graphs;\n            };\n            LGraphManager.prototype.getAllNodes = function() {\n                if (this.allNodes == null) {\n                    var nodeList = [];\n                    var graphs = this.getGraphs();\n                    var s = graphs.length;\n                    for(var i = 0; i < s; i++){\n                        nodeList = nodeList.concat(graphs[i].getNodes());\n                    }\n                    this.allNodes = nodeList;\n                }\n                return this.allNodes;\n            };\n            LGraphManager.prototype.resetAllNodes = function() {\n                this.allNodes = null;\n            };\n            LGraphManager.prototype.resetAllEdges = function() {\n                this.allEdges = null;\n            };\n            LGraphManager.prototype.resetAllNodesToApplyGravitation = function() {\n                this.allNodesToApplyGravitation = null;\n            };\n            LGraphManager.prototype.getAllEdges = function() {\n                if (this.allEdges == null) {\n                    var edgeList = [];\n                    var graphs = this.getGraphs();\n                    var s = graphs.length;\n                    for(var i = 0; i < graphs.length; i++){\n                        edgeList = edgeList.concat(graphs[i].getEdges());\n                    }\n                    edgeList = edgeList.concat(this.edges);\n                    this.allEdges = edgeList;\n                }\n                return this.allEdges;\n            };\n            LGraphManager.prototype.getAllNodesToApplyGravitation = function() {\n                return this.allNodesToApplyGravitation;\n            };\n            LGraphManager.prototype.setAllNodesToApplyGravitation = function(nodeList) {\n                if (this.allNodesToApplyGravitation != null) {\n                    throw \"assert failed\";\n                }\n                this.allNodesToApplyGravitation = nodeList;\n            };\n            LGraphManager.prototype.getRoot = function() {\n                return this.rootGraph;\n            };\n            LGraphManager.prototype.setRootGraph = function(graph) {\n                if (graph.getGraphManager() != this) {\n                    throw \"Root not in this graph mgr!\";\n                }\n                this.rootGraph = graph;\n                // root graph must have a root node associated with it for convenience\n                if (graph.parent == null) {\n                    graph.parent = this.layout.newNode(\"Root node\");\n                }\n            };\n            LGraphManager.prototype.getLayout = function() {\n                return this.layout;\n            };\n            LGraphManager.prototype.isOneAncestorOfOther = function(firstNode, secondNode) {\n                if (!(firstNode != null && secondNode != null)) {\n                    throw \"assert failed\";\n                }\n                if (firstNode == secondNode) {\n                    return true;\n                }\n                // Is second node an ancestor of the first one?\n                var ownerGraph = firstNode.getOwner();\n                var parentNode;\n                do {\n                    parentNode = ownerGraph.getParent();\n                    if (parentNode == null) {\n                        break;\n                    }\n                    if (parentNode == secondNode) {\n                        return true;\n                    }\n                    ownerGraph = parentNode.getOwner();\n                    if (ownerGraph == null) {\n                        break;\n                    }\n                }while (true);\n                // Is first node an ancestor of the second one?\n                ownerGraph = secondNode.getOwner();\n                do {\n                    parentNode = ownerGraph.getParent();\n                    if (parentNode == null) {\n                        break;\n                    }\n                    if (parentNode == firstNode) {\n                        return true;\n                    }\n                    ownerGraph = parentNode.getOwner();\n                    if (ownerGraph == null) {\n                        break;\n                    }\n                }while (true);\n                return false;\n            };\n            LGraphManager.prototype.calcLowestCommonAncestors = function() {\n                var edge;\n                var sourceNode;\n                var targetNode;\n                var sourceAncestorGraph;\n                var targetAncestorGraph;\n                var edges = this.getAllEdges();\n                var s = edges.length;\n                for(var i = 0; i < s; i++){\n                    edge = edges[i];\n                    sourceNode = edge.source;\n                    targetNode = edge.target;\n                    edge.lca = null;\n                    edge.sourceInLca = sourceNode;\n                    edge.targetInLca = targetNode;\n                    if (sourceNode == targetNode) {\n                        edge.lca = sourceNode.getOwner();\n                        continue;\n                    }\n                    sourceAncestorGraph = sourceNode.getOwner();\n                    while(edge.lca == null){\n                        edge.targetInLca = targetNode;\n                        targetAncestorGraph = targetNode.getOwner();\n                        while(edge.lca == null){\n                            if (targetAncestorGraph == sourceAncestorGraph) {\n                                edge.lca = targetAncestorGraph;\n                                break;\n                            }\n                            if (targetAncestorGraph == this.rootGraph) {\n                                break;\n                            }\n                            if (edge.lca != null) {\n                                throw \"assert failed\";\n                            }\n                            edge.targetInLca = targetAncestorGraph.getParent();\n                            targetAncestorGraph = edge.targetInLca.getOwner();\n                        }\n                        if (sourceAncestorGraph == this.rootGraph) {\n                            break;\n                        }\n                        if (edge.lca == null) {\n                            edge.sourceInLca = sourceAncestorGraph.getParent();\n                            sourceAncestorGraph = edge.sourceInLca.getOwner();\n                        }\n                    }\n                    if (edge.lca == null) {\n                        throw \"assert failed\";\n                    }\n                }\n            };\n            LGraphManager.prototype.calcLowestCommonAncestor = function(firstNode, secondNode) {\n                if (firstNode == secondNode) {\n                    return firstNode.getOwner();\n                }\n                var firstOwnerGraph = firstNode.getOwner();\n                do {\n                    if (firstOwnerGraph == null) {\n                        break;\n                    }\n                    var secondOwnerGraph = secondNode.getOwner();\n                    do {\n                        if (secondOwnerGraph == null) {\n                            break;\n                        }\n                        if (secondOwnerGraph == firstOwnerGraph) {\n                            return secondOwnerGraph;\n                        }\n                        secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n                    }while (true);\n                    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n                }while (true);\n                return firstOwnerGraph;\n            };\n            LGraphManager.prototype.calcInclusionTreeDepths = function(graph, depth) {\n                if (graph == null && depth == null) {\n                    graph = this.rootGraph;\n                    depth = 1;\n                }\n                var node;\n                var nodes = graph.getNodes();\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    node = nodes[i];\n                    node.inclusionTreeDepth = depth;\n                    if (node.child != null) {\n                        this.calcInclusionTreeDepths(node.child, depth + 1);\n                    }\n                }\n            };\n            LGraphManager.prototype.includesInvalidEdge = function() {\n                var edge;\n                var edgesToRemove = [];\n                var s = this.edges.length;\n                for(var i = 0; i < s; i++){\n                    edge = this.edges[i];\n                    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n                        edgesToRemove.push(edge);\n                    }\n                }\n                // Remove invalid edges from graph manager\n                for(var i = 0; i < edgesToRemove.length; i++){\n                    this.remove(edgesToRemove[i]);\n                }\n                // Invalid edges are cleared, so return false\n                return false;\n            };\n            module1.exports = LGraphManager;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_58301__) {\n            \"use strict\";\n            /**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */ var Point1 = __nested_webpack_require_58301__(12);\n            function IGeometry() {}\n            /**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */ IGeometry.calcSeparationAmount = function(rectA, rectB, overlapAmount, separationBuffer) {\n                if (!rectA.intersects(rectB)) {\n                    throw \"assert failed\";\n                }\n                var directions = new Array(2);\n                this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n                overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n                overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n                // update the overlapping amounts for the following cases:\n                if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n                    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */ overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n                } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n                    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */ overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n                }\n                if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n                    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */ overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n                } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n                    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */ overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n                }\n                // find slope of the line passes two centers\n                var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n                // if centers are overlapped\n                if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n                    // assume the slope is 1 (45 degree)\n                    slope = 1.0;\n                }\n                var moveByY = slope * overlapAmount[0];\n                var moveByX = overlapAmount[1] / slope;\n                if (overlapAmount[0] < moveByX) {\n                    moveByX = overlapAmount[0];\n                } else {\n                    moveByY = overlapAmount[1];\n                }\n                // return half the amount so that if each rectangle is moved by these\n                // amounts in opposite directions, overlap will be resolved\n                overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n                overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n            };\n            /**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */ IGeometry.decideDirectionsForOverlappingNodes = function(rectA, rectB, directions) {\n                if (rectA.getCenterX() < rectB.getCenterX()) {\n                    directions[0] = -1;\n                } else {\n                    directions[0] = 1;\n                }\n                if (rectA.getCenterY() < rectB.getCenterY()) {\n                    directions[1] = -1;\n                } else {\n                    directions[1] = 1;\n                }\n            };\n            /**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */ IGeometry.getIntersection2 = function(rectA, rectB, result) {\n                //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n                var p1x = rectA.getCenterX();\n                var p1y = rectA.getCenterY();\n                var p2x = rectB.getCenterX();\n                var p2y = rectB.getCenterY();\n                //if two rectangles intersect, then clipping points are centers\n                if (rectA.intersects(rectB)) {\n                    result[0] = p1x;\n                    result[1] = p1y;\n                    result[2] = p2x;\n                    result[3] = p2y;\n                    return true;\n                }\n                //variables for rectA\n                var topLeftAx = rectA.getX();\n                var topLeftAy = rectA.getY();\n                var topRightAx = rectA.getRight();\n                var bottomLeftAx = rectA.getX();\n                var bottomLeftAy = rectA.getBottom();\n                var bottomRightAx = rectA.getRight();\n                var halfWidthA = rectA.getWidthHalf();\n                var halfHeightA = rectA.getHeightHalf();\n                //variables for rectB\n                var topLeftBx = rectB.getX();\n                var topLeftBy = rectB.getY();\n                var topRightBx = rectB.getRight();\n                var bottomLeftBx = rectB.getX();\n                var bottomLeftBy = rectB.getBottom();\n                var bottomRightBx = rectB.getRight();\n                var halfWidthB = rectB.getWidthHalf();\n                var halfHeightB = rectB.getHeightHalf();\n                //flag whether clipping points are found\n                var clipPointAFound = false;\n                var clipPointBFound = false;\n                // line is vertical\n                if (p1x === p2x) {\n                    if (p1y > p2y) {\n                        result[0] = p1x;\n                        result[1] = topLeftAy;\n                        result[2] = p2x;\n                        result[3] = bottomLeftBy;\n                        return false;\n                    } else if (p1y < p2y) {\n                        result[0] = p1x;\n                        result[1] = bottomLeftAy;\n                        result[2] = p2x;\n                        result[3] = topLeftBy;\n                        return false;\n                    } else {\n                    //not line, return null;\n                    }\n                } else if (p1y === p2y) {\n                    if (p1x > p2x) {\n                        result[0] = topLeftAx;\n                        result[1] = p1y;\n                        result[2] = topRightBx;\n                        result[3] = p2y;\n                        return false;\n                    } else if (p1x < p2x) {\n                        result[0] = topRightAx;\n                        result[1] = p1y;\n                        result[2] = topLeftBx;\n                        result[3] = p2y;\n                        return false;\n                    } else {\n                    //not valid line, return null;\n                    }\n                } else {\n                    //slopes of rectA's and rectB's diagonals\n                    var slopeA = rectA.height / rectA.width;\n                    var slopeB = rectB.height / rectB.width;\n                    //slope of line between center of rectA and center of rectB\n                    var slopePrime = (p2y - p1y) / (p2x - p1x);\n                    var cardinalDirectionA = void 0;\n                    var cardinalDirectionB = void 0;\n                    var tempPointAx = void 0;\n                    var tempPointAy = void 0;\n                    var tempPointBx = void 0;\n                    var tempPointBy = void 0;\n                    //determine whether clipping point is the corner of nodeA\n                    if (-slopeA === slopePrime) {\n                        if (p1x > p2x) {\n                            result[0] = bottomLeftAx;\n                            result[1] = bottomLeftAy;\n                            clipPointAFound = true;\n                        } else {\n                            result[0] = topRightAx;\n                            result[1] = topLeftAy;\n                            clipPointAFound = true;\n                        }\n                    } else if (slopeA === slopePrime) {\n                        if (p1x > p2x) {\n                            result[0] = topLeftAx;\n                            result[1] = topLeftAy;\n                            clipPointAFound = true;\n                        } else {\n                            result[0] = bottomRightAx;\n                            result[1] = bottomLeftAy;\n                            clipPointAFound = true;\n                        }\n                    }\n                    //determine whether clipping point is the corner of nodeB\n                    if (-slopeB === slopePrime) {\n                        if (p2x > p1x) {\n                            result[2] = bottomLeftBx;\n                            result[3] = bottomLeftBy;\n                            clipPointBFound = true;\n                        } else {\n                            result[2] = topRightBx;\n                            result[3] = topLeftBy;\n                            clipPointBFound = true;\n                        }\n                    } else if (slopeB === slopePrime) {\n                        if (p2x > p1x) {\n                            result[2] = topLeftBx;\n                            result[3] = topLeftBy;\n                            clipPointBFound = true;\n                        } else {\n                            result[2] = bottomRightBx;\n                            result[3] = bottomLeftBy;\n                            clipPointBFound = true;\n                        }\n                    }\n                    //if both clipping points are corners\n                    if (clipPointAFound && clipPointBFound) {\n                        return false;\n                    }\n                    //determine Cardinal Direction of rectangles\n                    if (p1x > p2x) {\n                        if (p1y > p2y) {\n                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n                        } else {\n                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n                        }\n                    } else {\n                        if (p1y > p2y) {\n                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n                        } else {\n                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n                        }\n                    }\n                    //calculate clipping Point if it is not found before\n                    if (!clipPointAFound) {\n                        switch(cardinalDirectionA){\n                            case 1:\n                                tempPointAy = topLeftAy;\n                                tempPointAx = p1x + -halfHeightA / slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 2:\n                                tempPointAx = bottomRightAx;\n                                tempPointAy = p1y + halfWidthA * slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 3:\n                                tempPointAy = bottomLeftAy;\n                                tempPointAx = p1x + halfHeightA / slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 4:\n                                tempPointAx = bottomLeftAx;\n                                tempPointAy = p1y + -halfWidthA * slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                        }\n                    }\n                    if (!clipPointBFound) {\n                        switch(cardinalDirectionB){\n                            case 1:\n                                tempPointBy = topLeftBy;\n                                tempPointBx = p2x + -halfHeightB / slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 2:\n                                tempPointBx = bottomRightBx;\n                                tempPointBy = p2y + halfWidthB * slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 3:\n                                tempPointBy = bottomLeftBy;\n                                tempPointBx = p2x + halfHeightB / slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 4:\n                                tempPointBx = bottomLeftBx;\n                                tempPointBy = p2y + -halfWidthB * slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                        }\n                    }\n                }\n                return false;\n            };\n            /**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */ IGeometry.getCardinalDirection = function(slope, slopePrime, line) {\n                if (slope > slopePrime) {\n                    return line;\n                } else {\n                    return 1 + line % 4;\n                }\n            };\n            /**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */ IGeometry.getIntersection = function(s1, s2, f1, f2) {\n                if (f2 == null) {\n                    return this.getIntersection2(s1, s2, f1);\n                }\n                var x1 = s1.x;\n                var y1 = s1.y;\n                var x2 = s2.x;\n                var y2 = s2.y;\n                var x3 = f1.x;\n                var y3 = f1.y;\n                var x4 = f2.x;\n                var y4 = f2.y;\n                var x = void 0, y = void 0; // intersection point\n                var a1 = void 0, a2 = void 0, b1 = void 0, b2 = void 0, c1 = void 0, c2 = void 0; // coefficients of line eqns.\n                var denom = void 0;\n                a1 = y2 - y1;\n                b1 = x1 - x2;\n                c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n                a2 = y4 - y3;\n                b2 = x3 - x4;\n                c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n                denom = a1 * b2 - a2 * b1;\n                if (denom === 0) {\n                    return null;\n                }\n                x = (b1 * c2 - b2 * c1) / denom;\n                y = (a2 * c1 - a1 * c2) / denom;\n                return new Point1(x, y);\n            };\n            /**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */ IGeometry.angleOfVector = function(Cx, Cy, Nx, Ny) {\n                var C_angle = void 0;\n                if (Cx !== Nx) {\n                    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n                    if (Nx < Cx) {\n                        C_angle += Math.PI;\n                    } else if (Ny < Cy) {\n                        C_angle += this.TWO_PI;\n                    }\n                } else if (Ny < Cy) {\n                    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n                } else {\n                    C_angle = this.HALF_PI; // 90 degrees\n                }\n                return C_angle;\n            };\n            /**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */ IGeometry.doIntersect = function(p1, p2, p3, p4) {\n                var a = p1.x;\n                var b = p1.y;\n                var c = p2.x;\n                var d = p2.y;\n                var p = p3.x;\n                var q = p3.y;\n                var r = p4.x;\n                var s = p4.y;\n                var det = (c - a) * (s - q) - (r - p) * (d - b);\n                if (det === 0) {\n                    return false;\n                } else {\n                    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n                    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n                    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n                }\n            };\n            /**\n * This method checks and calculates the intersection of \n * a line segment and a circle.\n */ IGeometry.findCircleLineIntersections = function(Ex, Ey, Lx, Ly, Cx, Cy, r) {\n                // E is the starting point of the ray,\n                // L is the end point of the ray,\n                // C is the center of sphere you're testing against\n                // r is the radius of that sphere\n                // Compute:\n                // d = L - E ( Direction vector of ray, from start to end )\n                // f = E - C ( Vector from center sphere to ray start )\n                // Then the intersection is found by..\n                // P = E + t * d\n                // This is a parametric equation:\n                // Px = Ex + tdx\n                // Py = Ey + tdy\n                // get a, b, c values\n                var a = (Lx - Ex) * (Lx - Ex) + (Ly - Ey) * (Ly - Ey);\n                var b = 2 * ((Ex - Cx) * (Lx - Ex) + (Ey - Cy) * (Ly - Ey));\n                var c = (Ex - Cx) * (Ex - Cx) + (Ey - Cy) * (Ey - Cy) - r * r;\n                // get discriminant\n                var disc = b * b - 4 * a * c;\n                if (disc >= 0) {\n                    // insert into quadratic formula\n                    var t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n                    var t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n                    var intersections = null;\n                    if (t1 >= 0 && t1 <= 1) {\n                        // t1 is the intersection, and it's closer than t2\n                        // (since t1 uses -b - discriminant)\n                        // Impale, Poke\n                        return [\n                            t1\n                        ];\n                    }\n                    // here t1 didn't intersect so we are either started\n                    // inside the sphere or completely past it\n                    if (t2 >= 0 && t2 <= 1) {\n                        // ExitWound\n                        return [\n                            t2\n                        ];\n                    }\n                    return intersections;\n                } else return null;\n            };\n            // -----------------------------------------------------------------------------\n            // Section: Class Constants\n            // -----------------------------------------------------------------------------\n            /**\n * Some useful pre-calculated constants\n */ IGeometry.HALF_PI = 0.5 * Math.PI;\n            IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\n            IGeometry.TWO_PI = 2.0 * Math.PI;\n            IGeometry.THREE_PI = 3.0 * Math.PI;\n            module1.exports = IGeometry;\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function IMath() {}\n            /**\n * This method returns the sign of the input value.\n */ IMath.sign = function(value) {\n                if (value > 0) {\n                    return 1;\n                } else if (value < 0) {\n                    return -1;\n                } else {\n                    return 0;\n                }\n            };\n            IMath.floor = function(value) {\n                return value < 0 ? Math.ceil(value) : Math.floor(value);\n            };\n            IMath.ceil = function(value) {\n                return value < 0 ? Math.floor(value) : Math.ceil(value);\n            };\n            module1.exports = IMath;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function Integer() {}\n            Integer.MAX_VALUE = 2147483647;\n            Integer.MIN_VALUE = -2147483648;\n            module1.exports = Integer;\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var nodeFrom = function nodeFrom(value) {\n                return {\n                    value: value,\n                    next: null,\n                    prev: null\n                };\n            };\n            var add = function add(prev, node, next, list) {\n                if (prev !== null) {\n                    prev.next = node;\n                } else {\n                    list.head = node;\n                }\n                if (next !== null) {\n                    next.prev = node;\n                } else {\n                    list.tail = node;\n                }\n                node.prev = prev;\n                node.next = next;\n                list.length++;\n                return node;\n            };\n            var _remove = function _remove(node, list) {\n                var prev = node.prev, next = node.next;\n                if (prev !== null) {\n                    prev.next = next;\n                } else {\n                    list.head = next;\n                }\n                if (next !== null) {\n                    next.prev = prev;\n                } else {\n                    list.tail = prev;\n                }\n                node.prev = node.next = null;\n                list.length--;\n                return node;\n            };\n            var LinkedList = function() {\n                function LinkedList(vals) {\n                    var _this = this;\n                    _classCallCheck(this, LinkedList);\n                    this.length = 0;\n                    this.head = null;\n                    this.tail = null;\n                    if (vals != null) {\n                        vals.forEach(function(v) {\n                            return _this.push(v);\n                        });\n                    }\n                }\n                _createClass(LinkedList, [\n                    {\n                        key: \"size\",\n                        value: function size() {\n                            return this.length;\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(val, otherNode) {\n                            return add(otherNode.prev, nodeFrom(val), otherNode, this);\n                        }\n                    },\n                    {\n                        key: \"insertAfter\",\n                        value: function insertAfter(val, otherNode) {\n                            return add(otherNode, nodeFrom(val), otherNode.next, this);\n                        }\n                    },\n                    {\n                        key: \"insertNodeBefore\",\n                        value: function insertNodeBefore(newNode, otherNode) {\n                            return add(otherNode.prev, newNode, otherNode, this);\n                        }\n                    },\n                    {\n                        key: \"insertNodeAfter\",\n                        value: function insertNodeAfter(newNode, otherNode) {\n                            return add(otherNode, newNode, otherNode.next, this);\n                        }\n                    },\n                    {\n                        key: \"push\",\n                        value: function push(val) {\n                            return add(this.tail, nodeFrom(val), null, this);\n                        }\n                    },\n                    {\n                        key: \"unshift\",\n                        value: function unshift(val) {\n                            return add(null, nodeFrom(val), this.head, this);\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove(node) {\n                            return _remove(node, this);\n                        }\n                    },\n                    {\n                        key: \"pop\",\n                        value: function pop() {\n                            return _remove(this.tail, this).value;\n                        }\n                    },\n                    {\n                        key: \"popNode\",\n                        value: function popNode() {\n                            return _remove(this.tail, this);\n                        }\n                    },\n                    {\n                        key: \"shift\",\n                        value: function shift() {\n                            return _remove(this.head, this).value;\n                        }\n                    },\n                    {\n                        key: \"shiftNode\",\n                        value: function shiftNode() {\n                            return _remove(this.head, this);\n                        }\n                    },\n                    {\n                        key: \"get_object_at\",\n                        value: function get_object_at(index) {\n                            if (index <= this.length()) {\n                                var i = 1;\n                                var current = this.head;\n                                while(i < index){\n                                    current = current.next;\n                                    i++;\n                                }\n                                return current.value;\n                            }\n                        }\n                    },\n                    {\n                        key: \"set_object_at\",\n                        value: function set_object_at(index, value) {\n                            if (index <= this.length()) {\n                                var i = 1;\n                                var current = this.head;\n                                while(i < index){\n                                    current = current.next;\n                                    i++;\n                                }\n                                current.value = value;\n                            }\n                        }\n                    }\n                ]);\n                return LinkedList;\n            }();\n            module1.exports = LinkedList;\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */ function Point1(x, y, p) {\n                this.x = null;\n                this.y = null;\n                if (x == null && y == null && p == null) {\n                    this.x = 0;\n                    this.y = 0;\n                } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                    this.x = x;\n                    this.y = y;\n                } else if (x.constructor.name == \"Point\" && y == null && p == null) {\n                    p = x;\n                    this.x = p.x;\n                    this.y = p.y;\n                }\n            }\n            Point1.prototype.getX = function() {\n                return this.x;\n            };\n            Point1.prototype.getY = function() {\n                return this.y;\n            };\n            Point1.prototype.getLocation = function() {\n                return new Point1(this.x, this.y);\n            };\n            Point1.prototype.setLocation = function(x, y, p) {\n                if (x.constructor.name == \"Point\" && y == null && p == null) {\n                    p = x;\n                    this.setLocation(p.x, p.y);\n                } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                    //if both parameters are integer just move (x,y) location\n                    if (parseInt(x) == x && parseInt(y) == y) {\n                        this.move(x, y);\n                    } else {\n                        this.x = Math.floor(x + 0.5);\n                        this.y = Math.floor(y + 0.5);\n                    }\n                }\n            };\n            Point1.prototype.move = function(x, y) {\n                this.x = x;\n                this.y = y;\n            };\n            Point1.prototype.translate = function(dx, dy) {\n                this.x += dx;\n                this.y += dy;\n            };\n            Point1.prototype.equals = function(obj) {\n                if (obj.constructor.name == \"Point\") {\n                    var pt = obj;\n                    return this.x == pt.x && this.y == pt.y;\n                }\n                return this == obj;\n            };\n            Point1.prototype.toString = function() {\n                return new Point1().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n            };\n            module1.exports = Point1;\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function RectangleD(x, y, width, height) {\n                this.x = 0;\n                this.y = 0;\n                this.width = 0;\n                this.height = 0;\n                if (x != null && y != null && width != null && height != null) {\n                    this.x = x;\n                    this.y = y;\n                    this.width = width;\n                    this.height = height;\n                }\n            }\n            RectangleD.prototype.getX = function() {\n                return this.x;\n            };\n            RectangleD.prototype.setX = function(x) {\n                this.x = x;\n            };\n            RectangleD.prototype.getY = function() {\n                return this.y;\n            };\n            RectangleD.prototype.setY = function(y) {\n                this.y = y;\n            };\n            RectangleD.prototype.getWidth = function() {\n                return this.width;\n            };\n            RectangleD.prototype.setWidth = function(width) {\n                this.width = width;\n            };\n            RectangleD.prototype.getHeight = function() {\n                return this.height;\n            };\n            RectangleD.prototype.setHeight = function(height) {\n                this.height = height;\n            };\n            RectangleD.prototype.getRight = function() {\n                return this.x + this.width;\n            };\n            RectangleD.prototype.getBottom = function() {\n                return this.y + this.height;\n            };\n            RectangleD.prototype.intersects = function(a) {\n                if (this.getRight() < a.x) {\n                    return false;\n                }\n                if (this.getBottom() < a.y) {\n                    return false;\n                }\n                if (a.getRight() < this.x) {\n                    return false;\n                }\n                if (a.getBottom() < this.y) {\n                    return false;\n                }\n                return true;\n            };\n            RectangleD.prototype.getCenterX = function() {\n                return this.x + this.width / 2;\n            };\n            RectangleD.prototype.getMinX = function() {\n                return this.getX();\n            };\n            RectangleD.prototype.getMaxX = function() {\n                return this.getX() + this.width;\n            };\n            RectangleD.prototype.getCenterY = function() {\n                return this.y + this.height / 2;\n            };\n            RectangleD.prototype.getMinY = function() {\n                return this.getY();\n            };\n            RectangleD.prototype.getMaxY = function() {\n                return this.getY() + this.height;\n            };\n            RectangleD.prototype.getWidthHalf = function() {\n                return this.width / 2;\n            };\n            RectangleD.prototype.getHeightHalf = function() {\n                return this.height / 2;\n            };\n            module1.exports = RectangleD;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            function UniqueIDGeneretor() {}\n            UniqueIDGeneretor.lastID = 0;\n            UniqueIDGeneretor.createID = function(obj) {\n                if (UniqueIDGeneretor.isPrimitive(obj)) {\n                    return obj;\n                }\n                if (obj.uniqueID != null) {\n                    return obj.uniqueID;\n                }\n                obj.uniqueID = UniqueIDGeneretor.getString();\n                UniqueIDGeneretor.lastID++;\n                return obj.uniqueID;\n            };\n            UniqueIDGeneretor.getString = function(id) {\n                if (id == null) id = UniqueIDGeneretor.lastID;\n                return \"Object#\" + id + \"\";\n            };\n            UniqueIDGeneretor.isPrimitive = function(arg) {\n                var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n                return arg == null || type != \"object\" && type != \"function\";\n            };\n            module1.exports = UniqueIDGeneretor;\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_95260__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            var LayoutConstants = __nested_webpack_require_95260__(0);\n            var LGraphManager = __nested_webpack_require_95260__(7);\n            var LNode = __nested_webpack_require_95260__(3);\n            var LEdge = __nested_webpack_require_95260__(1);\n            var LGraph = __nested_webpack_require_95260__(6);\n            var PointD = __nested_webpack_require_95260__(5);\n            var Transform = __nested_webpack_require_95260__(17);\n            var Emitter = __nested_webpack_require_95260__(29);\n            function Layout1(isRemoteUse) {\n                Emitter.call(this);\n                //Layout Quality: 0:draft, 1:default, 2:proof\n                this.layoutQuality = LayoutConstants.QUALITY;\n                //Whether layout should create bendpoints as needed or not\n                this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                //Whether layout should be incremental or not\n                this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                //Whether we animate from before to after layout node positions\n                this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                //Whether we animate the layout process or not\n                this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                //Number iterations that should be done between two successive animations\n                this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */ this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n                /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */ this.edgeToDummyNodes = new Map();\n                this.graphManager = new LGraphManager(this);\n                this.isLayoutFinished = false;\n                this.isSubLayout = false;\n                this.isRemoteUse = false;\n                if (isRemoteUse != null) {\n                    this.isRemoteUse = isRemoteUse;\n                }\n            }\n            Layout1.RANDOM_SEED = 1;\n            Layout1.prototype = Object.create(Emitter.prototype);\n            Layout1.prototype.getGraphManager = function() {\n                return this.graphManager;\n            };\n            Layout1.prototype.getAllNodes = function() {\n                return this.graphManager.getAllNodes();\n            };\n            Layout1.prototype.getAllEdges = function() {\n                return this.graphManager.getAllEdges();\n            };\n            Layout1.prototype.getAllNodesToApplyGravitation = function() {\n                return this.graphManager.getAllNodesToApplyGravitation();\n            };\n            Layout1.prototype.newGraphManager = function() {\n                var gm = new LGraphManager(this);\n                this.graphManager = gm;\n                return gm;\n            };\n            Layout1.prototype.newGraph = function(vGraph) {\n                return new LGraph(null, this.graphManager, vGraph);\n            };\n            Layout1.prototype.newNode = function(vNode) {\n                return new LNode(this.graphManager, vNode);\n            };\n            Layout1.prototype.newEdge = function(vEdge) {\n                return new LEdge(null, null, vEdge);\n            };\n            Layout1.prototype.checkLayoutSuccess = function() {\n                return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n            };\n            Layout1.prototype.runLayout = function() {\n                this.isLayoutFinished = false;\n                if (this.tilingPreLayout) {\n                    this.tilingPreLayout();\n                }\n                this.initParameters();\n                var isLayoutSuccessfull;\n                if (this.checkLayoutSuccess()) {\n                    isLayoutSuccessfull = false;\n                } else {\n                    isLayoutSuccessfull = this.layout();\n                }\n                if (LayoutConstants.ANIMATE === \"during\") {\n                    // If this is a 'during' layout animation. Layout is not finished yet. \n                    // We need to perform these in index.js when layout is really finished.\n                    return false;\n                }\n                if (isLayoutSuccessfull) {\n                    if (!this.isSubLayout) {\n                        this.doPostLayout();\n                    }\n                }\n                if (this.tilingPostLayout) {\n                    this.tilingPostLayout();\n                }\n                this.isLayoutFinished = true;\n                return isLayoutSuccessfull;\n            };\n            /**\r\n * This method performs the operations required after layout.\r\n */ Layout1.prototype.doPostLayout = function() {\n                //assert !isSubLayout : \"Should not be called on sub-layout!\";\n                // Propagate geometric changes to v-level objects\n                if (!this.incremental) {\n                    this.transform();\n                }\n                this.update();\n            };\n            /**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */ Layout1.prototype.update2 = function() {\n                // update bend points\n                if (this.createBendsAsNeeded) {\n                    this.createBendpointsFromDummyNodes();\n                    // reset all edges, since the topology has changed\n                    this.graphManager.resetAllEdges();\n                }\n                // perform edge, node and root updates if layout is not called\n                // remotely\n                if (!this.isRemoteUse) {\n                    // update all edges\n                    var edge;\n                    var allEdges = this.graphManager.getAllEdges();\n                    for(var i = 0; i < allEdges.length; i++){\n                        edge = allEdges[i];\n                    //      this.update(edge);\n                    }\n                    // recursively update nodes\n                    var node;\n                    var nodes = this.graphManager.getRoot().getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        node = nodes[i];\n                    //      this.update(node);\n                    }\n                    // update root graph\n                    this.update(this.graphManager.getRoot());\n                }\n            };\n            Layout1.prototype.update = function(obj) {\n                if (obj == null) {\n                    this.update2();\n                } else if (obj instanceof LNode) {\n                    var node = obj;\n                    if (node.getChild() != null) {\n                        // since node is compound, recursively update child nodes\n                        var nodes = node.getChild().getNodes();\n                        for(var i = 0; i < nodes.length; i++){\n                            update(nodes[i]);\n                        }\n                    }\n                    // if the l-level node is associated with a v-level graph object,\n                    // then it is assumed that the v-level node implements the\n                    // interface Updatable.\n                    if (node.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vNode = node.vGraphObject;\n                        // call the update method of the interface\n                        vNode.update(node);\n                    }\n                } else if (obj instanceof LEdge) {\n                    var edge = obj;\n                    // if the l-level edge is associated with a v-level graph object,\n                    // then it is assumed that the v-level edge implements the\n                    // interface Updatable.\n                    if (edge.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vEdge = edge.vGraphObject;\n                        // call the update method of the interface\n                        vEdge.update(edge);\n                    }\n                } else if (obj instanceof LGraph) {\n                    var graph = obj;\n                    // if the l-level graph is associated with a v-level graph object,\n                    // then it is assumed that the v-level object implements the\n                    // interface Updatable.\n                    if (graph.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vGraph = graph.vGraphObject;\n                        // call the update method of the interface\n                        vGraph.update(graph);\n                    }\n                }\n            };\n            /**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */ Layout1.prototype.initParameters = function() {\n                if (!this.isSubLayout) {\n                    this.layoutQuality = LayoutConstants.QUALITY;\n                    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n                }\n                if (this.animationDuringLayout) {\n                    this.animationOnLayout = false;\n                }\n            };\n            Layout1.prototype.transform = function(newLeftTop) {\n                if (newLeftTop == undefined) {\n                    this.transform(new PointD(0, 0));\n                } else {\n                    // create a transformation object (from Eclipse to layout). When an\n                    // inverse transform is applied, we get upper-left coordinate of the\n                    // drawing or the root graph at given input coordinate (some margins\n                    // already included in calculation of left-top).\n                    var trans = new Transform();\n                    var leftTop = this.graphManager.getRoot().updateLeftTop();\n                    if (leftTop != null) {\n                        trans.setWorldOrgX(newLeftTop.x);\n                        trans.setWorldOrgY(newLeftTop.y);\n                        trans.setDeviceOrgX(leftTop.x);\n                        trans.setDeviceOrgY(leftTop.y);\n                        var nodes = this.getAllNodes();\n                        var node;\n                        for(var i = 0; i < nodes.length; i++){\n                            node = nodes[i];\n                            node.transform(trans);\n                        }\n                    }\n                }\n            };\n            Layout1.prototype.positionNodesRandomly = function(graph) {\n                if (graph == undefined) {\n                    //assert !this.incremental;\n                    this.positionNodesRandomly(this.getGraphManager().getRoot());\n                    this.getGraphManager().getRoot().updateBounds(true);\n                } else {\n                    var lNode;\n                    var childGraph;\n                    var nodes = graph.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        lNode = nodes[i];\n                        childGraph = lNode.getChild();\n                        if (childGraph == null) {\n                            lNode.scatter();\n                        } else if (childGraph.getNodes().length == 0) {\n                            lNode.scatter();\n                        } else {\n                            this.positionNodesRandomly(childGraph);\n                            lNode.updateBounds();\n                        }\n                    }\n                }\n            };\n            /**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */ Layout1.prototype.getFlatForest = function() {\n                var flatForest = [];\n                var isForest = true;\n                // Quick reference for all nodes in the graph manager associated with\n                // this layout. The list should not be changed.\n                var allNodes = this.graphManager.getRoot().getNodes();\n                // First be sure that the graph is flat\n                var isFlat = true;\n                for(var i = 0; i < allNodes.length; i++){\n                    if (allNodes[i].getChild() != null) {\n                        isFlat = false;\n                    }\n                }\n                // Return empty forest if the graph is not flat.\n                if (!isFlat) {\n                    return flatForest;\n                }\n                // Run BFS for each component of the graph.\n                var visited = new Set();\n                var toBeVisited = [];\n                var parents = new Map();\n                var unProcessedNodes = [];\n                unProcessedNodes = unProcessedNodes.concat(allNodes);\n                // Each iteration of this loop finds a component of the graph and\n                // decides whether it is a tree or not. If it is a tree, adds it to the\n                // forest and continued with the next component.\n                while(unProcessedNodes.length > 0 && isForest){\n                    toBeVisited.push(unProcessedNodes[0]);\n                    // Start the BFS. Each iteration of this loop visits a node in a\n                    // BFS manner.\n                    while(toBeVisited.length > 0 && isForest){\n                        //pool operation\n                        var currentNode = toBeVisited[0];\n                        toBeVisited.splice(0, 1);\n                        visited.add(currentNode);\n                        // Traverse all neighbors of this node\n                        var neighborEdges = currentNode.getEdges();\n                        for(var i = 0; i < neighborEdges.length; i++){\n                            var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n                            // If BFS is not growing from this neighbor.\n                            if (parents.get(currentNode) != currentNeighbor) {\n                                // We haven't previously visited this neighbor.\n                                if (!visited.has(currentNeighbor)) {\n                                    toBeVisited.push(currentNeighbor);\n                                    parents.set(currentNeighbor, currentNode);\n                                } else {\n                                    isForest = false;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // The graph contains a component that is not a tree. Empty\n                    // previously found trees. The method will end.\n                    if (!isForest) {\n                        flatForest = [];\n                    } else {\n                        var temp = [].concat(_toConsumableArray(visited));\n                        flatForest.push(temp);\n                        //flatForest = flatForest.concat(temp);\n                        //unProcessedNodes.removeAll(visited);\n                        for(var i = 0; i < temp.length; i++){\n                            var value = temp[i];\n                            var index = unProcessedNodes.indexOf(value);\n                            if (index > -1) {\n                                unProcessedNodes.splice(index, 1);\n                            }\n                        }\n                        visited = new Set();\n                        parents = new Map();\n                    }\n                }\n                return flatForest;\n            };\n            /**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */ Layout1.prototype.createDummyNodesForBendpoints = function(edge) {\n                var dummyNodes = [];\n                var prev = edge.source;\n                var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n                for(var i = 0; i < edge.bendpoints.length; i++){\n                    // create new dummy node\n                    var dummyNode = this.newNode(null);\n                    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n                    graph.add(dummyNode);\n                    // create new dummy edge between prev and dummy node\n                    var dummyEdge = this.newEdge(null);\n                    this.graphManager.add(dummyEdge, prev, dummyNode);\n                    dummyNodes.add(dummyNode);\n                    prev = dummyNode;\n                }\n                var dummyEdge = this.newEdge(null);\n                this.graphManager.add(dummyEdge, prev, edge.target);\n                this.edgeToDummyNodes.set(edge, dummyNodes);\n                // remove real edge from graph manager if it is inter-graph\n                if (edge.isInterGraph()) {\n                    this.graphManager.remove(edge);\n                } else {\n                    graph.remove(edge);\n                }\n                return dummyNodes;\n            };\n            /**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */ Layout1.prototype.createBendpointsFromDummyNodes = function() {\n                var edges = [];\n                edges = edges.concat(this.graphManager.getAllEdges());\n                edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n                for(var k = 0; k < edges.length; k++){\n                    var lEdge = edges[k];\n                    if (lEdge.bendpoints.length > 0) {\n                        var path = this.edgeToDummyNodes.get(lEdge);\n                        for(var i = 0; i < path.length; i++){\n                            var dummyNode = path[i];\n                            var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n                            // update bendpoint's location according to dummy node\n                            var ebp = lEdge.bendpoints.get(i);\n                            ebp.x = p.x;\n                            ebp.y = p.y;\n                            // remove the dummy node, dummy edges incident with this\n                            // dummy node is also removed (within the remove method)\n                            dummyNode.getOwner().remove(dummyNode);\n                        }\n                        // add the real edge to graph\n                        this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n                    }\n                }\n            };\n            Layout1.transform = function(sliderValue, defaultValue, minDiv, maxMul) {\n                if (minDiv != undefined && maxMul != undefined) {\n                    var value = defaultValue;\n                    if (sliderValue <= 50) {\n                        var minValue = defaultValue / minDiv;\n                        value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n                    } else {\n                        var maxValue = defaultValue * maxMul;\n                        value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n                    }\n                    return value;\n                } else {\n                    var a, b;\n                    if (sliderValue <= 50) {\n                        a = 9.0 * defaultValue / 500.0;\n                        b = defaultValue / 10.0;\n                    } else {\n                        a = 9.0 * defaultValue / 50.0;\n                        b = -8 * defaultValue;\n                    }\n                    return a * sliderValue + b;\n                }\n            };\n            /**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */ Layout1.findCenterOfTree = function(nodes) {\n                var list = [];\n                list = list.concat(nodes);\n                var removedNodes = [];\n                var remainingDegrees = new Map();\n                var foundCenter = false;\n                var centerNode = null;\n                if (list.length == 1 || list.length == 2) {\n                    foundCenter = true;\n                    centerNode = list[0];\n                }\n                for(var i = 0; i < list.length; i++){\n                    var node = list[i];\n                    var degree = node.getNeighborsList().size;\n                    remainingDegrees.set(node, node.getNeighborsList().size);\n                    if (degree == 1) {\n                        removedNodes.push(node);\n                    }\n                }\n                var tempList = [];\n                tempList = tempList.concat(removedNodes);\n                while(!foundCenter){\n                    var tempList2 = [];\n                    tempList2 = tempList2.concat(tempList);\n                    tempList = [];\n                    for(var i = 0; i < list.length; i++){\n                        var node = list[i];\n                        var index = list.indexOf(node);\n                        if (index >= 0) {\n                            list.splice(index, 1);\n                        }\n                        var neighbours = node.getNeighborsList();\n                        neighbours.forEach(function(neighbour) {\n                            if (removedNodes.indexOf(neighbour) < 0) {\n                                var otherDegree = remainingDegrees.get(neighbour);\n                                var newDegree = otherDegree - 1;\n                                if (newDegree == 1) {\n                                    tempList.push(neighbour);\n                                }\n                                remainingDegrees.set(neighbour, newDegree);\n                            }\n                        });\n                    }\n                    removedNodes = removedNodes.concat(tempList);\n                    if (list.length == 1 || list.length == 2) {\n                        foundCenter = true;\n                        centerNode = list[0];\n                    }\n                }\n                return centerNode;\n            };\n            /**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */ Layout1.prototype.setGraphManager = function(gm) {\n                this.graphManager = gm;\n            };\n            module1.exports = Layout1;\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function RandomSeed() {}\n            // adapted from: https://stackoverflow.com/a/19303725\n            RandomSeed.seed = 1;\n            RandomSeed.x = 0;\n            RandomSeed.nextDouble = function() {\n                RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n                return RandomSeed.x - Math.floor(RandomSeed.x);\n            };\n            module1.exports = RandomSeed;\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_119564__) {\n            \"use strict\";\n            var PointD = __nested_webpack_require_119564__(5);\n            function Transform(x, y) {\n                this.lworldOrgX = 0.0;\n                this.lworldOrgY = 0.0;\n                this.ldeviceOrgX = 0.0;\n                this.ldeviceOrgY = 0.0;\n                this.lworldExtX = 1.0;\n                this.lworldExtY = 1.0;\n                this.ldeviceExtX = 1.0;\n                this.ldeviceExtY = 1.0;\n            }\n            Transform.prototype.getWorldOrgX = function() {\n                return this.lworldOrgX;\n            };\n            Transform.prototype.setWorldOrgX = function(wox) {\n                this.lworldOrgX = wox;\n            };\n            Transform.prototype.getWorldOrgY = function() {\n                return this.lworldOrgY;\n            };\n            Transform.prototype.setWorldOrgY = function(woy) {\n                this.lworldOrgY = woy;\n            };\n            Transform.prototype.getWorldExtX = function() {\n                return this.lworldExtX;\n            };\n            Transform.prototype.setWorldExtX = function(wex) {\n                this.lworldExtX = wex;\n            };\n            Transform.prototype.getWorldExtY = function() {\n                return this.lworldExtY;\n            };\n            Transform.prototype.setWorldExtY = function(wey) {\n                this.lworldExtY = wey;\n            };\n            /* Device related */ Transform.prototype.getDeviceOrgX = function() {\n                return this.ldeviceOrgX;\n            };\n            Transform.prototype.setDeviceOrgX = function(dox) {\n                this.ldeviceOrgX = dox;\n            };\n            Transform.prototype.getDeviceOrgY = function() {\n                return this.ldeviceOrgY;\n            };\n            Transform.prototype.setDeviceOrgY = function(doy) {\n                this.ldeviceOrgY = doy;\n            };\n            Transform.prototype.getDeviceExtX = function() {\n                return this.ldeviceExtX;\n            };\n            Transform.prototype.setDeviceExtX = function(dex) {\n                this.ldeviceExtX = dex;\n            };\n            Transform.prototype.getDeviceExtY = function() {\n                return this.ldeviceExtY;\n            };\n            Transform.prototype.setDeviceExtY = function(dey) {\n                this.ldeviceExtY = dey;\n            };\n            Transform.prototype.transformX = function(x) {\n                var xDevice = 0.0;\n                var worldExtX = this.lworldExtX;\n                if (worldExtX != 0.0) {\n                    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n                }\n                return xDevice;\n            };\n            Transform.prototype.transformY = function(y) {\n                var yDevice = 0.0;\n                var worldExtY = this.lworldExtY;\n                if (worldExtY != 0.0) {\n                    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n                }\n                return yDevice;\n            };\n            Transform.prototype.inverseTransformX = function(x) {\n                var xWorld = 0.0;\n                var deviceExtX = this.ldeviceExtX;\n                if (deviceExtX != 0.0) {\n                    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n                }\n                return xWorld;\n            };\n            Transform.prototype.inverseTransformY = function(y) {\n                var yWorld = 0.0;\n                var deviceExtY = this.ldeviceExtY;\n                if (deviceExtY != 0.0) {\n                    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n                }\n                return yWorld;\n            };\n            Transform.prototype.inverseTransformPoint = function(inPoint) {\n                var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n                return outPoint;\n            };\n            module1.exports = Transform;\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_123688__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            var Layout1 = __nested_webpack_require_123688__(15);\n            var FDLayoutConstants = __nested_webpack_require_123688__(4);\n            var LayoutConstants = __nested_webpack_require_123688__(0);\n            var IGeometry = __nested_webpack_require_123688__(8);\n            var IMath = __nested_webpack_require_123688__(9);\n            function FDLayout() {\n                Layout1.call(this);\n                this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n                this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                this.totalDisplacement = 0.0;\n                this.oldTotalDisplacement = 0.0;\n                this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n            }\n            FDLayout.prototype = Object.create(Layout1.prototype);\n            for(var prop in Layout1){\n                FDLayout[prop] = Layout1[prop];\n            }\n            FDLayout.prototype.initParameters = function() {\n                Layout1.prototype.initParameters.call(this, arguments);\n                this.totalIterations = 0;\n                this.notAnimatedIterations = 0;\n                this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n                this.grid = [];\n            };\n            FDLayout.prototype.calcIdealEdgeLengths = function() {\n                var edge;\n                var originalIdealLength;\n                var lcaDepth;\n                var source;\n                var target;\n                var sizeOfSourceInLca;\n                var sizeOfTargetInLca;\n                var allEdges = this.getGraphManager().getAllEdges();\n                for(var i = 0; i < allEdges.length; i++){\n                    edge = allEdges[i];\n                    originalIdealLength = edge.idealLength;\n                    if (edge.isInterGraph) {\n                        source = edge.getSource();\n                        target = edge.getTarget();\n                        sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n                        sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n                        if (this.useSmartIdealEdgeLengthCalculation) {\n                            edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n                        }\n                        lcaDepth = edge.getLca().getInclusionTreeDepth();\n                        edge.idealLength += originalIdealLength * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n                    }\n                }\n            };\n            FDLayout.prototype.initSpringEmbedder = function() {\n                var s = this.getAllNodes().length;\n                if (this.incremental) {\n                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                        this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                    }\n                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n                } else {\n                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                        this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                    } else {\n                        this.coolingFactor = 1.0;\n                    }\n                    this.initialCoolingFactor = this.coolingFactor;\n                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n                }\n                this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n                // Reassign this attribute by using new constant value\n                this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n                this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n                this.repulsionRange = this.calcRepulsionRange();\n            };\n            FDLayout.prototype.calcSpringForces = function() {\n                var lEdges = this.getAllEdges();\n                var edge;\n                for(var i = 0; i < lEdges.length; i++){\n                    edge = lEdges[i];\n                    this.calcSpringForce(edge, edge.idealLength);\n                }\n            };\n            FDLayout.prototype.calcRepulsionForces = function() {\n                var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var i, j;\n                var nodeA, nodeB;\n                var lNodes = this.getAllNodes();\n                var processedNodeSet;\n                if (this.useFRGridVariant) {\n                    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n                        this.updateGrid();\n                    }\n                    processedNodeSet = new Set();\n                    // calculate repulsion forces between each nodes and its surrounding\n                    for(i = 0; i < lNodes.length; i++){\n                        nodeA = lNodes[i];\n                        this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                        processedNodeSet.add(nodeA);\n                    }\n                } else {\n                    for(i = 0; i < lNodes.length; i++){\n                        nodeA = lNodes[i];\n                        for(j = i + 1; j < lNodes.length; j++){\n                            nodeB = lNodes[j];\n                            // If both nodes are not members of the same graph, skip.\n                            if (nodeA.getOwner() != nodeB.getOwner()) {\n                                continue;\n                            }\n                            this.calcRepulsionForce(nodeA, nodeB);\n                        }\n                    }\n                }\n            };\n            FDLayout.prototype.calcGravitationalForces = function() {\n                var node;\n                var lNodes = this.getAllNodesToApplyGravitation();\n                for(var i = 0; i < lNodes.length; i++){\n                    node = lNodes[i];\n                    this.calcGravitationalForce(node);\n                }\n            };\n            FDLayout.prototype.moveNodes = function() {\n                var lNodes = this.getAllNodes();\n                var node;\n                for(var i = 0; i < lNodes.length; i++){\n                    node = lNodes[i];\n                    node.move();\n                }\n            };\n            FDLayout.prototype.calcSpringForce = function(edge, idealLength) {\n                var sourceNode = edge.getSource();\n                var targetNode = edge.getTarget();\n                var length;\n                var springForce;\n                var springForceX;\n                var springForceY;\n                // Update edge length\n                if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n                    edge.updateLengthSimple();\n                } else {\n                    edge.updateLength();\n                    if (edge.isOverlapingSourceAndTarget) {\n                        return;\n                    }\n                }\n                length = edge.getLength();\n                if (length == 0) return;\n                // Calculate spring forces\n                springForce = edge.edgeElasticity * (length - idealLength);\n                // Project force onto x and y axes\n                springForceX = springForce * (edge.lengthX / length);\n                springForceY = springForce * (edge.lengthY / length);\n                // Apply forces on the end nodes\n                sourceNode.springForceX += springForceX;\n                sourceNode.springForceY += springForceY;\n                targetNode.springForceX -= springForceX;\n                targetNode.springForceY -= springForceY;\n            };\n            FDLayout.prototype.calcRepulsionForce = function(nodeA, nodeB) {\n                var rectA = nodeA.getRect();\n                var rectB = nodeB.getRect();\n                var overlapAmount = new Array(2);\n                var clipPoints = new Array(4);\n                var distanceX;\n                var distanceY;\n                var distanceSquared;\n                var distance;\n                var repulsionForce;\n                var repulsionForceX;\n                var repulsionForceY;\n                if (rectA.intersects(rectB)) {\n                    // calculate separation amount in x and y directions\n                    IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n                    repulsionForceX = 2 * overlapAmount[0];\n                    repulsionForceY = 2 * overlapAmount[1];\n                    var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n                    // Apply forces on the two nodes\n                    nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n                    nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n                    nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n                    nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n                } else {\n                    // calculate distance\n                    if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) {\n                        distanceX = rectB.getCenterX() - rectA.getCenterX();\n                        distanceY = rectB.getCenterY() - rectA.getCenterY();\n                    } else {\n                        IGeometry.getIntersection(rectA, rectB, clipPoints);\n                        distanceX = clipPoints[2] - clipPoints[0];\n                        distanceY = clipPoints[3] - clipPoints[1];\n                    }\n                    // No repulsion range. FR grid variant should take care of this.\n                    if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n                    }\n                    if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n                    }\n                    distanceSquared = distanceX * distanceX + distanceY * distanceY;\n                    distance = Math.sqrt(distanceSquared);\n                    // Here we use half of the nodes' repulsion values for backward compatibility\n                    repulsionForce = (nodeA.nodeRepulsion / 2 + nodeB.nodeRepulsion / 2) * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n                    // Project force onto x and y axes\n                    repulsionForceX = repulsionForce * distanceX / distance;\n                    repulsionForceY = repulsionForce * distanceY / distance;\n                    // Apply forces on the two nodes    \n                    nodeA.repulsionForceX -= repulsionForceX;\n                    nodeA.repulsionForceY -= repulsionForceY;\n                    nodeB.repulsionForceX += repulsionForceX;\n                    nodeB.repulsionForceY += repulsionForceY;\n                }\n            };\n            FDLayout.prototype.calcGravitationalForce = function(node) {\n                var ownerGraph;\n                var ownerCenterX;\n                var ownerCenterY;\n                var distanceX;\n                var distanceY;\n                var absDistanceX;\n                var absDistanceY;\n                var estimatedSize;\n                ownerGraph = node.getOwner();\n                ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n                ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n                distanceX = node.getCenterX() - ownerCenterX;\n                distanceY = node.getCenterY() - ownerCenterY;\n                absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n                absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n                if (node.getOwner() == this.graphManager.getRoot()) {\n                    estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                        node.gravitationForceX = -this.gravityConstant * distanceX;\n                        node.gravitationForceY = -this.gravityConstant * distanceY;\n                    }\n                } else {\n                    estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n                        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n                    }\n                }\n            };\n            FDLayout.prototype.isConverged = function() {\n                var converged;\n                var oscilating = false;\n                if (this.totalIterations > this.maxIterations / 3) {\n                    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n                }\n                converged = this.totalDisplacement < this.totalDisplacementThreshold;\n                this.oldTotalDisplacement = this.totalDisplacement;\n                return converged || oscilating;\n            };\n            FDLayout.prototype.animate = function() {\n                if (this.animationDuringLayout && !this.isSubLayout) {\n                    if (this.notAnimatedIterations == this.animationPeriod) {\n                        this.update();\n                        this.notAnimatedIterations = 0;\n                    } else {\n                        this.notAnimatedIterations++;\n                    }\n                }\n            };\n            //This method calculates the number of children (weight) for all nodes\n            FDLayout.prototype.calcNoOfChildrenForAllNodes = function() {\n                var node;\n                var allNodes = this.graphManager.getAllNodes();\n                for(var i = 0; i < allNodes.length; i++){\n                    node = allNodes[i];\n                    node.noOfChildren = node.getNoOfChildren();\n                }\n            };\n            // -----------------------------------------------------------------------------\n            // Section: FR-Grid Variant Repulsion Force Calculation\n            // -----------------------------------------------------------------------------\n            FDLayout.prototype.calcGrid = function(graph) {\n                var sizeX = 0;\n                var sizeY = 0;\n                sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n                sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n                var grid = new Array(sizeX);\n                for(var i = 0; i < sizeX; i++){\n                    grid[i] = new Array(sizeY);\n                }\n                for(var i = 0; i < sizeX; i++){\n                    for(var j = 0; j < sizeY; j++){\n                        grid[i][j] = new Array();\n                    }\n                }\n                return grid;\n            };\n            FDLayout.prototype.addNodeToGrid = function(v, left, top) {\n                var startX = 0;\n                var finishX = 0;\n                var startY = 0;\n                var finishY = 0;\n                startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n                finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n                startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n                finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n                for(var i = startX; i <= finishX; i++){\n                    for(var j = startY; j <= finishY; j++){\n                        this.grid[i][j].push(v);\n                        v.setGridCoordinates(startX, finishX, startY, finishY);\n                    }\n                }\n            };\n            FDLayout.prototype.updateGrid = function() {\n                var i;\n                var nodeA;\n                var lNodes = this.getAllNodes();\n                this.grid = this.calcGrid(this.graphManager.getRoot());\n                // put all nodes to proper grid cells\n                for(i = 0; i < lNodes.length; i++){\n                    nodeA = lNodes[i];\n                    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n                }\n            };\n            FDLayout.prototype.calculateRepulsionForceOfANode = function(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n                if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n                    var surrounding = new Set();\n                    nodeA.surrounding = new Array();\n                    var nodeB;\n                    var grid = this.grid;\n                    for(var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++){\n                        for(var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++){\n                            if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n                                for(var k = 0; k < grid[i][j].length; k++){\n                                    nodeB = grid[i][j][k];\n                                    // If both nodes are not members of the same graph, \n                                    // or both nodes are the same, skip.\n                                    if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n                                        continue;\n                                    }\n                                    // check if the repulsion force between\n                                    // nodeA and nodeB has already been calculated\n                                    if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n                                        var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n                                        var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n                                        // if the distance between nodeA and nodeB \n                                        // is less then calculation range\n                                        if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                                            //then add nodeB to surrounding of nodeA\n                                            surrounding.add(nodeB);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n                }\n                for(i = 0; i < nodeA.surrounding.length; i++){\n                    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n                }\n            };\n            FDLayout.prototype.calcRepulsionRange = function() {\n                return 0.0;\n            };\n            module1.exports = FDLayout;\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_145238__) {\n            \"use strict\";\n            var LEdge = __nested_webpack_require_145238__(1);\n            var FDLayoutConstants = __nested_webpack_require_145238__(4);\n            function FDLayoutEdge(source, target, vEdge) {\n                LEdge.call(this, source, target, vEdge);\n                // Ideal length and elasticity value for this edge\n                this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                this.edgeElasticity = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n            }\n            FDLayoutEdge.prototype = Object.create(LEdge.prototype);\n            for(var prop in LEdge){\n                FDLayoutEdge[prop] = LEdge[prop];\n            }\n            module1.exports = FDLayoutEdge;\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_146028__) {\n            \"use strict\";\n            var LNode = __nested_webpack_require_146028__(3);\n            var FDLayoutConstants = __nested_webpack_require_146028__(4);\n            function FDLayoutNode(gm, loc, size, vNode) {\n                // alternative constructor is handled inside LNode\n                LNode.call(this, gm, loc, size, vNode);\n                // Repulsion value of this node\n                this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n                //Spring, repulsion and gravitational forces acting on this node\n                this.springForceX = 0;\n                this.springForceY = 0;\n                this.repulsionForceX = 0;\n                this.repulsionForceY = 0;\n                this.gravitationForceX = 0;\n                this.gravitationForceY = 0;\n                //Amount by which this node is to be moved in this iteration\n                this.displacementX = 0;\n                this.displacementY = 0;\n                //Start and finish grid coordinates that this node is fallen into\n                this.startX = 0;\n                this.finishX = 0;\n                this.startY = 0;\n                this.finishY = 0;\n                //Geometric neighbors of this node\n                this.surrounding = [];\n            }\n            FDLayoutNode.prototype = Object.create(LNode.prototype);\n            for(var prop in LNode){\n                FDLayoutNode[prop] = LNode[prop];\n            }\n            FDLayoutNode.prototype.setGridCoordinates = function(_startX, _finishX, _startY, _finishY) {\n                this.startX = _startX;\n                this.finishX = _finishX;\n                this.startY = _startY;\n                this.finishY = _finishY;\n            };\n            module1.exports = FDLayoutNode;\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function DimensionD1(width, height) {\n                this.width = 0;\n                this.height = 0;\n                if (width !== null && height !== null) {\n                    this.height = height;\n                    this.width = width;\n                }\n            }\n            DimensionD1.prototype.getWidth = function() {\n                return this.width;\n            };\n            DimensionD1.prototype.setWidth = function(width) {\n                this.width = width;\n            };\n            DimensionD1.prototype.getHeight = function() {\n                return this.height;\n            };\n            DimensionD1.prototype.setHeight = function(height) {\n                this.height = height;\n            };\n            module1.exports = DimensionD1;\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_148762__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __nested_webpack_require_148762__(14);\n            function HashMap() {\n                this.map = {};\n                this.keys = [];\n            }\n            HashMap.prototype.put = function(key, value) {\n                var theId = UniqueIDGeneretor.createID(key);\n                if (!this.contains(theId)) {\n                    this.map[theId] = value;\n                    this.keys.push(key);\n                }\n            };\n            HashMap.prototype.contains = function(key) {\n                var theId = UniqueIDGeneretor.createID(key);\n                return this.map[key] != null;\n            };\n            HashMap.prototype.get = function(key) {\n                var theId = UniqueIDGeneretor.createID(key);\n                return this.map[theId];\n            };\n            HashMap.prototype.keySet = function() {\n                return this.keys;\n            };\n            module1.exports = HashMap;\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_149821__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __nested_webpack_require_149821__(14);\n            function HashSet() {\n                this.set = {};\n            }\n            ;\n            HashSet.prototype.add = function(obj) {\n                var theId = UniqueIDGeneretor.createID(obj);\n                if (!this.contains(theId)) this.set[theId] = obj;\n            };\n            HashSet.prototype.remove = function(obj) {\n                delete this.set[UniqueIDGeneretor.createID(obj)];\n            };\n            HashSet.prototype.clear = function() {\n                this.set = {};\n            };\n            HashSet.prototype.contains = function(obj) {\n                return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n            };\n            HashSet.prototype.isEmpty = function() {\n                return this.size() === 0;\n            };\n            HashSet.prototype.size = function() {\n                return Object.keys(this.set).length;\n            };\n            //concats this.set to the given list\n            HashSet.prototype.addAllTo = function(list) {\n                var keys = Object.keys(this.set);\n                var length = keys.length;\n                for(var i = 0; i < length; i++){\n                    list.push(this.set[keys[i]]);\n                }\n            };\n            HashSet.prototype.size = function() {\n                return Object.keys(this.set).length;\n            };\n            HashSet.prototype.addAll = function(list) {\n                var s = list.length;\n                for(var i = 0; i < s; i++){\n                    var v = list[i];\n                    this.add(v);\n                }\n            };\n            module1.exports = HashSet;\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            // Some matrix (1d and 2d array) operations\n            function Matrix() {}\n            /**\n * matrix multiplication\n * array1, array2 and result are 2d arrays\n */ Matrix.multMat = function(array1, array2) {\n                var result = [];\n                for(var i = 0; i < array1.length; i++){\n                    result[i] = [];\n                    for(var j = 0; j < array2[0].length; j++){\n                        result[i][j] = 0;\n                        for(var k = 0; k < array1[0].length; k++){\n                            result[i][j] += array1[i][k] * array2[k][j];\n                        }\n                    }\n                }\n                return result;\n            };\n            /**\n * matrix transpose\n * array and result are 2d arrays\n */ Matrix.transpose = function(array) {\n                var result = [];\n                for(var i = 0; i < array[0].length; i++){\n                    result[i] = [];\n                    for(var j = 0; j < array.length; j++){\n                        result[i][j] = array[j][i];\n                    }\n                }\n                return result;\n            };\n            /**\n * multiply array with constant\n * array and result are 1d arrays\n */ Matrix.multCons = function(array, constant) {\n                var result = [];\n                for(var i = 0; i < array.length; i++){\n                    result[i] = array[i] * constant;\n                }\n                return result;\n            };\n            /**\n * substract two arrays\n * array1, array2 and result are 1d arrays\n */ Matrix.minusOp = function(array1, array2) {\n                var result = [];\n                for(var i = 0; i < array1.length; i++){\n                    result[i] = array1[i] - array2[i];\n                }\n                return result;\n            };\n            /**\n * dot product of two arrays with same size\n * array1 and array2 are 1d arrays\n */ Matrix.dotProduct = function(array1, array2) {\n                var product = 0;\n                for(var i = 0; i < array1.length; i++){\n                    product += array1[i] * array2[i];\n                }\n                return product;\n            };\n            /**\n * magnitude of an array\n * array is 1d array\n */ Matrix.mag = function(array) {\n                return Math.sqrt(this.dotProduct(array, array));\n            };\n            /**\n * normalization of an array\n * array and result are 1d array\n */ Matrix.normalize = function(array) {\n                var result = [];\n                var magnitude = this.mag(array);\n                for(var i = 0; i < array.length; i++){\n                    result[i] = array[i] / magnitude;\n                }\n                return result;\n            };\n            /**\n * multiply an array with centering matrix\n * array and result are 1d array\n */ Matrix.multGamma = function(array) {\n                var result = [];\n                var sum = 0;\n                for(var i = 0; i < array.length; i++){\n                    sum += array[i];\n                }\n                sum *= -1 / array.length;\n                for(var _i = 0; _i < array.length; _i++){\n                    result[_i] = sum + array[_i];\n                }\n                return result;\n            };\n            /**\n * a special matrix multiplication\n * result = 0.5 * C * INV * C^T * array\n * array and result are 1d, C and INV are 2d arrays\n */ Matrix.multL = function(array, C, INV) {\n                var result = [];\n                var temp1 = [];\n                var temp2 = [];\n                // multiply by C^T\n                for(var i = 0; i < C[0].length; i++){\n                    var sum = 0;\n                    for(var j = 0; j < C.length; j++){\n                        sum += -0.5 * C[j][i] * array[j];\n                    }\n                    temp1[i] = sum;\n                }\n                // multiply the result by INV\n                for(var _i2 = 0; _i2 < INV.length; _i2++){\n                    var _sum = 0;\n                    for(var _j = 0; _j < INV.length; _j++){\n                        _sum += INV[_i2][_j] * temp1[_j];\n                    }\n                    temp2[_i2] = _sum;\n                }\n                // multiply the result by C\n                for(var _i3 = 0; _i3 < C.length; _i3++){\n                    var _sum2 = 0;\n                    for(var _j2 = 0; _j2 < C[0].length; _j2++){\n                        _sum2 += C[_i3][_j2] * temp2[_j2];\n                    }\n                    result[_i3] = _sum2;\n                }\n                return result;\n            };\n            module1.exports = Matrix;\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __nested_webpack_require_156330__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            /**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */ var LinkedList = __nested_webpack_require_156330__(11);\n            var Quicksort = function() {\n                function Quicksort(A, compareFunction) {\n                    _classCallCheck(this, Quicksort);\n                    if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n                    var length = void 0;\n                    if (A instanceof LinkedList) length = A.size();\n                    else length = A.length;\n                    this._quicksort(A, 0, length - 1);\n                }\n                _createClass(Quicksort, [\n                    {\n                        key: \"_quicksort\",\n                        value: function _quicksort(A, p, r) {\n                            if (p < r) {\n                                var q = this._partition(A, p, r);\n                                this._quicksort(A, p, q);\n                                this._quicksort(A, q + 1, r);\n                            }\n                        }\n                    },\n                    {\n                        key: \"_partition\",\n                        value: function _partition(A, p, r) {\n                            var x = this._get(A, p);\n                            var i = p;\n                            var j = r;\n                            while(true){\n                                while(this.compareFunction(x, this._get(A, j))){\n                                    j--;\n                                }\n                                while(this.compareFunction(this._get(A, i), x)){\n                                    i++;\n                                }\n                                if (i < j) {\n                                    this._swap(A, i, j);\n                                    i++;\n                                    j--;\n                                } else return j;\n                            }\n                        }\n                    },\n                    {\n                        key: \"_get\",\n                        value: function _get(object, index) {\n                            if (object instanceof LinkedList) return object.get_object_at(index);\n                            else return object[index];\n                        }\n                    },\n                    {\n                        key: \"_set\",\n                        value: function _set(object, index, value) {\n                            if (object instanceof LinkedList) object.set_object_at(index, value);\n                            else object[index] = value;\n                        }\n                    },\n                    {\n                        key: \"_swap\",\n                        value: function _swap(A, i, j) {\n                            var temp = this._get(A, i);\n                            this._set(A, i, this._get(A, j));\n                            this._set(A, j, temp);\n                        }\n                    },\n                    {\n                        key: \"_defaultCompareFunction\",\n                        value: function _defaultCompareFunction(a, b) {\n                            return b > a;\n                        }\n                    }\n                ]);\n                return Quicksort;\n            }();\n            module1.exports = Quicksort;\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            // Singular Value Decomposition implementation\n            function SVD() {}\n            ;\n            /* Below singular value decomposition (svd) code including hypot function is adopted from https://github.com/dragonfly-ai/JamaJS\n   Some changes are applied to make the code compatible with the fcose code and to make it independent from Jama.\n   Input matrix is changed to a 2D array instead of Jama matrix. Matrix dimensions are taken according to 2D array instead of using Jama functions.\n   An object that includes singular value components is created for return. \n   The types of input parameters of the hypot function are removed. \n   let is used instead of var for the variable initialization.\n*/ /*\n                               Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/ SVD.svd = function(A) {\n                this.U = null;\n                this.V = null;\n                this.s = null;\n                this.m = 0;\n                this.n = 0;\n                this.m = A.length;\n                this.n = A[0].length;\n                var nu = Math.min(this.m, this.n);\n                this.s = function(s) {\n                    var a = [];\n                    while(s-- > 0){\n                        a.push(0);\n                    }\n                    return a;\n                }(Math.min(this.m + 1, this.n));\n                this.U = function(dims) {\n                    var allocate = function allocate(dims) {\n                        if (dims.length == 0) {\n                            return 0;\n                        } else {\n                            var array = [];\n                            for(var i = 0; i < dims[0]; i++){\n                                array.push(allocate(dims.slice(1)));\n                            }\n                            return array;\n                        }\n                    };\n                    return allocate(dims);\n                }([\n                    this.m,\n                    nu\n                ]);\n                this.V = function(dims) {\n                    var allocate = function allocate(dims) {\n                        if (dims.length == 0) {\n                            return 0;\n                        } else {\n                            var array = [];\n                            for(var i = 0; i < dims[0]; i++){\n                                array.push(allocate(dims.slice(1)));\n                            }\n                            return array;\n                        }\n                    };\n                    return allocate(dims);\n                }([\n                    this.n,\n                    this.n\n                ]);\n                var e = function(s) {\n                    var a = [];\n                    while(s-- > 0){\n                        a.push(0);\n                    }\n                    return a;\n                }(this.n);\n                var work = function(s) {\n                    var a = [];\n                    while(s-- > 0){\n                        a.push(0);\n                    }\n                    return a;\n                }(this.m);\n                var wantu = true;\n                var wantv = true;\n                var nct = Math.min(this.m - 1, this.n);\n                var nrt = Math.max(0, Math.min(this.n - 2, this.m));\n                for(var k = 0; k < Math.max(nct, nrt); k++){\n                    if (k < nct) {\n                        this.s[k] = 0;\n                        for(var i = k; i < this.m; i++){\n                            this.s[k] = SVD.hypot(this.s[k], A[i][k]);\n                        }\n                        ;\n                        if (this.s[k] !== 0.0) {\n                            if (A[k][k] < 0.0) {\n                                this.s[k] = -this.s[k];\n                            }\n                            for(var _i = k; _i < this.m; _i++){\n                                A[_i][k] /= this.s[k];\n                            }\n                            ;\n                            A[k][k] += 1.0;\n                        }\n                        this.s[k] = -this.s[k];\n                    }\n                    for(var j = k + 1; j < this.n; j++){\n                        if (function(lhs, rhs) {\n                            return lhs && rhs;\n                        }(k < nct, this.s[k] !== 0.0)) {\n                            var t = 0;\n                            for(var _i2 = k; _i2 < this.m; _i2++){\n                                t += A[_i2][k] * A[_i2][j];\n                            }\n                            ;\n                            t = -t / A[k][k];\n                            for(var _i3 = k; _i3 < this.m; _i3++){\n                                A[_i3][j] += t * A[_i3][k];\n                            }\n                            ;\n                        }\n                        e[j] = A[k][j];\n                    }\n                    ;\n                    if (function(lhs, rhs) {\n                        return lhs && rhs;\n                    }(wantu, k < nct)) {\n                        for(var _i4 = k; _i4 < this.m; _i4++){\n                            this.U[_i4][k] = A[_i4][k];\n                        }\n                        ;\n                    }\n                    if (k < nrt) {\n                        e[k] = 0;\n                        for(var _i5 = k + 1; _i5 < this.n; _i5++){\n                            e[k] = SVD.hypot(e[k], e[_i5]);\n                        }\n                        ;\n                        if (e[k] !== 0.0) {\n                            if (e[k + 1] < 0.0) {\n                                e[k] = -e[k];\n                            }\n                            for(var _i6 = k + 1; _i6 < this.n; _i6++){\n                                e[_i6] /= e[k];\n                            }\n                            ;\n                            e[k + 1] += 1.0;\n                        }\n                        e[k] = -e[k];\n                        if (function(lhs, rhs) {\n                            return lhs && rhs;\n                        }(k + 1 < this.m, e[k] !== 0.0)) {\n                            for(var _i7 = k + 1; _i7 < this.m; _i7++){\n                                work[_i7] = 0.0;\n                            }\n                            ;\n                            for(var _j = k + 1; _j < this.n; _j++){\n                                for(var _i8 = k + 1; _i8 < this.m; _i8++){\n                                    work[_i8] += e[_j] * A[_i8][_j];\n                                }\n                                ;\n                            }\n                            ;\n                            for(var _j2 = k + 1; _j2 < this.n; _j2++){\n                                var _t = -e[_j2] / e[k + 1];\n                                for(var _i9 = k + 1; _i9 < this.m; _i9++){\n                                    A[_i9][_j2] += _t * work[_i9];\n                                }\n                                ;\n                            }\n                            ;\n                        }\n                        if (wantv) {\n                            for(var _i10 = k + 1; _i10 < this.n; _i10++){\n                                this.V[_i10][k] = e[_i10];\n                            }\n                            ;\n                        }\n                    }\n                }\n                ;\n                var p = Math.min(this.n, this.m + 1);\n                if (nct < this.n) {\n                    this.s[nct] = A[nct][nct];\n                }\n                if (this.m < p) {\n                    this.s[p - 1] = 0.0;\n                }\n                if (nrt + 1 < p) {\n                    e[nrt] = A[nrt][p - 1];\n                }\n                e[p - 1] = 0.0;\n                if (wantu) {\n                    for(var _j3 = nct; _j3 < nu; _j3++){\n                        for(var _i11 = 0; _i11 < this.m; _i11++){\n                            this.U[_i11][_j3] = 0.0;\n                        }\n                        ;\n                        this.U[_j3][_j3] = 1.0;\n                    }\n                    ;\n                    for(var _k = nct - 1; _k >= 0; _k--){\n                        if (this.s[_k] !== 0.0) {\n                            for(var _j4 = _k + 1; _j4 < nu; _j4++){\n                                var _t2 = 0;\n                                for(var _i12 = _k; _i12 < this.m; _i12++){\n                                    _t2 += this.U[_i12][_k] * this.U[_i12][_j4];\n                                }\n                                ;\n                                _t2 = -_t2 / this.U[_k][_k];\n                                for(var _i13 = _k; _i13 < this.m; _i13++){\n                                    this.U[_i13][_j4] += _t2 * this.U[_i13][_k];\n                                }\n                                ;\n                            }\n                            ;\n                            for(var _i14 = _k; _i14 < this.m; _i14++){\n                                this.U[_i14][_k] = -this.U[_i14][_k];\n                            }\n                            ;\n                            this.U[_k][_k] = 1.0 + this.U[_k][_k];\n                            for(var _i15 = 0; _i15 < _k - 1; _i15++){\n                                this.U[_i15][_k] = 0.0;\n                            }\n                            ;\n                        } else {\n                            for(var _i16 = 0; _i16 < this.m; _i16++){\n                                this.U[_i16][_k] = 0.0;\n                            }\n                            ;\n                            this.U[_k][_k] = 1.0;\n                        }\n                    }\n                    ;\n                }\n                if (wantv) {\n                    for(var _k2 = this.n - 1; _k2 >= 0; _k2--){\n                        if (function(lhs, rhs) {\n                            return lhs && rhs;\n                        }(_k2 < nrt, e[_k2] !== 0.0)) {\n                            for(var _j5 = _k2 + 1; _j5 < nu; _j5++){\n                                var _t3 = 0;\n                                for(var _i17 = _k2 + 1; _i17 < this.n; _i17++){\n                                    _t3 += this.V[_i17][_k2] * this.V[_i17][_j5];\n                                }\n                                ;\n                                _t3 = -_t3 / this.V[_k2 + 1][_k2];\n                                for(var _i18 = _k2 + 1; _i18 < this.n; _i18++){\n                                    this.V[_i18][_j5] += _t3 * this.V[_i18][_k2];\n                                }\n                                ;\n                            }\n                            ;\n                        }\n                        for(var _i19 = 0; _i19 < this.n; _i19++){\n                            this.V[_i19][_k2] = 0.0;\n                        }\n                        ;\n                        this.V[_k2][_k2] = 1.0;\n                    }\n                    ;\n                }\n                var pp = p - 1;\n                var iter = 0;\n                var eps = Math.pow(2.0, -52.0);\n                var tiny = Math.pow(2.0, -966.0);\n                while(p > 0){\n                    var _k3 = void 0;\n                    var kase = void 0;\n                    for(_k3 = p - 2; _k3 >= -1; _k3--){\n                        if (_k3 === -1) {\n                            break;\n                        }\n                        if (Math.abs(e[_k3]) <= tiny + eps * (Math.abs(this.s[_k3]) + Math.abs(this.s[_k3 + 1]))) {\n                            e[_k3] = 0.0;\n                            break;\n                        }\n                    }\n                    ;\n                    if (_k3 === p - 2) {\n                        kase = 4;\n                    } else {\n                        var ks = void 0;\n                        for(ks = p - 1; ks >= _k3; ks--){\n                            if (ks === _k3) {\n                                break;\n                            }\n                            var _t4 = (ks !== p ? Math.abs(e[ks]) : 0.0) + (ks !== _k3 + 1 ? Math.abs(e[ks - 1]) : 0.0);\n                            if (Math.abs(this.s[ks]) <= tiny + eps * _t4) {\n                                this.s[ks] = 0.0;\n                                break;\n                            }\n                        }\n                        ;\n                        if (ks === _k3) {\n                            kase = 3;\n                        } else if (ks === p - 1) {\n                            kase = 1;\n                        } else {\n                            kase = 2;\n                            _k3 = ks;\n                        }\n                    }\n                    _k3++;\n                    switch(kase){\n                        case 1:\n                            {\n                                var f = e[p - 2];\n                                e[p - 2] = 0.0;\n                                for(var _j6 = p - 2; _j6 >= _k3; _j6--){\n                                    var _t5 = SVD.hypot(this.s[_j6], f);\n                                    var cs = this.s[_j6] / _t5;\n                                    var sn = f / _t5;\n                                    this.s[_j6] = _t5;\n                                    if (_j6 !== _k3) {\n                                        f = -sn * e[_j6 - 1];\n                                        e[_j6 - 1] = cs * e[_j6 - 1];\n                                    }\n                                    if (wantv) {\n                                        for(var _i20 = 0; _i20 < this.n; _i20++){\n                                            _t5 = cs * this.V[_i20][_j6] + sn * this.V[_i20][p - 1];\n                                            this.V[_i20][p - 1] = -sn * this.V[_i20][_j6] + cs * this.V[_i20][p - 1];\n                                            this.V[_i20][_j6] = _t5;\n                                        }\n                                        ;\n                                    }\n                                }\n                                ;\n                            }\n                            ;\n                            break;\n                        case 2:\n                            {\n                                var _f = e[_k3 - 1];\n                                e[_k3 - 1] = 0.0;\n                                for(var _j7 = _k3; _j7 < p; _j7++){\n                                    var _t6 = SVD.hypot(this.s[_j7], _f);\n                                    var _cs = this.s[_j7] / _t6;\n                                    var _sn = _f / _t6;\n                                    this.s[_j7] = _t6;\n                                    _f = -_sn * e[_j7];\n                                    e[_j7] = _cs * e[_j7];\n                                    if (wantu) {\n                                        for(var _i21 = 0; _i21 < this.m; _i21++){\n                                            _t6 = _cs * this.U[_i21][_j7] + _sn * this.U[_i21][_k3 - 1];\n                                            this.U[_i21][_k3 - 1] = -_sn * this.U[_i21][_j7] + _cs * this.U[_i21][_k3 - 1];\n                                            this.U[_i21][_j7] = _t6;\n                                        }\n                                        ;\n                                    }\n                                }\n                                ;\n                            }\n                            ;\n                            break;\n                        case 3:\n                            {\n                                var scale = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[p - 1]), Math.abs(this.s[p - 2])), Math.abs(e[p - 2])), Math.abs(this.s[_k3])), Math.abs(e[_k3]));\n                                var sp = this.s[p - 1] / scale;\n                                var spm1 = this.s[p - 2] / scale;\n                                var epm1 = e[p - 2] / scale;\n                                var sk = this.s[_k3] / scale;\n                                var ek = e[_k3] / scale;\n                                var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                                var c = sp * epm1 * (sp * epm1);\n                                var shift = 0.0;\n                                if (function(lhs, rhs) {\n                                    return lhs || rhs;\n                                }(b !== 0.0, c !== 0.0)) {\n                                    shift = Math.sqrt(b * b + c);\n                                    if (b < 0.0) {\n                                        shift = -shift;\n                                    }\n                                    shift = c / (b + shift);\n                                }\n                                var _f2 = (sk + sp) * (sk - sp) + shift;\n                                var g = sk * ek;\n                                for(var _j8 = _k3; _j8 < p - 1; _j8++){\n                                    var _t7 = SVD.hypot(_f2, g);\n                                    var _cs2 = _f2 / _t7;\n                                    var _sn2 = g / _t7;\n                                    if (_j8 !== _k3) {\n                                        e[_j8 - 1] = _t7;\n                                    }\n                                    _f2 = _cs2 * this.s[_j8] + _sn2 * e[_j8];\n                                    e[_j8] = _cs2 * e[_j8] - _sn2 * this.s[_j8];\n                                    g = _sn2 * this.s[_j8 + 1];\n                                    this.s[_j8 + 1] = _cs2 * this.s[_j8 + 1];\n                                    if (wantv) {\n                                        for(var _i22 = 0; _i22 < this.n; _i22++){\n                                            _t7 = _cs2 * this.V[_i22][_j8] + _sn2 * this.V[_i22][_j8 + 1];\n                                            this.V[_i22][_j8 + 1] = -_sn2 * this.V[_i22][_j8] + _cs2 * this.V[_i22][_j8 + 1];\n                                            this.V[_i22][_j8] = _t7;\n                                        }\n                                        ;\n                                    }\n                                    _t7 = SVD.hypot(_f2, g);\n                                    _cs2 = _f2 / _t7;\n                                    _sn2 = g / _t7;\n                                    this.s[_j8] = _t7;\n                                    _f2 = _cs2 * e[_j8] + _sn2 * this.s[_j8 + 1];\n                                    this.s[_j8 + 1] = -_sn2 * e[_j8] + _cs2 * this.s[_j8 + 1];\n                                    g = _sn2 * e[_j8 + 1];\n                                    e[_j8 + 1] = _cs2 * e[_j8 + 1];\n                                    if (wantu && _j8 < this.m - 1) {\n                                        for(var _i23 = 0; _i23 < this.m; _i23++){\n                                            _t7 = _cs2 * this.U[_i23][_j8] + _sn2 * this.U[_i23][_j8 + 1];\n                                            this.U[_i23][_j8 + 1] = -_sn2 * this.U[_i23][_j8] + _cs2 * this.U[_i23][_j8 + 1];\n                                            this.U[_i23][_j8] = _t7;\n                                        }\n                                        ;\n                                    }\n                                }\n                                ;\n                                e[p - 2] = _f2;\n                                iter = iter + 1;\n                            }\n                            ;\n                            break;\n                        case 4:\n                            {\n                                if (this.s[_k3] <= 0.0) {\n                                    this.s[_k3] = this.s[_k3] < 0.0 ? -this.s[_k3] : 0.0;\n                                    if (wantv) {\n                                        for(var _i24 = 0; _i24 <= pp; _i24++){\n                                            this.V[_i24][_k3] = -this.V[_i24][_k3];\n                                        }\n                                        ;\n                                    }\n                                }\n                                while(_k3 < pp){\n                                    if (this.s[_k3] >= this.s[_k3 + 1]) {\n                                        break;\n                                    }\n                                    var _t8 = this.s[_k3];\n                                    this.s[_k3] = this.s[_k3 + 1];\n                                    this.s[_k3 + 1] = _t8;\n                                    if (wantv && _k3 < this.n - 1) {\n                                        for(var _i25 = 0; _i25 < this.n; _i25++){\n                                            _t8 = this.V[_i25][_k3 + 1];\n                                            this.V[_i25][_k3 + 1] = this.V[_i25][_k3];\n                                            this.V[_i25][_k3] = _t8;\n                                        }\n                                        ;\n                                    }\n                                    if (wantu && _k3 < this.m - 1) {\n                                        for(var _i26 = 0; _i26 < this.m; _i26++){\n                                            _t8 = this.U[_i26][_k3 + 1];\n                                            this.U[_i26][_k3 + 1] = this.U[_i26][_k3];\n                                            this.U[_i26][_k3] = _t8;\n                                        }\n                                        ;\n                                    }\n                                    _k3++;\n                                }\n                                ;\n                                iter = 0;\n                                p--;\n                            }\n                            ;\n                            break;\n                    }\n                }\n                ;\n                var result = {\n                    U: this.U,\n                    V: this.V,\n                    S: this.s\n                };\n                return result;\n            };\n            // sqrt(a^2 + b^2) without under/overflow.\n            SVD.hypot = function(a, b) {\n                var r = void 0;\n                if (Math.abs(a) > Math.abs(b)) {\n                    r = b / a;\n                    r = Math.abs(a) * Math.sqrt(1 + r * r);\n                } else if (b != 0) {\n                    r = a / b;\n                    r = Math.abs(b) * Math.sqrt(1 + r * r);\n                } else {\n                    r = 0.0;\n                }\n                return r;\n            };\n            module1.exports = SVD;\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            /**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */ var NeedlemanWunsch = function() {\n                function NeedlemanWunsch(sequence1, sequence2) {\n                    var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n                    var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n                    var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n                    _classCallCheck(this, NeedlemanWunsch);\n                    this.sequence1 = sequence1;\n                    this.sequence2 = sequence2;\n                    this.match_score = match_score;\n                    this.mismatch_penalty = mismatch_penalty;\n                    this.gap_penalty = gap_penalty;\n                    // Just the remove redundancy\n                    this.iMax = sequence1.length + 1;\n                    this.jMax = sequence2.length + 1;\n                    // Grid matrix of scores\n                    this.grid = new Array(this.iMax);\n                    for(var i = 0; i < this.iMax; i++){\n                        this.grid[i] = new Array(this.jMax);\n                        for(var j = 0; j < this.jMax; j++){\n                            this.grid[i][j] = 0;\n                        }\n                    }\n                    // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n                    this.tracebackGrid = new Array(this.iMax);\n                    for(var _i = 0; _i < this.iMax; _i++){\n                        this.tracebackGrid[_i] = new Array(this.jMax);\n                        for(var _j = 0; _j < this.jMax; _j++){\n                            this.tracebackGrid[_i][_j] = [\n                                null,\n                                null,\n                                null\n                            ];\n                        }\n                    }\n                    // The aligned sequences (return multiple possibilities)\n                    this.alignments = [];\n                    // Final alignment score\n                    this.score = -1;\n                    // Calculate scores and tracebacks\n                    this.computeGrids();\n                }\n                _createClass(NeedlemanWunsch, [\n                    {\n                        key: \"getScore\",\n                        value: function getScore() {\n                            return this.score;\n                        }\n                    },\n                    {\n                        key: \"getAlignments\",\n                        value: function getAlignments() {\n                            return this.alignments;\n                        }\n                    },\n                    {\n                        key: \"computeGrids\",\n                        value: function computeGrids() {\n                            // Fill in the first row\n                            for(var j = 1; j < this.jMax; j++){\n                                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                                this.tracebackGrid[0][j] = [\n                                    false,\n                                    false,\n                                    true\n                                ];\n                            }\n                            // Fill in the first column\n                            for(var i = 1; i < this.iMax; i++){\n                                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                                this.tracebackGrid[i][0] = [\n                                    false,\n                                    true,\n                                    false\n                                ];\n                            }\n                            // Fill the rest of the grid\n                            for(var _i2 = 1; _i2 < this.iMax; _i2++){\n                                for(var _j2 = 1; _j2 < this.jMax; _j2++){\n                                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                                    var diag = void 0;\n                                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;\n                                    else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n                                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n                                    // If there exists multiple max values, capture them for multiple paths\n                                    var maxOf = [\n                                        diag,\n                                        up,\n                                        left\n                                    ];\n                                    var indices = this.arrayAllMaxIndexes(maxOf);\n                                    // Update Grids\n                                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                                    this.tracebackGrid[_i2][_j2] = [\n                                        indices.includes(0),\n                                        indices.includes(1),\n                                        indices.includes(2)\n                                    ];\n                                }\n                            }\n                            // Update alignment score\n                            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n                        }\n                    },\n                    {\n                        key: \"alignmentTraceback\",\n                        value: function alignmentTraceback() {\n                            var inProcessAlignments = [];\n                            inProcessAlignments.push({\n                                pos: [\n                                    this.sequence1.length,\n                                    this.sequence2.length\n                                ],\n                                seq1: \"\",\n                                seq2: \"\"\n                            });\n                            while(inProcessAlignments[0]){\n                                var current = inProcessAlignments[0];\n                                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n                                if (directions[0]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0] - 1,\n                                            current.pos[1] - 1\n                                        ],\n                                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                                    });\n                                }\n                                if (directions[1]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0] - 1,\n                                            current.pos[1]\n                                        ],\n                                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                                        seq2: \"-\" + current.seq2\n                                    });\n                                }\n                                if (directions[2]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0],\n                                            current.pos[1] - 1\n                                        ],\n                                        seq1: \"-\" + current.seq1,\n                                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                                    });\n                                }\n                                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({\n                                    sequence1: current.seq1,\n                                    sequence2: current.seq2\n                                });\n                                inProcessAlignments.shift();\n                            }\n                            return this.alignments;\n                        }\n                    },\n                    {\n                        key: \"getAllIndexes\",\n                        value: function getAllIndexes(arr, val) {\n                            var indexes = [], i = -1;\n                            while((i = arr.indexOf(val, i + 1)) !== -1){\n                                indexes.push(i);\n                            }\n                            return indexes;\n                        }\n                    },\n                    {\n                        key: \"arrayAllMaxIndexes\",\n                        value: function arrayAllMaxIndexes(array) {\n                            return this.getAllIndexes(array, Math.max.apply(null, array));\n                        }\n                    }\n                ]);\n                return NeedlemanWunsch;\n            }();\n            module1.exports = NeedlemanWunsch;\n        /***/ },\n        /* 28 */ /***/ function(module1, exports1, __nested_webpack_require_205988__) {\n            \"use strict\";\n            var layoutBase = function layoutBase() {\n                return;\n            };\n            layoutBase.FDLayout = __nested_webpack_require_205988__(18);\n            layoutBase.FDLayoutConstants = __nested_webpack_require_205988__(4);\n            layoutBase.FDLayoutEdge = __nested_webpack_require_205988__(19);\n            layoutBase.FDLayoutNode = __nested_webpack_require_205988__(20);\n            layoutBase.DimensionD = __nested_webpack_require_205988__(21);\n            layoutBase.HashMap = __nested_webpack_require_205988__(22);\n            layoutBase.HashSet = __nested_webpack_require_205988__(23);\n            layoutBase.IGeometry = __nested_webpack_require_205988__(8);\n            layoutBase.IMath = __nested_webpack_require_205988__(9);\n            layoutBase.Integer = __nested_webpack_require_205988__(10);\n            layoutBase.Point = __nested_webpack_require_205988__(12);\n            layoutBase.PointD = __nested_webpack_require_205988__(5);\n            layoutBase.RandomSeed = __nested_webpack_require_205988__(16);\n            layoutBase.RectangleD = __nested_webpack_require_205988__(13);\n            layoutBase.Transform = __nested_webpack_require_205988__(17);\n            layoutBase.UniqueIDGeneretor = __nested_webpack_require_205988__(14);\n            layoutBase.Quicksort = __nested_webpack_require_205988__(25);\n            layoutBase.LinkedList = __nested_webpack_require_205988__(11);\n            layoutBase.LGraphObject = __nested_webpack_require_205988__(2);\n            layoutBase.LGraph = __nested_webpack_require_205988__(6);\n            layoutBase.LEdge = __nested_webpack_require_205988__(1);\n            layoutBase.LGraphManager = __nested_webpack_require_205988__(7);\n            layoutBase.LNode = __nested_webpack_require_205988__(3);\n            layoutBase.Layout = __nested_webpack_require_205988__(15);\n            layoutBase.LayoutConstants = __nested_webpack_require_205988__(0);\n            layoutBase.NeedlemanWunsch = __nested_webpack_require_205988__(27);\n            layoutBase.Matrix = __nested_webpack_require_205988__(24);\n            layoutBase.SVD = __nested_webpack_require_205988__(26);\n            module1.exports = layoutBase;\n        /***/ },\n        /* 29 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function Emitter() {\n                this.listeners = [];\n            }\n            var p = Emitter.prototype;\n            p.addListener = function(event, callback) {\n                this.listeners.push({\n                    event: event,\n                    callback: callback\n                });\n            };\n            p.removeListener = function(event, callback) {\n                for(var i = this.listeners.length; i >= 0; i--){\n                    var l = this.listeners[i];\n                    if (l.event === event && l.callback === callback) {\n                        this.listeners.splice(i, 1);\n                    }\n                }\n            };\n            p.emit = function(event, data) {\n                for(var i = 0; i < this.listeners.length; i++){\n                    var l = this.listeners[i];\n                    if (event === l.event) {\n                        l.callback(data);\n                    }\n                }\n            };\n            module1.exports = Emitter;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9sYXlvdXQtYmFzZS9sYXlvdXQtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdEO1NBQ2IsRUFLMkJBO0FBQ2pDLEdBQUcsSUFBSSxFQUFFO0lBQ1QsT0FBZ0IsTUFBSCxHQUFJLFNBQVNLLE9BQU87UUFDakMsTUFBTSxHQUFJLG1CQUFtQjtRQUM3QixNQUFNLEdBQUksSUFBSUMsbUJBQW1CLENBQUM7UUFDbEMsTUFBTSxHQUNOLE1BQU0sR0FBSSx1QkFBdUI7UUFDakMsTUFBTSxHQUFJLFNBQVNDLDhCQUFtQkEsQ0FBQ0MsUUFBUTtZQUMvQyxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUssSUFBR0YsZ0JBQWdCLENBQUNFLFNBQVMsRUFBRTtnQkFDMUMsTUFBTSxHQUFNLE9BQU9GLGdCQUFnQixDQUFDRSxTQUFTLENBQUNQLE9BQU87WUFDckQsTUFBTSxHQUFLO1lBQ1gsTUFBTSxHQUFLLGtEQUFrRDtZQUM3RCxNQUFNLEdBQUssSUFBSUMsVUFBU0ksZ0JBQWdCLENBQUNFLFNBQVMsR0FBRztnQkFDckQsTUFBTSxHQUFNQyxHQUFHRDtnQkFDZixNQUFNLEdBQU1FLEdBQUc7Z0JBQ2YsTUFBTSxHQUFNVCxTQUFTLENBQUM7WUFDWDtZQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS0ksT0FBTyxDQUFDRyxTQUFTLENBQUNHLElBQUksQ0FBQ1QsUUFBT0QsT0FBTyxFQUFFQyxTQUFRQSxRQUFPRCxPQUFPLEVBQUVNLDhCQUFtQkE7WUFDN0YsTUFBTSxHQUNOLE1BQU0sR0FBSyw0QkFBNEI7WUFDdkMsTUFBTSxHQUFLTCxRQUFPUSxDQUFDLEdBQUc7WUFDdEIsTUFBTSxHQUNOLE1BQU0sR0FB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RCxJQUFJLENBQUNILFNBQVMsQ0FBQ2xsQixNQUFNLENBQUMzTyxHQUFHO29CQUMzQjtnQkFDRjtZQUNGO1lBRUF1QixFQUFFMnlCLElBQUksR0FBRyxTQUFVSCxLQUFLLEVBQUVJLElBQUk7Z0JBQzVCLElBQUssSUFBSW4wQixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNnpCLFNBQVMsQ0FBQ2x3QixNQUFNLEVBQUUzRCxJQUFLO29CQUM5QyxJQUFJQyxJQUFJLElBQUksQ0FBQzR6QixTQUFTLENBQUM3ekIsRUFBRTtvQkFFekIsSUFBSSt6QixVQUFVOXpCLEVBQUU4ekIsS0FBSyxFQUFFO3dCQUNyQjl6QixFQUFFK3pCLFFBQVEsQ0FBQ0c7b0JBQ2I7Z0JBQ0Y7WUFDRjtZQUVBMTBCLFFBQU9ELE9BQU8sR0FBRzZkO1FBRWpCLEdBQUcsR0FBRztLQUNJO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXJvLW5ldHdvcmstd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2Uvbm9kZV9tb2R1bGVzL2xheW91dC1iYXNlL2xheW91dC1iYXNlLmpzP2EzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibGF5b3V0QmFzZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJsYXlvdXRCYXNlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjgpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBMYXlvdXRDb25zdGFudHMoKSB7fVxuXG4vKipcclxuICogTGF5b3V0IFF1YWxpdHk6IDA6ZHJhZnQsIDE6ZGVmYXVsdCwgMjpwcm9vZlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5RVUFMSVRZID0gMTtcblxuLyoqXHJcbiAqIERlZmF1bHQgcGFyYW1ldGVyc1xyXG4gKi9cbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUID0gdHJ1ZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EID0gNTA7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUyA9IGZhbHNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogR2VuZXJhbCBvdGhlciBjb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKlxyXG4gKiBNYXJnaW5zIG9mIGEgZ3JhcGggdG8gYmUgYXBwbGllZCBvbiBib3VkaW5nIHJlY3RhbmdsZSBvZiBpdHMgY29udGVudHMuIFdlXHJcbiAqIGFzc3VtZSBtYXJnaW5zIG9uIGFsbCBmb3VyIHNpZGVzIHRvIGJlIHVuaWZvcm0uXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfTUFSR0lOID0gMTU7XG5cbi8qXHJcbiAqIFdoZXRoZXIgdG8gY29uc2lkZXIgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9ucyBvciBub3RcclxuICovXG5MYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gZmFsc2U7XG5cbi8qXHJcbiAqIERlZmF1bHQgZGltZW5zaW9uIG9mIGEgbm9uLWNvbXBvdW5kIG5vZGUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkUgPSA0MDtcblxuLypcclxuICogRGVmYXVsdCBkaW1lbnNpb24gb2YgYSBub24tY29tcG91bmQgbm9kZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfSEFMRl9TSVpFID0gTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkUgLyAyO1xuXG4vKlxyXG4gKiBFbXB0eSBjb21wb3VuZCBub2RlIHNpemUuIFdoZW4gYSBjb21wb3VuZCBub2RlIGlzIGVtcHR5LCBpdHMgYm90aFxyXG4gKiBkaW1lbnNpb25zIHNob3VsZCBiZSBvZiB0aGlzIHZhbHVlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5FTVBUWV9DT01QT1VORF9OT0RFX1NJWkUgPSA0MDtcblxuLypcclxuICogTWluaW11bSBsZW5ndGggdGhhdCBhbiBlZGdlIHNob3VsZCB0YWtlIGR1cmluZyBsYXlvdXRcclxuICovXG5MYXlvdXRDb25zdGFudHMuTUlOX0VER0VfTEVOR1RIID0gMTtcblxuLypcclxuICogV29ybGQgYm91bmRhcmllcyB0aGF0IGxheW91dCBvcGVyYXRlcyBvblxyXG4gKi9cbkxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSA9IDEwMDAwMDA7XG5cbi8qXHJcbiAqIFdvcmxkIGJvdW5kYXJpZXMgdGhhdCByYW5kb20gcG9zaXRpb25pbmcgY2FuIGJlIHBlcmZvcm1lZCB3aXRoXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlkgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkgLyAxMDAwO1xuXG4vKlxyXG4gKiBDb29yZGluYXRlcyBvZiB0aGUgd29ybGQgY2VudGVyXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YID0gMTIwMDtcbkxheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSA9IDkwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXRDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIElNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuZnVuY3Rpb24gTEVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZFZGdlKTtcblxuICB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IGZhbHNlO1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZFZGdlO1xuICB0aGlzLmJlbmRwb2ludHMgPSBbXTtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5MRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMRWRnZVtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTEVkZ2UucHJvdG90eXBlLmdldFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudGFyZ2V0O1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmlzSW50ZXJHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNJbnRlckdyYXBoO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0O1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldEJlbmRwb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmJlbmRwb2ludHM7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0TGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0U291cmNlSW5MY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZUluTGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFRhcmdldEluTGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50YXJnZXRJbkxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRPdGhlckVuZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLnNvdXJjZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIk5vZGUgaXMgbm90IGluY2lkZW50IHdpdGggdGhpcyBlZGdlXCI7XG4gIH1cbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRPdGhlckVuZEluR3JhcGggPSBmdW5jdGlvbiAobm9kZSwgZ3JhcGgpIHtcbiAgdmFyIG90aGVyRW5kID0gdGhpcy5nZXRPdGhlckVuZChub2RlKTtcbiAgdmFyIHJvb3QgPSBncmFwaC5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAob3RoZXJFbmQuZ2V0T3duZXIoKSA9PSBncmFwaCkge1xuICAgICAgcmV0dXJuIG90aGVyRW5kO1xuICAgIH1cblxuICAgIGlmIChvdGhlckVuZC5nZXRPd25lcigpID09IHJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG90aGVyRW5kID0gb3RoZXJFbmQuZ2V0T3duZXIoKS5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLnVwZGF0ZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNsaXBQb2ludENvb3JkaW5hdGVzID0gbmV3IEFycmF5KDQpO1xuXG4gIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbih0aGlzLnRhcmdldC5nZXRSZWN0KCksIHRoaXMuc291cmNlLmdldFJlY3QoKSwgY2xpcFBvaW50Q29vcmRpbmF0ZXMpO1xuXG4gIGlmICghdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQpIHtcbiAgICB0aGlzLmxlbmd0aFggPSBjbGlwUG9pbnRDb29yZGluYXRlc1swXSAtIGNsaXBQb2ludENvb3JkaW5hdGVzWzJdO1xuICAgIHRoaXMubGVuZ3RoWSA9IGNsaXBQb2ludENvb3JkaW5hdGVzWzFdIC0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbM107XG5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhYKSA8IDEuMCkge1xuICAgICAgdGhpcy5sZW5ndGhYID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFgpO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFkpIDwgMS4wKSB7XG4gICAgICB0aGlzLmxlbmd0aFkgPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWSk7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhYICogdGhpcy5sZW5ndGhYICsgdGhpcy5sZW5ndGhZICogdGhpcy5sZW5ndGhZKTtcbiAgfVxufTtcblxuTEVkZ2UucHJvdG90eXBlLnVwZGF0ZUxlbmd0aFNpbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sZW5ndGhYID0gdGhpcy50YXJnZXQuZ2V0Q2VudGVyWCgpIC0gdGhpcy5zb3VyY2UuZ2V0Q2VudGVyWCgpO1xuICB0aGlzLmxlbmd0aFkgPSB0aGlzLnRhcmdldC5nZXRDZW50ZXJZKCkgLSB0aGlzLnNvdXJjZS5nZXRDZW50ZXJZKCk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWCkgPCAxLjApIHtcbiAgICB0aGlzLmxlbmd0aFggPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhZKSA8IDEuMCkge1xuICAgIHRoaXMubGVuZ3RoWSA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhZKTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoWCAqIHRoaXMubGVuZ3RoWCArIHRoaXMubGVuZ3RoWSAqIHRoaXMubGVuZ3RoWSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gTEdyYXBoT2JqZWN0KHZHcmFwaE9iamVjdCkge1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZHcmFwaE9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMR3JhcGhPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUmFuZG9tU2VlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbmZ1bmN0aW9uIExOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIC8vQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgMSA6IExOb2RlKExHcmFwaE1hbmFnZXIgZ20sIFBvaW50IGxvYywgRGltZW5zaW9uIHNpemUsIE9iamVjdCB2Tm9kZSlcbiAgaWYgKHNpemUgPT0gbnVsbCAmJiB2Tm9kZSA9PSBudWxsKSB7XG4gICAgdk5vZGUgPSBsb2M7XG4gIH1cblxuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2Tm9kZSk7XG5cbiAgLy9BbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciAyIDogTE5vZGUoTGF5b3V0IGxheW91dCwgT2JqZWN0IHZOb2RlKVxuICBpZiAoZ20uZ3JhcGhNYW5hZ2VyICE9IG51bGwpIGdtID0gZ20uZ3JhcGhNYW5hZ2VyO1xuXG4gIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IEludGVnZXIuTUlOX1ZBTFVFO1xuICB0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZOb2RlO1xuICB0aGlzLmVkZ2VzID0gW107XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG5cbiAgaWYgKHNpemUgIT0gbnVsbCAmJiBsb2MgIT0gbnVsbCkgdGhpcy5yZWN0ID0gbmV3IFJlY3RhbmdsZUQobG9jLngsIGxvYy55LCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7ZWxzZSB0aGlzLnJlY3QgPSBuZXcgUmVjdGFuZ2xlRCgpO1xufVxuXG5MTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTE5vZGVbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWRnZXM7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE93bmVyID0gZnVuY3Rpb24gKCkge1xuICAvLyAgaWYgKHRoaXMub3duZXIgIT0gbnVsbCkge1xuICAvLyAgICBpZiAoISh0aGlzLm93bmVyID09IG51bGwgfHwgdGhpcy5vd25lci5nZXROb2RlcygpLmluZGV4T2YodGhpcykgPiAtMSkpIHtcbiAgLy8gICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgLy8gICAgfVxuICAvLyAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMucmVjdC53aWR0aCA9IHdpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLnJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aCAvIDIsIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodCAvIDIpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLnJlY3QueCwgdGhpcy5yZWN0LnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RGlhZ29uYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5yZWN0LndpZHRoICogdGhpcy5yZWN0LndpZHRoICsgdGhpcy5yZWN0LmhlaWdodCAqIHRoaXMucmVjdC5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGhhbGYgdGhlIGRpYWdvbmFsIGxlbmd0aCBvZiB0aGlzIG5vZGUuXG4gKi9cbkxOb2RlLnByb3RvdHlwZS5nZXRIYWxmVGhlRGlhZ29uYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5yZWN0LmhlaWdodCAqIHRoaXMucmVjdC5oZWlnaHQgKyB0aGlzLnJlY3Qud2lkdGggKiB0aGlzLnJlY3Qud2lkdGgpIC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRSZWN0ID0gZnVuY3Rpb24gKHVwcGVyTGVmdCwgZGltZW5zaW9uKSB7XG4gIHRoaXMucmVjdC54ID0gdXBwZXJMZWZ0Lng7XG4gIHRoaXMucmVjdC55ID0gdXBwZXJMZWZ0Lnk7XG4gIHRoaXMucmVjdC53aWR0aCA9IGRpbWVuc2lvbi53aWR0aDtcbiAgdGhpcy5yZWN0LmhlaWdodCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGN4LCBjeSkge1xuICB0aGlzLnJlY3QueCA9IGN4IC0gdGhpcy5yZWN0LndpZHRoIC8gMjtcbiAgdGhpcy5yZWN0LnkgPSBjeSAtIHRoaXMucmVjdC5oZWlnaHQgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdGhpcy5yZWN0LnggPSB4O1xuICB0aGlzLnJlY3QueSA9IHk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUubW92ZUJ5ID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnJlY3QueCArPSBkeDtcbiAgdGhpcy5yZWN0LnkgKz0gZHk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZUxpc3RUb05vZGUgPSBmdW5jdGlvbiAodG8pIHtcbiAgdmFyIGVkZ2VMaXN0ID0gW107XG4gIHZhciBlZGdlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgPT0gdG8pIHtcbiAgICAgIGlmIChlZGdlLnNvdXJjZSAhPSBzZWxmKSB0aHJvdyBcIkluY29ycmVjdCBlZGdlIHNvdXJjZSFcIjtcblxuICAgICAgZWRnZUxpc3QucHVzaChlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlc0JldHdlZW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgdmFyIGVkZ2VMaXN0ID0gW107XG4gIHZhciBlZGdlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZSA9PSBzZWxmIHx8IGVkZ2UudGFyZ2V0ID09IHNlbGYpKSB0aHJvdyBcIkluY29ycmVjdCBlZGdlIHNvdXJjZSBhbmQvb3IgdGFyZ2V0XCI7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgPT0gb3RoZXIgfHwgZWRnZS5zb3VyY2UgPT0gb3RoZXIpIHtcbiAgICAgIGVkZ2VMaXN0LnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWRnZUxpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5laWdoYm9ycyA9IG5ldyBTZXQoKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKGVkZ2Uuc291cmNlID09IHNlbGYpIHtcbiAgICAgIG5laWdoYm9ycy5hZGQoZWRnZS50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWRnZS50YXJnZXQgIT0gc2VsZikge1xuICAgICAgICB0aHJvdyBcIkluY29ycmVjdCBpbmNpZGVuY3khXCI7XG4gICAgICB9XG5cbiAgICAgIG5laWdoYm9ycy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn07XG5cbkxOb2RlLnByb3RvdHlwZS53aXRoQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3aXRoTmVpZ2hib3JzTGlzdCA9IG5ldyBTZXQoKTtcbiAgdmFyIGNoaWxkTm9kZTtcbiAgdmFyIGNoaWxkcmVuO1xuXG4gIHdpdGhOZWlnaGJvcnNMaXN0LmFkZCh0aGlzKTtcblxuICBpZiAodGhpcy5jaGlsZCAhPSBudWxsKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkTm9kZSA9IG5vZGVzW2ldO1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZE5vZGUud2l0aENoaWxkcmVuKCk7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHdpdGhOZWlnaGJvcnNMaXN0LmFkZChub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aXRoTmVpZ2hib3JzTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXROb09mQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub09mQ2hpbGRyZW4gPSAwO1xuICB2YXIgY2hpbGROb2RlO1xuXG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICBub09mQ2hpbGRyZW4gPSAxO1xuICB9IGVsc2Uge1xuICAgIHZhciBub2RlcyA9IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgbm9PZkNoaWxkcmVuICs9IGNoaWxkTm9kZS5nZXROb09mQ2hpbGRyZW4oKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9PZkNoaWxkcmVuID09IDApIHtcbiAgICBub09mQ2hpbGRyZW4gPSAxO1xuICB9XG4gIHJldHVybiBub09mQ2hpbGRyZW47XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZXN0aW1hdGVkU2l6ZSA9PSBJbnRlZ2VyLk1JTl9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplID0gKHRoaXMucmVjdC53aWR0aCArIHRoaXMucmVjdC5oZWlnaHQpIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSB0aGlzLmNoaWxkLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gICAgdGhpcy5yZWN0LndpZHRoID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICAgIHRoaXMucmVjdC5oZWlnaHQgPSB0aGlzLmVzdGltYXRlZFNpemU7XG5cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICB9XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2NhdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhbmRvbUNlbnRlclg7XG4gIHZhciByYW5kb21DZW50ZXJZO1xuXG4gIHZhciBtaW5YID0gLUxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICB2YXIgbWF4WCA9IExheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICByYW5kb21DZW50ZXJYID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YICsgUmFuZG9tU2VlZC5uZXh0RG91YmxlKCkgKiAobWF4WCAtIG1pblgpICsgbWluWDtcblxuICB2YXIgbWluWSA9IC1MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgdmFyIG1heFkgPSBMYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgcmFuZG9tQ2VudGVyWSA9IExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSArIFJhbmRvbVNlZWQubmV4dERvdWJsZSgpICogKG1heFkgLSBtaW5ZKSArIG1pblk7XG5cbiAgdGhpcy5yZWN0LnggPSByYW5kb21DZW50ZXJYO1xuICB0aGlzLnJlY3QueSA9IHJhbmRvbUNlbnRlclk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICBpZiAodGhpcy5nZXRDaGlsZCgpLmdldE5vZGVzKCkubGVuZ3RoICE9IDApIHtcbiAgICAvLyB3cmFwIHRoZSBjaGlsZHJlbiBub2RlcyBieSByZS1hcnJhbmdpbmcgdGhlIGJvdW5kYXJpZXNcbiAgICB2YXIgY2hpbGRHcmFwaCA9IHRoaXMuZ2V0Q2hpbGQoKTtcbiAgICBjaGlsZEdyYXBoLnVwZGF0ZUJvdW5kcyh0cnVlKTtcblxuICAgIHRoaXMucmVjdC54ID0gY2hpbGRHcmFwaC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yZWN0LnkgPSBjaGlsZEdyYXBoLmdldFRvcCgpO1xuXG4gICAgdGhpcy5zZXRXaWR0aChjaGlsZEdyYXBoLmdldFJpZ2h0KCkgLSBjaGlsZEdyYXBoLmdldExlZnQoKSk7XG4gICAgdGhpcy5zZXRIZWlnaHQoY2hpbGRHcmFwaC5nZXRCb3R0b20oKSAtIGNoaWxkR3JhcGguZ2V0VG9wKCkpO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyAgICBcbiAgICBpZiAoTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjaGlsZEdyYXBoLmdldFJpZ2h0KCkgLSBjaGlsZEdyYXBoLmdldExlZnQoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBjaGlsZEdyYXBoLmdldEJvdHRvbSgpIC0gY2hpbGRHcmFwaC5nZXRUb3AoKTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueCAtPSB0aGlzLmxhYmVsV2lkdGg7XG4gICAgICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCArIHRoaXMubGFiZWxXaWR0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiB0aGlzLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIHRoaXMucmVjdC54IC09ICh0aGlzLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHdpZHRoICsgdGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSB0aGlzLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCArIHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImNlbnRlclwiICYmIHRoaXMubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSAodGhpcy5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0ICsgdGhpcy5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmluY2x1c2lvblRyZWVEZXB0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgdmFyIGxlZnQgPSB0aGlzLnJlY3QueDtcblxuICBpZiAobGVmdCA+IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIGxlZnQgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH0gZWxzZSBpZiAobGVmdCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICBsZWZ0ID0gLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfVxuXG4gIHZhciB0b3AgPSB0aGlzLnJlY3QueTtcblxuICBpZiAodG9wID4gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgdG9wID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9IGVsc2UgaWYgKHRvcCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICB0b3AgPSAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9XG5cbiAgdmFyIGxlZnRUb3AgPSBuZXcgUG9pbnREKGxlZnQsIHRvcCk7XG4gIHZhciB2TGVmdFRvcCA9IHRyYW5zLmludmVyc2VUcmFuc2Zvcm1Qb2ludChsZWZ0VG9wKTtcblxuICB0aGlzLnNldExvY2F0aW9uKHZMZWZ0VG9wLngsIHZMZWZ0VG9wLnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm93bmVyID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyLmdldFBhcmVudCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMTm9kZTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBGRExheW91dENvbnN0YW50cygpIHt9XG5cbi8vRkRMYXlvdXRDb25zdGFudHMgaW5oZXJpdHMgc3RhdGljIHByb3BzIGluIExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXRDb25zdGFudHMpIHtcbiAgRkRMYXlvdXRDb25zdGFudHNbcHJvcF0gPSBMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gMjUwMDtcblxuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IDUwO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSAwLjQ1O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSA0NTAwLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSAwLjQ7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSAxLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gMy44O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IDEuNTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OID0gdHJ1ZTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX1JFUFVMU0lPTl9SQU5HRV9DQUxDVUxBVElPTiA9IHRydWU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gMC4zO1xuRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiA9IDAuMzM7XG5GRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQgPSAxMDAwO1xuRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUID0gNTAwMDtcbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCA9IDEwMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMICogMztcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID0gMTAwO1xuRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IDAuMTtcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9FREdFX0xFTkdUSCA9IDE7XG5GRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9IDEwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Q29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUG9pbnREKHgsIHkpIHtcbiAgaWYgKHggPT0gbnVsbCAmJiB5ID09IG51bGwpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG59XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiAoeSkge1xuICB0aGlzLnkgPSB5O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHB0KSB7XG4gIHJldHVybiBuZXcgRGltZW5zaW9uRCh0aGlzLnggLSBwdC54LCB0aGlzLnkgLSBwdC55KTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuUG9pbnRELnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZGltKSB7XG4gIHRoaXMueCArPSBkaW0ud2lkdGg7XG4gIHRoaXMueSArPSBkaW0uaGVpZ2h0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnREO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBSZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbmZ1bmN0aW9uIExHcmFwaChwYXJlbnQsIG9iajIsIHZHcmFwaCkge1xuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2R3JhcGgpO1xuICB0aGlzLmVzdGltYXRlZFNpemUgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgdGhpcy5tYXJnaW4gPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFQSF9NQVJHSU47XG4gIHRoaXMuZWRnZXMgPSBbXTtcbiAgdGhpcy5ub2RlcyA9IFtdO1xuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIGlmIChvYmoyICE9IG51bGwgJiYgb2JqMiBpbnN0YW5jZW9mIExHcmFwaE1hbmFnZXIpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajI7XG4gIH0gZWxzZSBpZiAob2JqMiAhPSBudWxsICYmIG9iajIgaW5zdGFuY2VvZiBMYXlvdXQpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajIuZ3JhcGhNYW5hZ2VyO1xuICB9XG59XG5cbkxHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTEdyYXBoW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MR3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlcztcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVkZ2VzO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlcjtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlZnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yaWdodDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50b3A7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYm90dG9tO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmoxLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIGlmIChzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgdmFyIG5ld05vZGUgPSBvYmoxO1xuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGhhcyBubyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE5vZGVzKCkuaW5kZXhPZihuZXdOb2RlKSA+IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgYWxyZWFkeSBpbiBncmFwaCFcIjtcbiAgICB9XG4gICAgbmV3Tm9kZS5vd25lciA9IHRoaXM7XG4gICAgdGhpcy5nZXROb2RlcygpLnB1c2gobmV3Tm9kZSk7XG5cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3RWRnZSA9IG9iajE7XG4gICAgaWYgKCEodGhpcy5nZXROb2RlcygpLmluZGV4T2Yoc291cmNlTm9kZSkgPiAtMSAmJiB0aGlzLmdldE5vZGVzKCkuaW5kZXhPZih0YXJnZXROb2RlKSA+IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2Ugb3IgdGFyZ2V0IG5vdCBpbiBncmFwaCFcIjtcbiAgICB9XG5cbiAgICBpZiAoIShzb3VyY2VOb2RlLm93bmVyID09IHRhcmdldE5vZGUub3duZXIgJiYgc291cmNlTm9kZS5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJCb3RoIG93bmVycyBtdXN0IGJlIHRoaXMgZ3JhcGghXCI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZU5vZGUub3duZXIgIT0gdGFyZ2V0Tm9kZS5vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgIG5ld0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcblxuICAgIC8vIHNldCBhcyBpbnRyYS1ncmFwaCBlZGdlXG4gICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSBmYWxzZTtcblxuICAgIC8vIGFkZCB0byBncmFwaCBlZGdlIGxpc3RcbiAgICB0aGlzLmdldEVkZ2VzKCkucHVzaChuZXdFZGdlKTtcblxuICAgIC8vIGFkZCB0byBpbmNpZGVuY3kgbGlzdHNcbiAgICBzb3VyY2VOb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICBpZiAodGFyZ2V0Tm9kZSAhPSBzb3VyY2VOb2RlKSB7XG4gICAgICB0YXJnZXROb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0VkZ2U7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgbm9kZSA9IG9iajtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJOb2RlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKG5vZGUub3duZXIgIT0gbnVsbCAmJiBub2RlLm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIGlzIGludmFsaWQhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIG1hbmFnZXIgaXMgaW52YWxpZCFcIjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGluY2lkZW50IGVkZ2VzIGZpcnN0IChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIGVkZ2VzVG9CZVJlbW92ZWQgPSBub2RlLmVkZ2VzLnNsaWNlKCk7XG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG5cbiAgICAgIGlmIChlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlLnNvdXJjZS5vd25lci5yZW1vdmUoZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm93IHRoZSBub2RlIGl0c2VsZlxuICAgIHZhciBpbmRleCA9IHRoaXMubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm9kZSBub3QgaW4gb3duZXIgbm9kZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIHRoaXMubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIHZhciBlZGdlID0gb2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlLm93bmVyICE9IG51bGwgJiYgZWRnZS50YXJnZXQub3duZXIgIT0gbnVsbCAmJiBlZGdlLnNvdXJjZS5vd25lciA9PSB0aGlzICYmIGVkZ2UudGFyZ2V0Lm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IG93bmVyIGlzIGludmFsaWQhXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICB2YXIgdGFyZ2V0SW5kZXggPSBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGlmICghKHNvdXJjZUluZGV4ID4gLTEgJiYgdGFyZ2V0SW5kZXggPiAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgZG9lc24ndCBrbm93IHRoaXMgZWRnZSFcIjtcbiAgICB9XG5cbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2Uoc291cmNlSW5kZXgsIDEpO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9IGVkZ2Uuc291cmNlKSB7XG4gICAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuaW5kZXhPZihlZGdlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm90IGluIG93bmVyJ3MgZWRnZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVMZWZ0VG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBtYXJnaW47XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG4gIH1cblxuICAvLyBEbyB3ZSBoYXZlIGFueSBub2RlcyBpbiB0aGlzIGdyYXBoP1xuICBpZiAodG9wID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgbWFyZ2luID0gbm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQ7XG4gIH0gZWxzZSB7XG4gICAgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gIH1cblxuICB0aGlzLmxlZnQgPSBsZWZ0IC0gbWFyZ2luO1xuICB0aGlzLnRvcCA9IHRvcCAtIG1hcmdpbjtcblxuICAvLyBBcHBseSB0aGUgbWFyZ2lucyBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKHJlY3Vyc2l2ZSkge1xuICAvLyBjYWxjdWxhdGUgYm91bmRzXG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcbiAgdmFyIG1hcmdpbjtcblxuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChyZWN1cnNpdmUgJiYgbE5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgbE5vZGUudXBkYXRlQm91bmRzKCk7XG4gICAgfVxuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgaWYgKGxlZnQgPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICB0aGlzLmxlZnQgPSB0aGlzLnBhcmVudC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMucGFyZW50LmdldFJpZ2h0KCk7XG4gICAgdGhpcy50b3AgPSB0aGlzLnBhcmVudC5nZXRUb3AoKTtcbiAgICB0aGlzLmJvdHRvbSA9IHRoaXMucGFyZW50LmdldEJvdHRvbSgpO1xuICB9XG5cbiAgaWYgKG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0ICE9IHVuZGVmaW5lZCkge1xuICAgIG1hcmdpbiA9IG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0O1xuICB9IGVsc2Uge1xuICAgIG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICB9XG5cbiAgdGhpcy5sZWZ0ID0gYm91bmRpbmdSZWN0LnggLSBtYXJnaW47XG4gIHRoaXMucmlnaHQgPSBib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCArIG1hcmdpbjtcbiAgdGhpcy50b3AgPSBib3VuZGluZ1JlY3QueSAtIG1hcmdpbjtcbiAgdGhpcy5ib3R0b20gPSBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgKyBtYXJnaW47XG59O1xuXG5MR3JhcGguY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcblxuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcblxuICByZXR1cm4gYm91bmRpbmdSZWN0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzID09IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lc3RpbWF0ZWRTaXplID09IEludGVnZXIuTUlOX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBzaXplICs9IGxOb2RlLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gIH1cblxuICBpZiAoc2l6ZSA9PSAwKSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gTGF5b3V0Q29uc3RhbnRzLkVNUFRZX0NPTVBPVU5EX05PREVfU0laRTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBzaXplIC8gTWF0aC5zcXJ0KHRoaXMubm9kZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLm5vZGVzWzBdO1xuICB2YXIgbmVpZ2hib3JFZGdlcztcbiAgdmFyIGN1cnJlbnROZWlnaGJvcjtcbiAgdmFyIGNoaWxkcmVuT2ZOb2RlID0gY3VycmVudE5vZGUud2l0aENoaWxkcmVuKCk7XG4gIGNoaWxkcmVuT2ZOb2RlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICB9KTtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcbiAgICB2YXIgc2l6ZSA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbmVpZ2hib3JFZGdlID0gbmVpZ2hib3JFZGdlc1tpXTtcbiAgICAgIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZS5nZXRPdGhlckVuZEluR3JhcGgoY3VycmVudE5vZGUsIHRoaXMpO1xuXG4gICAgICAvLyBBZGQgdW52aXNpdGVkIG5laWdoYm9ycyB0byB0aGUgbGlzdCB0byB2aXNpdFxuICAgICAgaWYgKGN1cnJlbnROZWlnaGJvciAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3Iud2l0aENoaWxkcmVuKCk7XG5cbiAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbiAgaWYgKHZpc2l0ZWQuc2l6ZSA+PSB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBub09mVmlzaXRlZEluVGhpc0dyYXBoID0gMDtcblxuICAgIHZpc2l0ZWQuZm9yRWFjaChmdW5jdGlvbiAodmlzaXRlZE5vZGUpIHtcbiAgICAgIGlmICh2aXNpdGVkTm9kZS5vd25lciA9PSBzZWxmKSB7XG4gICAgICAgIG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGgrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChub09mVmlzaXRlZEluVGhpc0dyYXBoID09IHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaDtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmZ1bmN0aW9uIExHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7IC8vIEl0IG1heSBiZSBiZXR0ZXIgdG8gaW5pdGlsaXplIHRoaXMgb3V0IG9mIHRoaXMgZnVuY3Rpb24gYnV0IGl0IGdpdmVzIGFuIGVycm9yIChSaWdodC1oYW5kIHNpZGUgb2YgJ2luc3RhbmNlb2YnIGlzIG5vdCBjYWxsYWJsZSkgbm93LlxuICB0aGlzLmxheW91dCA9IGxheW91dDtcblxuICB0aGlzLmdyYXBocyA9IFtdO1xuICB0aGlzLmVkZ2VzID0gW107XG59XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmFkZFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZ3JhcGggPSB0aGlzLmxheW91dC5uZXdHcmFwaCgpO1xuICB2YXIgbm5vZGUgPSB0aGlzLmxheW91dC5uZXdOb2RlKG51bGwpO1xuICB2YXIgcm9vdCA9IHRoaXMuYWRkKG5ncmFwaCwgbm5vZGUpO1xuICB0aGlzLnNldFJvb3RHcmFwaChyb290KTtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5ld0dyYXBoLCBwYXJlbnROb2RlLCBuZXdFZGdlLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIC8vdGhlcmUgYXJlIGp1c3QgMiBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQgdGhlbiBpdCBhZGRzIGFuIExHcmFwaCBlbHNlIGl0IGFkZHMgYW4gTEVkZ2VcbiAgaWYgKG5ld0VkZ2UgPT0gbnVsbCAmJiBzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgaWYgKG5ld0dyYXBoID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiR3JhcGggaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJQYXJlbnQgbm9kZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncmFwaHMuaW5kZXhPZihuZXdHcmFwaCkgPiAtMSkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBhbHJlYWR5IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cblxuICAgIHRoaXMuZ3JhcGhzLnB1c2gobmV3R3JhcGgpO1xuXG4gICAgaWYgKG5ld0dyYXBoLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgcGFyZW50IVwiO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgY2hpbGQhXCI7XG4gICAgfVxuXG4gICAgbmV3R3JhcGgucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmNoaWxkID0gbmV3R3JhcGg7XG5cbiAgICByZXR1cm4gbmV3R3JhcGg7XG4gIH0gZWxzZSB7XG4gICAgLy9jaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAgdGFyZ2V0Tm9kZSA9IG5ld0VkZ2U7XG4gICAgc291cmNlTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgbmV3RWRnZSA9IG5ld0dyYXBoO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSB0YXJnZXROb2RlLmdldE93bmVyKCk7XG5cbiAgICBpZiAoIShzb3VyY2VHcmFwaCAhPSBudWxsICYmIHNvdXJjZUdyYXBoLmdldEdyYXBoTWFuYWdlcigpID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICghKHRhcmdldEdyYXBoICE9IG51bGwgJiYgdGFyZ2V0R3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiVGFyZ2V0IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlR3JhcGggPT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gZmFsc2U7XG4gICAgICByZXR1cm4gc291cmNlR3JhcGguYWRkKG5ld0VkZ2UsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IHRydWU7XG5cbiAgICAgIC8vIHNldCBzb3VyY2UgYW5kIHRhcmdldFxuICAgICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgICAgbmV3RWRnZS50YXJnZXQgPSB0YXJnZXROb2RlO1xuXG4gICAgICAvLyBhZGQgZWRnZSB0byBpbnRlci1ncmFwaCBlZGdlIGxpc3RcbiAgICAgIGlmICh0aGlzLmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPiAtMSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2UgYWxyZWFkeSBpbiBpbnRlci1ncmFwaCBlZGdlIGxpc3QhXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgLy8gYWRkIGVkZ2UgdG8gc291cmNlIGFuZCB0YXJnZXQgaW5jaWRlbmN5IGxpc3RzXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZSAhPSBudWxsICYmIG5ld0VkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBzb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID09IC0xICYmIG5ld0VkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPT0gLTEpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBhbHJlYWR5IGluIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IGluY2lkZW5jeSBsaXN0IVwiO1xuICAgICAgfVxuXG4gICAgICBuZXdFZGdlLnNvdXJjZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgICAgbmV3RWRnZS50YXJnZXQuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobE9iaikge1xuICBpZiAobE9iaiBpbnN0YW5jZW9mIExHcmFwaCkge1xuICAgIHZhciBncmFwaCA9IGxPYmo7XG4gICAgaWYgKGdyYXBoLmdldEdyYXBoTWFuYWdlcigpICE9IHRoaXMpIHtcbiAgICAgIHRocm93IFwiR3JhcGggbm90IGluIHRoaXMgZ3JhcGggbWdyXCI7XG4gICAgfVxuICAgIGlmICghKGdyYXBoID09IHRoaXMucm9vdEdyYXBoIHx8IGdyYXBoLnBhcmVudCAhPSBudWxsICYmIGdyYXBoLnBhcmVudC5ncmFwaE1hbmFnZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBwYXJlbnQgbm9kZSFcIjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCB0aGUgZWRnZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgZWRnZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgZWRnZXNUb0JlUmVtb3ZlZCA9IGVkZ2VzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldEVkZ2VzKCkpO1xuXG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gICAgLy8gdGhlbiB0aGUgbm9kZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgbm9kZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgbm9kZXNUb0JlUmVtb3ZlZCA9IG5vZGVzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldE5vZGVzKCkpO1xuXG4gICAgdmFyIG5vZGU7XG4gICAgcyA9IG5vZGVzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNUb0JlUmVtb3ZlZFtpXTtcbiAgICAgIGdyYXBoLnJlbW92ZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBncmFwaCBpcyB0aGUgcm9vdFxuICAgIGlmIChncmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgdGhpcy5zZXRSb290R3JhcGgobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gbm93IHJlbW92ZSB0aGUgZ3JhcGggaXRzZWxmXG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncmFwaHMuaW5kZXhPZihncmFwaCk7XG4gICAgdGhpcy5ncmFwaHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIGFsc28gcmVzZXQgdGhlIHBhcmVudCBvZiB0aGUgZ3JhcGhcbiAgICBncmFwaC5wYXJlbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGxPYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIGVkZ2UgPSBsT2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIWVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICB0aHJvdyBcIk5vdCBhbiBpbnRlci1ncmFwaCBlZGdlIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBzb3VyY2UgYW5kIHRhcmdldCBub2RlcycgaW5jaWRlbmN5IGxpc3RzXG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpICE9IC0xICYmIGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSkgIT0gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGRvZXNuJ3Qga25vdyB0aGlzIGVkZ2UhXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0gZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBvd25lciBncmFwaCBtYW5hZ2VyJ3MgaW50ZXItZ3JhcGggZWRnZSBsaXN0XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5vd25lciAhPSBudWxsICYmIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIkVkZ2Ugb3duZXIgZ3JhcGggb3Igb3duZXIgZ3JhcGggbWFuYWdlciBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuaW5kZXhPZihlZGdlKSA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb3QgaW4gb3duZXIgZ3JhcGggbWFuYWdlcidzIGVkZ2UgbGlzdCFcIjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yb290R3JhcGgudXBkYXRlQm91bmRzKHRydWUpO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JhcGhzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaHM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXMgPT0gbnVsbCkge1xuICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmFsbE5vZGVzID0gbm9kZUxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYWxsTm9kZXM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbE5vZGVzID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsRWRnZXMgPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsRWRnZXMgPT0gbnVsbCkge1xuICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldEVkZ2VzKCkpO1xuICAgIH1cblxuICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRoaXMuZWRnZXMpO1xuXG4gICAgdGhpcy5hbGxFZGdlcyA9IGVkZ2VMaXN0O1xuICB9XG4gIHJldHVybiB0aGlzLmFsbEVkZ2VzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAobm9kZUxpc3QpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gIT0gbnVsbCkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG5vZGVMaXN0O1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0Um9vdEdyYXBoID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gIGlmIChncmFwaC5nZXRHcmFwaE1hbmFnZXIoKSAhPSB0aGlzKSB7XG4gICAgdGhyb3cgXCJSb290IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgfVxuXG4gIHRoaXMucm9vdEdyYXBoID0gZ3JhcGg7XG4gIC8vIHJvb3QgZ3JhcGggbXVzdCBoYXZlIGEgcm9vdCBub2RlIGFzc29jaWF0ZWQgd2l0aCBpdCBmb3IgY29udmVuaWVuY2VcbiAgaWYgKGdyYXBoLnBhcmVudCA9PSBudWxsKSB7XG4gICAgZ3JhcGgucGFyZW50ID0gdGhpcy5sYXlvdXQubmV3Tm9kZShcIlJvb3Qgbm9kZVwiKTtcbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sYXlvdXQ7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pc09uZUFuY2VzdG9yT2ZPdGhlciA9IGZ1bmN0aW9uIChmaXJzdE5vZGUsIHNlY29uZE5vZGUpIHtcbiAgaWYgKCEoZmlyc3ROb2RlICE9IG51bGwgJiYgc2Vjb25kTm9kZSAhPSBudWxsKSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgaWYgKGZpcnN0Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSXMgc2Vjb25kIG5vZGUgYW4gYW5jZXN0b3Igb2YgdGhlIGZpcnN0IG9uZT9cbiAgdmFyIG93bmVyR3JhcGggPSBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcbiAgdmFyIHBhcmVudE5vZGU7XG5cbiAgZG8ge1xuICAgIHBhcmVudE5vZGUgPSBvd25lckdyYXBoLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuICAvLyBJcyBmaXJzdCBub2RlIGFuIGFuY2VzdG9yIG9mIHRoZSBzZWNvbmQgb25lP1xuICBvd25lckdyYXBoID0gc2Vjb25kTm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBwYXJlbnROb2RlID0gb3duZXJHcmFwaC5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlID09IGZpcnN0Tm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuICB2YXIgc291cmNlTm9kZTtcbiAgdmFyIHRhcmdldE5vZGU7XG4gIHZhciBzb3VyY2VBbmNlc3RvckdyYXBoO1xuICB2YXIgdGFyZ2V0QW5jZXN0b3JHcmFwaDtcblxuICB2YXIgZWRnZXMgPSB0aGlzLmdldEFsbEVkZ2VzKCk7XG4gIHZhciBzID0gZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIHNvdXJjZU5vZGUgPSBlZGdlLnNvdXJjZTtcbiAgICB0YXJnZXROb2RlID0gZWRnZS50YXJnZXQ7XG4gICAgZWRnZS5sY2EgPSBudWxsO1xuICAgIGVkZ2Uuc291cmNlSW5MY2EgPSBzb3VyY2VOb2RlO1xuICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuXG4gICAgaWYgKHNvdXJjZU5vZGUgPT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgZWRnZS5sY2EgPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzb3VyY2VBbmNlc3RvckdyYXBoID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuXG4gICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuICAgICAgdGFyZ2V0QW5jZXN0b3JHcmFwaCA9IHRhcmdldE5vZGUuZ2V0T3duZXIoKTtcblxuICAgICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRhcmdldEFuY2VzdG9yR3JhcGggPT0gc291cmNlQW5jZXN0b3JHcmFwaCkge1xuICAgICAgICAgIGVkZ2UubGNhID0gdGFyZ2V0QW5jZXN0b3JHcmFwaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRBbmNlc3RvckdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZS5sY2EgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXRBbmNlc3RvckdyYXBoLmdldFBhcmVudCgpO1xuICAgICAgICB0YXJnZXRBbmNlc3RvckdyYXBoID0gZWRnZS50YXJnZXRJbkxjYS5nZXRPd25lcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlQW5jZXN0b3JHcmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgZWRnZS5zb3VyY2VJbkxjYSA9IHNvdXJjZUFuY2VzdG9yR3JhcGguZ2V0UGFyZW50KCk7XG4gICAgICAgIHNvdXJjZUFuY2VzdG9yR3JhcGggPSBlZGdlLnNvdXJjZUluTGNhLmdldE93bmVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9yID0gZnVuY3Rpb24gKGZpcnN0Tm9kZSwgc2Vjb25kTm9kZSkge1xuICBpZiAoZmlyc3ROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICByZXR1cm4gZmlyc3ROb2RlLmdldE93bmVyKCk7XG4gIH1cbiAgdmFyIGZpcnN0T3duZXJHcmFwaCA9IGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBpZiAoZmlyc3RPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgc2Vjb25kT3duZXJHcmFwaCA9IHNlY29uZE5vZGUuZ2V0T3duZXIoKTtcblxuICAgIGRvIHtcbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IGZpcnN0T3duZXJHcmFwaCkge1xuICAgICAgICByZXR1cm4gc2Vjb25kT3duZXJHcmFwaDtcbiAgICAgIH1cbiAgICAgIHNlY29uZE93bmVyR3JhcGggPSBzZWNvbmRPd25lckdyYXBoLmdldFBhcmVudCgpLmdldE93bmVyKCk7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBmaXJzdE93bmVyR3JhcGggPSBmaXJzdE93bmVyR3JhcGguZ2V0UGFyZW50KCkuZ2V0T3duZXIoKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGZpcnN0T3duZXJHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzID0gZnVuY3Rpb24gKGdyYXBoLCBkZXB0aCkge1xuICBpZiAoZ3JhcGggPT0gbnVsbCAmJiBkZXB0aCA9PSBudWxsKSB7XG4gICAgZ3JhcGggPSB0aGlzLnJvb3RHcmFwaDtcbiAgICBkZXB0aCA9IDE7XG4gIH1cbiAgdmFyIG5vZGU7XG5cbiAgdmFyIG5vZGVzID0gZ3JhcGguZ2V0Tm9kZXMoKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGUuaW5jbHVzaW9uVHJlZURlcHRoID0gZGVwdGg7XG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKG5vZGUuY2hpbGQsIGRlcHRoICsgMSk7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pbmNsdWRlc0ludmFsaWRFZGdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIGVkZ2VzVG9SZW1vdmUgPSBbXTtcblxuICB2YXIgcyA9IHRoaXMuZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXG4gICAgaWYgKHRoaXMuaXNPbmVBbmNlc3Rvck9mT3RoZXIoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KSkge1xuICAgICAgZWRnZXNUb1JlbW92ZS5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBpbnZhbGlkIGVkZ2VzIGZyb20gZ3JhcGggbWFuYWdlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzVG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJlbW92ZShlZGdlc1RvUmVtb3ZlW2ldKTtcbiAgfVxuXG4gIC8vIEludmFsaWQgZWRnZXMgYXJlIGNsZWFyZWQsIHNvIHJldHVybiBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgbWFpbnRhaW5zIGEgbGlzdCBvZiBzdGF0aWMgZ2VvbWV0cnkgcmVsYXRlZCB1dGlsaXR5IG1ldGhvZHMuXG4gKlxuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuZnVuY3Rpb24gSUdlb21ldHJ5KCkge31cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzICpoYWxmKiB0aGUgYW1vdW50IGluIHggYW5kIHkgZGlyZWN0aW9ucyBvZiB0aGUgdHdvXG4gKiBpbnB1dCByZWN0YW5nbGVzIG5lZWRlZCB0byBzZXBhcmF0ZSB0aGVtIGtlZXBpbmcgdGhlaXIgcmVzcGVjdGl2ZVxuICogcG9zaXRpb25pbmcsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IGFycmF5LiBBbiBpbnB1dFxuICogc2VwYXJhdGlvbiBidWZmZXIgYWRkZWQgdG8gdGhlIGFtb3VudCBpbiBib3RoIGRpcmVjdGlvbnMuIFdlIGFzc3VtZSB0aGF0XG4gKiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gaW50ZXJzZWN0LlxuICovXG5JR2VvbWV0cnkuY2FsY1NlcGFyYXRpb25BbW91bnQgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdmVybGFwQW1vdW50LCBzZXBhcmF0aW9uQnVmZmVyKSB7XG4gIGlmICghcmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIHZhciBkaXJlY3Rpb25zID0gbmV3IEFycmF5KDIpO1xuXG4gIHRoaXMuZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMocmVjdEEsIHJlY3RCLCBkaXJlY3Rpb25zKTtcblxuICBvdmVybGFwQW1vdW50WzBdID0gTWF0aC5taW4ocmVjdEEuZ2V0UmlnaHQoKSwgcmVjdEIuZ2V0UmlnaHQoKSkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KTtcbiAgb3ZlcmxhcEFtb3VudFsxXSA9IE1hdGgubWluKHJlY3RBLmdldEJvdHRvbSgpLCByZWN0Qi5nZXRCb3R0b20oKSkgLSBNYXRoLm1heChyZWN0QS55LCByZWN0Qi55KTtcblxuICAvLyB1cGRhdGUgdGhlIG92ZXJsYXBwaW5nIGFtb3VudHMgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gIGlmIChyZWN0QS5nZXRYKCkgPD0gcmVjdEIuZ2V0WCgpICYmIHJlY3RBLmdldFJpZ2h0KCkgPj0gcmVjdEIuZ2V0UmlnaHQoKSkge1xuICAgIC8qIENhc2UgeC4xOlxuICAgICpcbiAgICAqIHJlY3RBXG4gICAgKiBcdHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgX19fX19fX19fICAgICAgfFxuICAgICogXHR8ICAgICAgICB8ICAgICAgIHwgICAgICB8XG4gICAgKiBcdHxfX19fX19fX3xfX19fX19ffF9fX19fX3xcbiAgICAqIFx0XHRcdCB8ICAgICAgIHxcbiAgICAqICAgICAgICAgICB8ICAgICAgIHxcbiAgICAqICAgICAgICByZWN0QlxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFswXSArPSBNYXRoLm1pbihyZWN0Qi5nZXRYKCkgLSByZWN0QS5nZXRYKCksIHJlY3RBLmdldFJpZ2h0KCkgLSByZWN0Qi5nZXRSaWdodCgpKTtcbiAgfSBlbHNlIGlmIChyZWN0Qi5nZXRYKCkgPD0gcmVjdEEuZ2V0WCgpICYmIHJlY3RCLmdldFJpZ2h0KCkgPj0gcmVjdEEuZ2V0UmlnaHQoKSkge1xuICAgIC8qIENhc2UgeC4yOlxuICAgICpcbiAgICAqIHJlY3RCXG4gICAgKiBcdHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgX19fX19fX19fICAgICAgfFxuICAgICogXHR8ICAgICAgICB8ICAgICAgIHwgICAgICB8XG4gICAgKiBcdHxfX19fX19fX3xfX19fX19ffF9fX19fX3xcbiAgICAqIFx0XHRcdCB8ICAgICAgIHxcbiAgICAqICAgICAgICAgICB8ICAgICAgIHxcbiAgICAqICAgICAgICByZWN0QVxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFswXSArPSBNYXRoLm1pbihyZWN0QS5nZXRYKCkgLSByZWN0Qi5nZXRYKCksIHJlY3RCLmdldFJpZ2h0KCkgLSByZWN0QS5nZXRSaWdodCgpKTtcbiAgfVxuICBpZiAocmVjdEEuZ2V0WSgpIDw9IHJlY3RCLmdldFkoKSAmJiByZWN0QS5nZXRCb3R0b20oKSA+PSByZWN0Qi5nZXRCb3R0b20oKSkge1xuICAgIC8qIENhc2UgeS4xOlxuICAgICAqICAgICAgICAgIF9fX19fX19fIHJlY3RBXG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8XG4gICAgICogICBfX19fX198X19fXyAgcmVjdEJcbiAgICAgKiAgICAgICAgIHwgICAgfFxuICAgICAqICAgICAgICAgfCAgICB8XG4gICAgICogICBfX19fX198X19fX3xcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxfX19fX19fX1xuICAgICAqXG4gICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFsxXSArPSBNYXRoLm1pbihyZWN0Qi5nZXRZKCkgLSByZWN0QS5nZXRZKCksIHJlY3RBLmdldEJvdHRvbSgpIC0gcmVjdEIuZ2V0Qm90dG9tKCkpO1xuICB9IGVsc2UgaWYgKHJlY3RCLmdldFkoKSA8PSByZWN0QS5nZXRZKCkgJiYgcmVjdEIuZ2V0Qm90dG9tKCkgPj0gcmVjdEEuZ2V0Qm90dG9tKCkpIHtcbiAgICAvKiBDYXNlIHkuMjpcbiAgICAqICAgICAgICAgIF9fX19fX19fIHJlY3RCXG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfFxuICAgICogICBfX19fX198X19fXyAgcmVjdEFcbiAgICAqICAgICAgICAgfCAgICB8XG4gICAgKiAgICAgICAgIHwgICAgfFxuICAgICogICBfX19fX198X19fX3xcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxfX19fX19fX1xuICAgICpcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMV0gKz0gTWF0aC5taW4ocmVjdEEuZ2V0WSgpIC0gcmVjdEIuZ2V0WSgpLCByZWN0Qi5nZXRCb3R0b20oKSAtIHJlY3RBLmdldEJvdHRvbSgpKTtcbiAgfVxuXG4gIC8vIGZpbmQgc2xvcGUgb2YgdGhlIGxpbmUgcGFzc2VzIHR3byBjZW50ZXJzXG4gIHZhciBzbG9wZSA9IE1hdGguYWJzKChyZWN0Qi5nZXRDZW50ZXJZKCkgLSByZWN0QS5nZXRDZW50ZXJZKCkpIC8gKHJlY3RCLmdldENlbnRlclgoKSAtIHJlY3RBLmdldENlbnRlclgoKSkpO1xuICAvLyBpZiBjZW50ZXJzIGFyZSBvdmVybGFwcGVkXG4gIGlmIChyZWN0Qi5nZXRDZW50ZXJZKCkgPT09IHJlY3RBLmdldENlbnRlclkoKSAmJiByZWN0Qi5nZXRDZW50ZXJYKCkgPT09IHJlY3RBLmdldENlbnRlclgoKSkge1xuICAgIC8vIGFzc3VtZSB0aGUgc2xvcGUgaXMgMSAoNDUgZGVncmVlKVxuICAgIHNsb3BlID0gMS4wO1xuICB9XG5cbiAgdmFyIG1vdmVCeVkgPSBzbG9wZSAqIG92ZXJsYXBBbW91bnRbMF07XG4gIHZhciBtb3ZlQnlYID0gb3ZlcmxhcEFtb3VudFsxXSAvIHNsb3BlO1xuICBpZiAob3ZlcmxhcEFtb3VudFswXSA8IG1vdmVCeVgpIHtcbiAgICBtb3ZlQnlYID0gb3ZlcmxhcEFtb3VudFswXTtcbiAgfSBlbHNlIHtcbiAgICBtb3ZlQnlZID0gb3ZlcmxhcEFtb3VudFsxXTtcbiAgfVxuICAvLyByZXR1cm4gaGFsZiB0aGUgYW1vdW50IHNvIHRoYXQgaWYgZWFjaCByZWN0YW5nbGUgaXMgbW92ZWQgYnkgdGhlc2VcbiAgLy8gYW1vdW50cyBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zLCBvdmVybGFwIHdpbGwgYmUgcmVzb2x2ZWRcbiAgb3ZlcmxhcEFtb3VudFswXSA9IC0xICogZGlyZWN0aW9uc1swXSAqIChtb3ZlQnlYIC8gMiArIHNlcGFyYXRpb25CdWZmZXIpO1xuICBvdmVybGFwQW1vdW50WzFdID0gLTEgKiBkaXJlY3Rpb25zWzFdICogKG1vdmVCeVkgLyAyICsgc2VwYXJhdGlvbkJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRlY2lkZXMgdGhlIHNlcGFyYXRpb24gZGlyZWN0aW9uIG9mIG92ZXJsYXBwaW5nIG5vZGVzXG4gKlxuICogaWYgZGlyZWN0aW9uc1swXSA9IC0xLCB0aGVuIHJlY3RBIGdvZXMgbGVmdFxuICogaWYgZGlyZWN0aW9uc1swXSA9IDEsICB0aGVuIHJlY3RBIGdvZXMgcmlnaHRcbiAqIGlmIGRpcmVjdGlvbnNbMV0gPSAtMSwgdGhlbiByZWN0QSBnb2VzIHVwXG4gKiBpZiBkaXJlY3Rpb25zWzFdID0gMSwgIHRoZW4gcmVjdEEgZ29lcyBkb3duXG4gKi9cbklHZW9tZXRyeS5kZWNpZGVEaXJlY3Rpb25zRm9yT3ZlcmxhcHBpbmdOb2RlcyA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIGRpcmVjdGlvbnMpIHtcbiAgaWYgKHJlY3RBLmdldENlbnRlclgoKSA8IHJlY3RCLmdldENlbnRlclgoKSkge1xuICAgIGRpcmVjdGlvbnNbMF0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3Rpb25zWzBdID0gMTtcbiAgfVxuXG4gIGlmIChyZWN0QS5nZXRDZW50ZXJZKCkgPCByZWN0Qi5nZXRDZW50ZXJZKCkpIHtcbiAgICBkaXJlY3Rpb25zWzFdID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0aW9uc1sxXSA9IDE7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIChjbGlwcGluZykgcG9pbnRzIG9mIHRoZSB0d29cbiAqIGlucHV0IHJlY3RhbmdsZXMgd2l0aCBsaW5lIHNlZ21lbnQgZGVmaW5lZCBieSB0aGUgY2VudGVycyBvZiB0aGVzZSB0d29cbiAqIHJlY3RhbmdsZXMuIFRoZSBjbGlwcGluZyBwb2ludHMgYXJlIHNhdmVkIGluIHRoZSBpbnB1dCBkb3VibGUgYXJyYXkgYW5kXG4gKiB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIHJlY3RhbmdsZXMgb3ZlcmxhcCBpcyByZXR1cm5lZC5cbiAqL1xuSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbjIgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCByZXN1bHQpIHtcbiAgLy9yZXN1bHRbMC0xXSB3aWxsIGNvbnRhaW4gY2xpcFBvaW50IG9mIHJlY3RBLCByZXN1bHRbMi0zXSB3aWxsIGNvbnRhaW4gY2xpcFBvaW50IG9mIHJlY3RCXG4gIHZhciBwMXggPSByZWN0QS5nZXRDZW50ZXJYKCk7XG4gIHZhciBwMXkgPSByZWN0QS5nZXRDZW50ZXJZKCk7XG4gIHZhciBwMnggPSByZWN0Qi5nZXRDZW50ZXJYKCk7XG4gIHZhciBwMnkgPSByZWN0Qi5nZXRDZW50ZXJZKCk7XG5cbiAgLy9pZiB0d28gcmVjdGFuZ2xlcyBpbnRlcnNlY3QsIHRoZW4gY2xpcHBpbmcgcG9pbnRzIGFyZSBjZW50ZXJzXG4gIGlmIChyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkge1xuICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvL3ZhcmlhYmxlcyBmb3IgcmVjdEFcbiAgdmFyIHRvcExlZnRBeCA9IHJlY3RBLmdldFgoKTtcbiAgdmFyIHRvcExlZnRBeSA9IHJlY3RBLmdldFkoKTtcbiAgdmFyIHRvcFJpZ2h0QXggPSByZWN0QS5nZXRSaWdodCgpO1xuICB2YXIgYm90dG9tTGVmdEF4ID0gcmVjdEEuZ2V0WCgpO1xuICB2YXIgYm90dG9tTGVmdEF5ID0gcmVjdEEuZ2V0Qm90dG9tKCk7XG4gIHZhciBib3R0b21SaWdodEF4ID0gcmVjdEEuZ2V0UmlnaHQoKTtcbiAgdmFyIGhhbGZXaWR0aEEgPSByZWN0QS5nZXRXaWR0aEhhbGYoKTtcbiAgdmFyIGhhbGZIZWlnaHRBID0gcmVjdEEuZ2V0SGVpZ2h0SGFsZigpO1xuICAvL3ZhcmlhYmxlcyBmb3IgcmVjdEJcbiAgdmFyIHRvcExlZnRCeCA9IHJlY3RCLmdldFgoKTtcbiAgdmFyIHRvcExlZnRCeSA9IHJlY3RCLmdldFkoKTtcbiAgdmFyIHRvcFJpZ2h0QnggPSByZWN0Qi5nZXRSaWdodCgpO1xuICB2YXIgYm90dG9tTGVmdEJ4ID0gcmVjdEIuZ2V0WCgpO1xuICB2YXIgYm90dG9tTGVmdEJ5ID0gcmVjdEIuZ2V0Qm90dG9tKCk7XG4gIHZhciBib3R0b21SaWdodEJ4ID0gcmVjdEIuZ2V0UmlnaHQoKTtcbiAgdmFyIGhhbGZXaWR0aEIgPSByZWN0Qi5nZXRXaWR0aEhhbGYoKTtcbiAgdmFyIGhhbGZIZWlnaHRCID0gcmVjdEIuZ2V0SGVpZ2h0SGFsZigpO1xuXG4gIC8vZmxhZyB3aGV0aGVyIGNsaXBwaW5nIHBvaW50cyBhcmUgZm91bmRcbiAgdmFyIGNsaXBQb2ludEFGb3VuZCA9IGZhbHNlO1xuICB2YXIgY2xpcFBvaW50QkZvdW5kID0gZmFsc2U7XG5cbiAgLy8gbGluZSBpcyB2ZXJ0aWNhbFxuICBpZiAocDF4ID09PSBwMngpIHtcbiAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChwMXkgPCBwMnkpIHtcbiAgICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9ub3QgbGluZSwgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8vIGxpbmUgaXMgaG9yaXpvbnRhbFxuICBlbHNlIGlmIChwMXkgPT09IHAyeSkge1xuICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICByZXN1bHRbMF0gPSB0b3BMZWZ0QXg7XG4gICAgICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICAgICAgcmVzdWx0WzJdID0gdG9wUmlnaHRCeDtcbiAgICAgICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHAxeCA8IHAyeCkge1xuICAgICAgICByZXN1bHRbMF0gPSB0b3BSaWdodEF4O1xuICAgICAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgICAgIHJlc3VsdFsyXSA9IHRvcExlZnRCeDtcbiAgICAgICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL25vdCB2YWxpZCBsaW5lLCByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9zbG9wZXMgb2YgcmVjdEEncyBhbmQgcmVjdEIncyBkaWFnb25hbHNcbiAgICAgIHZhciBzbG9wZUEgPSByZWN0QS5oZWlnaHQgLyByZWN0QS53aWR0aDtcbiAgICAgIHZhciBzbG9wZUIgPSByZWN0Qi5oZWlnaHQgLyByZWN0Qi53aWR0aDtcblxuICAgICAgLy9zbG9wZSBvZiBsaW5lIGJldHdlZW4gY2VudGVyIG9mIHJlY3RBIGFuZCBjZW50ZXIgb2YgcmVjdEJcbiAgICAgIHZhciBzbG9wZVByaW1lID0gKHAyeSAtIHAxeSkgLyAocDJ4IC0gcDF4KTtcbiAgICAgIHZhciBjYXJkaW5hbERpcmVjdGlvbkEgPSB2b2lkIDA7XG4gICAgICB2YXIgY2FyZGluYWxEaXJlY3Rpb25CID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEF4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEF5ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEJ4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEJ5ID0gdm9pZCAwO1xuXG4gICAgICAvL2RldGVybWluZSB3aGV0aGVyIGNsaXBwaW5nIHBvaW50IGlzIHRoZSBjb3JuZXIgb2Ygbm9kZUFcbiAgICAgIGlmICgtc2xvcGVBID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSBib3R0b21MZWZ0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gdG9wUmlnaHRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzbG9wZUEgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICAgIHJlc3VsdFswXSA9IHRvcExlZnRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSBib3R0b21SaWdodEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnQgaXMgdGhlIGNvcm5lciBvZiBub2RlQlxuICAgICAgaWYgKC1zbG9wZUIgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAyeCA+IHAxeCkge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGJvdHRvbUxlZnRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSB0b3BSaWdodEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNsb3BlQiA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDJ4ID4gcDF4KSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gdG9wTGVmdEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGJvdHRvbVJpZ2h0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9pZiBib3RoIGNsaXBwaW5nIHBvaW50cyBhcmUgY29ybmVyc1xuICAgICAgaWYgKGNsaXBQb2ludEFGb3VuZCAmJiBjbGlwUG9pbnRCRm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL2RldGVybWluZSBDYXJkaW5hbCBEaXJlY3Rpb24gb2YgcmVjdGFuZ2xlc1xuICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUEsIHNsb3BlUHJpbWUsIDQpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVCLCBzbG9wZVByaW1lLCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUEsIHNsb3BlUHJpbWUsIDMpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQiwgc2xvcGVQcmltZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUEsIHNsb3BlUHJpbWUsIDEpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQiwgc2xvcGVQcmltZSwgMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUEsIHNsb3BlUHJpbWUsIDIpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVCLCBzbG9wZVByaW1lLCA0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9jYWxjdWxhdGUgY2xpcHBpbmcgUG9pbnQgaWYgaXQgaXMgbm90IGZvdW5kIGJlZm9yZVxuICAgICAgaWYgKCFjbGlwUG9pbnRBRm91bmQpIHtcbiAgICAgICAgc3dpdGNoIChjYXJkaW5hbERpcmVjdGlvbkEpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHRvcExlZnRBeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gcDF4ICsgLWhhbGZIZWlnaHRBIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IGJvdHRvbVJpZ2h0QXg7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHAxeSArIGhhbGZXaWR0aEEgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBwMXggKyBoYWxmSGVpZ2h0QSAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBib3R0b21MZWZ0QXg7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHAxeSArIC1oYWxmV2lkdGhBICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbGlwUG9pbnRCRm91bmQpIHtcbiAgICAgICAgc3dpdGNoIChjYXJkaW5hbERpcmVjdGlvbkIpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHRvcExlZnRCeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gcDJ4ICsgLWhhbGZIZWlnaHRCIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IGJvdHRvbVJpZ2h0Qng7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHAyeSArIGhhbGZXaWR0aEIgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBwMnggKyBoYWxmSGVpZ2h0QiAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBib3R0b21MZWZ0Qng7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHAyeSArIC1oYWxmV2lkdGhCICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGluIHdoaWNoIGNhcmRpbmFsIGRpcmVjdGlvbiBkb2VzIGlucHV0IHBvaW50IHN0YXlzXG4gKiAxOiBOb3J0aFxuICogMjogRWFzdFxuICogMzogU291dGhcbiAqIDQ6IFdlc3RcbiAqL1xuSUdlb21ldHJ5LmdldENhcmRpbmFsRGlyZWN0aW9uID0gZnVuY3Rpb24gKHNsb3BlLCBzbG9wZVByaW1lLCBsaW5lKSB7XG4gIGlmIChzbG9wZSA+IHNsb3BlUHJpbWUpIHtcbiAgICByZXR1cm4gbGluZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMSArIGxpbmUgJSA0O1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIGRlZmluZWQgYnlcbiAqIHBvaW50IHBhaXJzIChzMSxzMikgYW5kIChmMSxmMikuXG4gKi9cbklHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoczEsIHMyLCBmMSwgZjIpIHtcbiAgaWYgKGYyID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnRlcnNlY3Rpb24yKHMxLCBzMiwgZjEpO1xuICB9XG5cbiAgdmFyIHgxID0gczEueDtcbiAgdmFyIHkxID0gczEueTtcbiAgdmFyIHgyID0gczIueDtcbiAgdmFyIHkyID0gczIueTtcbiAgdmFyIHgzID0gZjEueDtcbiAgdmFyIHkzID0gZjEueTtcbiAgdmFyIHg0ID0gZjIueDtcbiAgdmFyIHk0ID0gZjIueTtcbiAgdmFyIHggPSB2b2lkIDAsXG4gICAgICB5ID0gdm9pZCAwOyAvLyBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgdmFyIGExID0gdm9pZCAwLFxuICAgICAgYTIgPSB2b2lkIDAsXG4gICAgICBiMSA9IHZvaWQgMCxcbiAgICAgIGIyID0gdm9pZCAwLFxuICAgICAgYzEgPSB2b2lkIDAsXG4gICAgICBjMiA9IHZvaWQgMDsgLy8gY29lZmZpY2llbnRzIG9mIGxpbmUgZXFucy5cbiAgdmFyIGRlbm9tID0gdm9pZCAwO1xuXG4gIGExID0geTIgLSB5MTtcbiAgYjEgPSB4MSAtIHgyO1xuICBjMSA9IHgyICogeTEgLSB4MSAqIHkyOyAvLyB7IGExKnggKyBiMSp5ICsgYzEgPSAwIGlzIGxpbmUgMSB9XG5cbiAgYTIgPSB5NCAtIHkzO1xuICBiMiA9IHgzIC0geDQ7XG4gIGMyID0geDQgKiB5MyAtIHgzICogeTQ7IC8vIHsgYTIqeCArIGIyKnkgKyBjMiA9IDAgaXMgbGluZSAyIH1cblxuICBkZW5vbSA9IGExICogYjIgLSBhMiAqIGIxO1xuXG4gIGlmIChkZW5vbSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgeCA9IChiMSAqIGMyIC0gYjIgKiBjMSkgLyBkZW5vbTtcbiAgeSA9IChhMiAqIGMxIC0gYTEgKiBjMikgLyBkZW5vbTtcblxuICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBmaW5kcyBhbmQgcmV0dXJucyB0aGUgYW5nbGUgb2YgdGhlIHZlY3RvciBmcm9tIHRoZSArIHgtYXhpc1xuICogaW4gY2xvY2t3aXNlIGRpcmVjdGlvbiAoY29tcGF0aWJsZSB3LyBKYXZhIGNvb3JkaW5hdGUgc3lzdGVtISkuXG4gKi9cbklHZW9tZXRyeS5hbmdsZU9mVmVjdG9yID0gZnVuY3Rpb24gKEN4LCBDeSwgTngsIE55KSB7XG4gIHZhciBDX2FuZ2xlID0gdm9pZCAwO1xuXG4gIGlmIChDeCAhPT0gTngpIHtcbiAgICBDX2FuZ2xlID0gTWF0aC5hdGFuKChOeSAtIEN5KSAvIChOeCAtIEN4KSk7XG5cbiAgICBpZiAoTnggPCBDeCkge1xuICAgICAgQ19hbmdsZSArPSBNYXRoLlBJO1xuICAgIH0gZWxzZSBpZiAoTnkgPCBDeSkge1xuICAgICAgQ19hbmdsZSArPSB0aGlzLlRXT19QSTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnkgPCBDeSkge1xuICAgIENfYW5nbGUgPSB0aGlzLk9ORV9BTkRfSEFMRl9QSTsgLy8gMjcwIGRlZ3JlZXNcbiAgfSBlbHNlIHtcbiAgICBDX2FuZ2xlID0gdGhpcy5IQUxGX1BJOyAvLyA5MCBkZWdyZWVzXG4gIH1cblxuICByZXR1cm4gQ19hbmdsZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHR3byBsaW5lIHNlZ21lbnRzIChvbmUgd2l0aCBwb2ludFxuICogcDEgYW5kIHAyLCB0aGUgb3RoZXIgd2l0aCBwb2ludCBwMyBhbmQgcDQpIGludGVyc2VjdCBhdCBhIHBvaW50IG90aGVyXG4gKiB0aGFuIHRoZXNlIHBvaW50cy5cbiAqL1xuSUdlb21ldHJ5LmRvSW50ZXJzZWN0ID0gZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gIHZhciBhID0gcDEueDtcbiAgdmFyIGIgPSBwMS55O1xuICB2YXIgYyA9IHAyLng7XG4gIHZhciBkID0gcDIueTtcbiAgdmFyIHAgPSBwMy54O1xuICB2YXIgcSA9IHAzLnk7XG4gIHZhciByID0gcDQueDtcbiAgdmFyIHMgPSBwNC55O1xuICB2YXIgZGV0ID0gKGMgLSBhKSAqIChzIC0gcSkgLSAociAtIHApICogKGQgLSBiKTtcblxuICBpZiAoZGV0ID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBsYW1iZGEgPSAoKHMgLSBxKSAqIChyIC0gYSkgKyAocCAtIHIpICogKHMgLSBiKSkgLyBkZXQ7XG4gICAgdmFyIGdhbW1hID0gKChiIC0gZCkgKiAociAtIGEpICsgKGMgLSBhKSAqIChzIC0gYikpIC8gZGV0O1xuICAgIHJldHVybiAwIDwgbGFtYmRhICYmIGxhbWJkYSA8IDEgJiYgMCA8IGdhbW1hICYmIGdhbW1hIDwgMTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgYW5kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiBcbiAqIGEgbGluZSBzZWdtZW50IGFuZCBhIGNpcmNsZS5cbiAqL1xuSUdlb21ldHJ5LmZpbmRDaXJjbGVMaW5lSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIChFeCwgRXksIEx4LCBMeSwgQ3gsIEN5LCByKSB7XG5cbiAgLy8gRSBpcyB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIHJheSxcbiAgLy8gTCBpcyB0aGUgZW5kIHBvaW50IG9mIHRoZSByYXksXG4gIC8vIEMgaXMgdGhlIGNlbnRlciBvZiBzcGhlcmUgeW91J3JlIHRlc3RpbmcgYWdhaW5zdFxuICAvLyByIGlzIHRoZSByYWRpdXMgb2YgdGhhdCBzcGhlcmVcblxuICAvLyBDb21wdXRlOlxuICAvLyBkID0gTCAtIEUgKCBEaXJlY3Rpb24gdmVjdG9yIG9mIHJheSwgZnJvbSBzdGFydCB0byBlbmQgKVxuICAvLyBmID0gRSAtIEMgKCBWZWN0b3IgZnJvbSBjZW50ZXIgc3BoZXJlIHRvIHJheSBzdGFydCApXG5cbiAgLy8gVGhlbiB0aGUgaW50ZXJzZWN0aW9uIGlzIGZvdW5kIGJ5Li5cbiAgLy8gUCA9IEUgKyB0ICogZFxuICAvLyBUaGlzIGlzIGEgcGFyYW1ldHJpYyBlcXVhdGlvbjpcbiAgLy8gUHggPSBFeCArIHRkeFxuICAvLyBQeSA9IEV5ICsgdGR5XG5cbiAgLy8gZ2V0IGEsIGIsIGMgdmFsdWVzXG4gIHZhciBhID0gKEx4IC0gRXgpICogKEx4IC0gRXgpICsgKEx5IC0gRXkpICogKEx5IC0gRXkpO1xuICB2YXIgYiA9IDIgKiAoKEV4IC0gQ3gpICogKEx4IC0gRXgpICsgKEV5IC0gQ3kpICogKEx5IC0gRXkpKTtcbiAgdmFyIGMgPSAoRXggLSBDeCkgKiAoRXggLSBDeCkgKyAoRXkgLSBDeSkgKiAoRXkgLSBDeSkgLSByICogcjtcblxuICAvLyBnZXQgZGlzY3JpbWluYW50XG4gIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGlmIChkaXNjID49IDApIHtcbiAgICAvLyBpbnNlcnQgaW50byBxdWFkcmF0aWMgZm9ybXVsYVxuICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gKDIgKiBhKTtcbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYiAqIGIgLSA0ICogYSAqIGMpKSAvICgyICogYSk7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBudWxsO1xuICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgIC8vIHQxIGlzIHRoZSBpbnRlcnNlY3Rpb24sIGFuZCBpdCdzIGNsb3NlciB0aGFuIHQyXG4gICAgICAvLyAoc2luY2UgdDEgdXNlcyAtYiAtIGRpc2NyaW1pbmFudClcbiAgICAgIC8vIEltcGFsZSwgUG9rZVxuICAgICAgcmV0dXJuIFt0MV07XG4gICAgfVxuXG4gICAgLy8gaGVyZSB0MSBkaWRuJ3QgaW50ZXJzZWN0IHNvIHdlIGFyZSBlaXRoZXIgc3RhcnRlZFxuICAgIC8vIGluc2lkZSB0aGUgc3BoZXJlIG9yIGNvbXBsZXRlbHkgcGFzdCBpdFxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgIC8vIEV4aXRXb3VuZFxuICAgICAgcmV0dXJuIFt0Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH0gZWxzZSByZXR1cm4gbnVsbDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBDbGFzcyBDb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFNvbWUgdXNlZnVsIHByZS1jYWxjdWxhdGVkIGNvbnN0YW50c1xuICovXG5JR2VvbWV0cnkuSEFMRl9QSSA9IDAuNSAqIE1hdGguUEk7XG5JR2VvbWV0cnkuT05FX0FORF9IQUxGX1BJID0gMS41ICogTWF0aC5QSTtcbklHZW9tZXRyeS5UV09fUEkgPSAyLjAgKiBNYXRoLlBJO1xuSUdlb21ldHJ5LlRIUkVFX1BJID0gMy4wICogTWF0aC5QSTtcblxubW9kdWxlLmV4cG9ydHMgPSBJR2VvbWV0cnk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBJTWF0aCgpIHt9XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKi9cbklNYXRoLnNpZ24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuSU1hdGguZmxvb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguY2VpbCh2YWx1ZSkgOiBNYXRoLmZsb29yKHZhbHVlKTtcbn07XG5cbklNYXRoLmNlaWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguZmxvb3IodmFsdWUpIDogTWF0aC5jZWlsKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSU1hdGg7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gSW50ZWdlcigpIHt9XG5cbkludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbkludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZWdlcjtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgbm9kZUZyb20gPSBmdW5jdGlvbiBub2RlRnJvbSh2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIG5leHQ6IG51bGwsIHByZXY6IG51bGwgfTtcbn07XG5cbnZhciBhZGQgPSBmdW5jdGlvbiBhZGQocHJldiwgbm9kZSwgbmV4dCwgbGlzdCkge1xuICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgIHByZXYubmV4dCA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC5oZWFkID0gbm9kZTtcbiAgfVxuXG4gIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgbmV4dC5wcmV2ID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LnRhaWwgPSBub2RlO1xuICB9XG5cbiAgbm9kZS5wcmV2ID0gcHJldjtcbiAgbm9kZS5uZXh0ID0gbmV4dDtcblxuICBsaXN0Lmxlbmd0aCsrO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIF9yZW1vdmUgPSBmdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIGxpc3QpIHtcbiAgdmFyIHByZXYgPSBub2RlLnByZXYsXG4gICAgICBuZXh0ID0gbm9kZS5uZXh0O1xuXG5cbiAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIGxpc3QuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC50YWlsID0gcHJldjtcbiAgfVxuXG4gIG5vZGUucHJldiA9IG5vZGUubmV4dCA9IG51bGw7XG5cbiAgbGlzdC5sZW5ndGgtLTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rZWRMaXN0KHZhbHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmtlZExpc3QpO1xuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcblxuICAgIGlmICh2YWxzICE9IG51bGwpIHtcbiAgICAgIHZhbHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gX3RoaXMucHVzaCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5rZWRMaXN0LCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUodmFsLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLnByZXYsIG5vZGVGcm9tKHZhbCksIG90aGVyTm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEFmdGVyKHZhbCwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZSwgbm9kZUZyb20odmFsKSwgb3RoZXJOb2RlLm5leHQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGVCZWZvcmUobmV3Tm9kZSwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZS5wcmV2LCBuZXdOb2RlLCBvdGhlck5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZUFmdGVyKG5ld05vZGUsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUsIG5ld05vZGUsIG90aGVyTm9kZS5uZXh0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHZhbCkge1xuICAgICAgcmV0dXJuIGFkZCh0aGlzLnRhaWwsIG5vZGVGcm9tKHZhbCksIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodmFsKSB7XG4gICAgICByZXR1cm4gYWRkKG51bGwsIG5vZGVGcm9tKHZhbCksIHRoaXMuaGVhZCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUobm9kZSkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUobm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMuaGVhZCwgdGhpcykudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLmhlYWQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRfb2JqZWN0X2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9vYmplY3RfYXQoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0X29iamVjdF9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRfb2JqZWN0X2F0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4IDw9IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGkgPCBpbmRleCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRMaXN0O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXHJcbiAqVGhpcyBjbGFzcyBpcyB0aGUgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9pbnQuamF2YSBjbGFzcyBpbiBqZGtcclxuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5LCBwKSB7XG4gIHRoaXMueCA9IG51bGw7XG4gIHRoaXMueSA9IG51bGw7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiBwID09IG51bGwpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH0gZWxzZSBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMueCA9IHAueDtcbiAgICB0aGlzLnkgPSBwLnk7XG4gIH1cbn1cblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgcCkge1xuICBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMuc2V0TG9jYXRpb24ocC54LCBwLnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInICYmIHR5cGVvZiB5ID09ICdudW1iZXInICYmIHAgPT0gbnVsbCkge1xuICAgIC8vaWYgYm90aCBwYXJhbWV0ZXJzIGFyZSBpbnRlZ2VyIGp1c3QgbW92ZSAoeCx5KSBsb2NhdGlvblxuICAgIGlmIChwYXJzZUludCh4KSA9PSB4ICYmIHBhcnNlSW50KHkpID09IHkpIHtcbiAgICAgIHRoaXMubW92ZSh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0gTWF0aC5mbG9vcih4ICsgMC41KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoeSArIDAuNSk7XG4gICAgfVxuICB9XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnggKz0gZHg7XG4gIHRoaXMueSArPSBkeTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PSBcIlBvaW50XCIpIHtcbiAgICB2YXIgcHQgPSBvYmo7XG4gICAgcmV0dXJuIHRoaXMueCA9PSBwdC54ICYmIHRoaXMueSA9PSBwdC55O1xuICB9XG4gIHJldHVybiB0aGlzID09IG9iajtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCgpLmNvbnN0cnVjdG9yLm5hbWUgKyBcIlt4PVwiICsgdGhpcy54ICsgXCIseT1cIiArIHRoaXMueSArIFwiXVwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBSZWN0YW5nbGVEKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy54ID0gMDtcbiAgdGhpcy55ID0gMDtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcblxuICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxufVxuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uICh5KSB7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAoYSkge1xuICBpZiAodGhpcy5nZXRSaWdodCgpIDwgYS54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuZ2V0Qm90dG9tKCkgPCBhLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5nZXRSaWdodCgpIDwgdGhpcy54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuZ2V0Qm90dG9tKCkgPCB0aGlzLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1pblggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1heFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKSArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRDZW50ZXJZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWluWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWF4WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpICsgdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEhlaWdodEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodCAvIDI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZUQ7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBVbmlxdWVJREdlbmVyZXRvcigpIHt9XG5cblVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRCA9IDA7XG5cblVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAoVW5pcXVlSURHZW5lcmV0b3IuaXNQcmltaXRpdmUob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKG9iai51bmlxdWVJRCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9iai51bmlxdWVJRDtcbiAgfVxuICBvYmoudW5pcXVlSUQgPSBVbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcoKTtcbiAgVW5pcXVlSURHZW5lcmV0b3IubGFzdElEKys7XG4gIHJldHVybiBvYmoudW5pcXVlSUQ7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGlkID09IG51bGwpIGlkID0gVW5pcXVlSURHZW5lcmV0b3IubGFzdElEO1xuICByZXR1cm4gXCJPYmplY3QjXCIgKyBpZCArIFwiXCI7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoYXJnKTtcbiAgcmV0dXJuIGFyZyA9PSBudWxsIHx8IHR5cGUgIT0gXCJvYmplY3RcIiAmJiB0eXBlICE9IFwiZnVuY3Rpb25cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pcXVlSURHZW5lcmV0b3I7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuZnVuY3Rpb24gTGF5b3V0KGlzUmVtb3RlVXNlKSB7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvL0xheW91dCBRdWFsaXR5OiAwOmRyYWZ0LCAxOmRlZmF1bHQsIDI6cHJvb2ZcbiAgdGhpcy5sYXlvdXRRdWFsaXR5ID0gTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFk7XG4gIC8vV2hldGhlciBsYXlvdXQgc2hvdWxkIGNyZWF0ZSBiZW5kcG9pbnRzIGFzIG5lZWRlZCBvciBub3RcbiAgdGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgLy9XaGV0aGVyIGxheW91dCBzaG91bGQgYmUgaW5jcmVtZW50YWwgb3Igbm90XG4gIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgLy9XaGV0aGVyIHdlIGFuaW1hdGUgZnJvbSBiZWZvcmUgdG8gYWZ0ZXIgbGF5b3V0IG5vZGUgcG9zaXRpb25zXG4gIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAvL1doZXRoZXIgd2UgYW5pbWF0ZSB0aGUgbGF5b3V0IHByb2Nlc3Mgb3Igbm90XG4gIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gIC8vTnVtYmVyIGl0ZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgZG9uZSBiZXR3ZWVuIHR3byBzdWNjZXNzaXZlIGFuaW1hdGlvbnNcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAvKipcclxuICAgKiBXaGV0aGVyIG9yIG5vdCBsZWFmIG5vZGVzIChub24tY29tcG91bmQgbm9kZXMpIGFyZSBvZiB1bmlmb3JtIHNpemVzLiBXaGVuXHJcbiAgICogdGhleSBhcmUsIGJvdGggc3ByaW5nIGFuZCByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gdHdvIGxlYWYgbm9kZXMgY2FuIGJlXHJcbiAgICogY2FsY3VsYXRlZCB3aXRob3V0IHRoZSBleHBlbnNpdmUgY2xpcHBpbmcgcG9pbnQgY2FsY3VsYXRpb25zLCByZXN1bHRpbmdcclxuICAgKiBpbiBtYWpvciBzcGVlZC11cC5cclxuICAgKi9cbiAgdGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTO1xuICAvKipcclxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW9uIG9mIGJlbmRwb2ludHMgYnkgdXNpbmcgZHVtbXkgbm9kZXMgYW5kIGVkZ2VzLlxyXG4gICAqIE1hcHMgYW4gTEVkZ2UgdG8gaXRzIGR1bW15IGJlbmRwb2ludCBwYXRoLlxyXG4gICAqL1xuICB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMgPSBuZXcgTWFwKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLmlzU3ViTGF5b3V0ID0gZmFsc2U7XG4gIHRoaXMuaXNSZW1vdGVVc2UgPSBmYWxzZTtcblxuICBpZiAoaXNSZW1vdGVVc2UgIT0gbnVsbCkge1xuICAgIHRoaXMuaXNSZW1vdGVVc2UgPSBpc1JlbW90ZVVzZTtcbiAgfVxufVxuXG5MYXlvdXQuUkFORE9NX1NFRUQgPSAxO1xuXG5MYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXI7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3R3JhcGggPSBmdW5jdGlvbiAodkdyYXBoKSB7XG4gIHJldHVybiBuZXcgTEdyYXBoKG51bGwsIHRoaXMuZ3JhcGhNYW5hZ2VyLCB2R3JhcGgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgTE5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IExFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuY2hlY2tMYXlvdXRTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpID09IG51bGwgfHwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkubGVuZ3RoID09IDAgfHwgdGhpcy5ncmFwaE1hbmFnZXIuaW5jbHVkZXNJbnZhbGlkRWRnZSgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5ydW5MYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnRpbGluZ1ByZUxheW91dCkge1xuICAgIHRoaXMudGlsaW5nUHJlTGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmluaXRQYXJhbWV0ZXJzKCk7XG4gIHZhciBpc0xheW91dFN1Y2Nlc3NmdWxsO1xuXG4gIGlmICh0aGlzLmNoZWNrTGF5b3V0U3VjY2VzcygpKSB7XG4gICAgaXNMYXlvdXRTdWNjZXNzZnVsbCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlzTGF5b3V0U3VjY2Vzc2Z1bGwgPSB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaWYgKExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIC8vIElmIHRoaXMgaXMgYSAnZHVyaW5nJyBsYXlvdXQgYW5pbWF0aW9uLiBMYXlvdXQgaXMgbm90IGZpbmlzaGVkIHlldC4gXG4gICAgLy8gV2UgbmVlZCB0byBwZXJmb3JtIHRoZXNlIGluIGluZGV4LmpzIHdoZW4gbGF5b3V0IGlzIHJlYWxseSBmaW5pc2hlZC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNMYXlvdXRTdWNjZXNzZnVsbCkge1xuICAgIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgICAgdGhpcy5kb1Bvc3RMYXlvdXQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50aWxpbmdQb3N0TGF5b3V0KSB7XG4gICAgdGhpcy50aWxpbmdQb3N0TGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSB0cnVlO1xuXG4gIHJldHVybiBpc0xheW91dFN1Y2Nlc3NmdWxsO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGFmdGVyIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmRvUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgLy9hc3NlcnQgIWlzU3ViTGF5b3V0IDogXCJTaG91bGQgbm90IGJlIGNhbGxlZCBvbiBzdWItbGF5b3V0IVwiO1xuICAvLyBQcm9wYWdhdGUgZ2VvbWV0cmljIGNoYW5nZXMgdG8gdi1sZXZlbCBvYmplY3RzXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHRoaXMudHJhbnNmb3JtKCk7XG4gIH1cbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBnZW9tZXRyeSBvZiB0aGUgdGFyZ2V0IGdyYXBoIGFjY29yZGluZyB0b1xyXG4gKiBjYWxjdWxhdGVkIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLnVwZGF0ZTIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHVwZGF0ZSBiZW5kIHBvaW50c1xuICBpZiAodGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzRnJvbUR1bW15Tm9kZXMoKTtcblxuICAgIC8vIHJlc2V0IGFsbCBlZGdlcywgc2luY2UgdGhlIHRvcG9sb2d5IGhhcyBjaGFuZ2VkXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgLy8gcGVyZm9ybSBlZGdlLCBub2RlIGFuZCByb290IHVwZGF0ZXMgaWYgbGF5b3V0IGlzIG5vdCBjYWxsZWRcbiAgLy8gcmVtb3RlbHlcbiAgaWYgKCF0aGlzLmlzUmVtb3RlVXNlKSB7XG4gICAgLy8gdXBkYXRlIGFsbCBlZGdlc1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBhbGxFZGdlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuICAgICAgLy8gICAgICB0aGlzLnVwZGF0ZShlZGdlKTtcbiAgICB9XG5cbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgbm9kZXNcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAvLyAgICAgIHRoaXMudXBkYXRlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSByb290IGdyYXBoXG4gICAgdGhpcy51cGRhdGUodGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHRoaXMudXBkYXRlMigpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgdmFyIG5vZGUgPSBvYmo7XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICAvLyBzaW5jZSBub2RlIGlzIGNvbXBvdW5kLCByZWN1cnNpdmVseSB1cGRhdGUgY2hpbGQgbm9kZXNcbiAgICAgIHZhciBub2RlcyA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGUobm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsLWxldmVsIG5vZGUgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgbm9kZSBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG4gICAgaWYgKG5vZGUudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2Tm9kZSA9IG5vZGUudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZOb2RlLnVwZGF0ZShub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICB2YXIgZWRnZSA9IG9iajtcbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBlZGdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIGVkZ2UgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuXG4gICAgaWYgKGVkZ2UudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2RWRnZSA9IGVkZ2UudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZFZGdlLnVwZGF0ZShlZGdlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEdyYXBoKSB7XG4gICAgdmFyIGdyYXBoID0gb2JqO1xuICAgIC8vIGlmIHRoZSBsLWxldmVsIGdyYXBoIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIG9iamVjdCBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG5cbiAgICBpZiAoZ3JhcGgudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2R3JhcGggPSBncmFwaC52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdkdyYXBoLnVwZGF0ZShncmFwaCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgYWxsIGxheW91dCBwYXJhbWV0ZXJzIHRvIGRlZmF1bHQgdmFsdWVzXHJcbiAqIGRldGVybWluZWQgYXQgY29tcGlsZSB0aW1lLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgIHRoaXMubGF5b3V0UXVhbGl0eSA9IExheW91dENvbnN0YW50cy5RVUFMSVRZO1xuICAgIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAgIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgICB0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICAgIHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUztcbiAgfVxuXG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCkge1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBmYWxzZTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAobmV3TGVmdFRvcCkge1xuICBpZiAobmV3TGVmdFRvcCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRyYW5zZm9ybShuZXcgUG9pbnREKDAsIDApKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBvYmplY3QgKGZyb20gRWNsaXBzZSB0byBsYXlvdXQpLiBXaGVuIGFuXG4gICAgLy8gaW52ZXJzZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCwgd2UgZ2V0IHVwcGVyLWxlZnQgY29vcmRpbmF0ZSBvZiB0aGVcbiAgICAvLyBkcmF3aW5nIG9yIHRoZSByb290IGdyYXBoIGF0IGdpdmVuIGlucHV0IGNvb3JkaW5hdGUgKHNvbWUgbWFyZ2luc1xuICAgIC8vIGFscmVhZHkgaW5jbHVkZWQgaW4gY2FsY3VsYXRpb24gb2YgbGVmdC10b3ApLlxuXG4gICAgdmFyIHRyYW5zID0gbmV3IFRyYW5zZm9ybSgpO1xuICAgIHZhciBsZWZ0VG9wID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLnVwZGF0ZUxlZnRUb3AoKTtcblxuICAgIGlmIChsZWZ0VG9wICE9IG51bGwpIHtcbiAgICAgIHRyYW5zLnNldFdvcmxkT3JnWChuZXdMZWZ0VG9wLngpO1xuICAgICAgdHJhbnMuc2V0V29ybGRPcmdZKG5ld0xlZnRUb3AueSk7XG5cbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1gobGVmdFRvcC54KTtcbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1kobGVmdFRvcC55KTtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnRyYW5zZm9ybSh0cmFucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnBvc2l0aW9uTm9kZXNSYW5kb21seSA9IGZ1bmN0aW9uIChncmFwaCkge1xuXG4gIGlmIChncmFwaCA9PSB1bmRlZmluZWQpIHtcbiAgICAvL2Fzc2VydCAhdGhpcy5pbmNyZW1lbnRhbDtcbiAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSh0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKSk7XG4gICAgdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCkudXBkYXRlQm91bmRzKHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsTm9kZTtcbiAgICB2YXIgY2hpbGRHcmFwaDtcblxuICAgIHZhciBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNoaWxkR3JhcGggPSBsTm9kZS5nZXRDaGlsZCgpO1xuXG4gICAgICBpZiAoY2hpbGRHcmFwaCA9PSBudWxsKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRHcmFwaC5nZXROb2RlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KGNoaWxkR3JhcGgpO1xuICAgICAgICBsTm9kZS51cGRhdGVCb3VuZHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbGlzdCBvZiB0cmVlcyB3aGVyZSBlYWNoIHRyZWUgaXMgcmVwcmVzZW50ZWQgYXMgYVxyXG4gKiBsaXN0IG9mIGwtbm9kZXMuIFRoZSBtZXRob2QgcmV0dXJucyBhIGxpc3Qgb2Ygc2l6ZSAwIHdoZW46XHJcbiAqIC0gVGhlIGdyYXBoIGlzIG5vdCBmbGF0IG9yXHJcbiAqIC0gT25lIG9mIHRoZSBjb21wb25lbnQocykgb2YgdGhlIGdyYXBoIGlzIG5vdCBhIHRyZWUuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5nZXRGbGF0Rm9yZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZmxhdEZvcmVzdCA9IFtdO1xuICB2YXIgaXNGb3Jlc3QgPSB0cnVlO1xuXG4gIC8vIFF1aWNrIHJlZmVyZW5jZSBmb3IgYWxsIG5vZGVzIGluIHRoZSBncmFwaCBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aFxuICAvLyB0aGlzIGxheW91dC4gVGhlIGxpc3Qgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcblxuICAvLyBGaXJzdCBiZSBzdXJlIHRoYXQgdGhlIGdyYXBoIGlzIGZsYXRcbiAgdmFyIGlzRmxhdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhbGxOb2Rlc1tpXS5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIGlzRmxhdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiBlbXB0eSBmb3Jlc3QgaWYgdGhlIGdyYXBoIGlzIG5vdCBmbGF0LlxuICBpZiAoIWlzRmxhdCkge1xuICAgIHJldHVybiBmbGF0Rm9yZXN0O1xuICB9XG5cbiAgLy8gUnVuIEJGUyBmb3IgZWFjaCBjb21wb25lbnQgb2YgdGhlIGdyYXBoLlxuXG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdG9CZVZpc2l0ZWQgPSBbXTtcbiAgdmFyIHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gIHZhciB1blByb2Nlc3NlZE5vZGVzID0gW107XG5cbiAgdW5Qcm9jZXNzZWROb2RlcyA9IHVuUHJvY2Vzc2VkTm9kZXMuY29uY2F0KGFsbE5vZGVzKTtcblxuICAvLyBFYWNoIGl0ZXJhdGlvbiBvZiB0aGlzIGxvb3AgZmluZHMgYSBjb21wb25lbnQgb2YgdGhlIGdyYXBoIGFuZFxuICAvLyBkZWNpZGVzIHdoZXRoZXIgaXQgaXMgYSB0cmVlIG9yIG5vdC4gSWYgaXQgaXMgYSB0cmVlLCBhZGRzIGl0IHRvIHRoZVxuICAvLyBmb3Jlc3QgYW5kIGNvbnRpbnVlZCB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudC5cblxuICB3aGlsZSAodW5Qcm9jZXNzZWROb2Rlcy5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgdG9CZVZpc2l0ZWQucHVzaCh1blByb2Nlc3NlZE5vZGVzWzBdKTtcblxuICAgIC8vIFN0YXJ0IHRoZSBCRlMuIEVhY2ggaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCB2aXNpdHMgYSBub2RlIGluIGFcbiAgICAvLyBCRlMgbWFubmVyLlxuICAgIHdoaWxlICh0b0JlVmlzaXRlZC5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgICAvL3Bvb2wgb3BlcmF0aW9uXG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0b0JlVmlzaXRlZFswXTtcbiAgICAgIHRvQmVWaXNpdGVkLnNwbGljZSgwLCAxKTtcbiAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICAgIHZhciBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvckVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyBJZiBCRlMgaXMgbm90IGdyb3dpbmcgZnJvbSB0aGlzIG5laWdoYm9yLlxuICAgICAgICBpZiAocGFyZW50cy5nZXQoY3VycmVudE5vZGUpICE9IGN1cnJlbnROZWlnaGJvcikge1xuICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgcHJldmlvdXNseSB2aXNpdGVkIHRoaXMgbmVpZ2hib3IuXG4gICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgICAgICB0b0JlVmlzaXRlZC5wdXNoKGN1cnJlbnROZWlnaGJvcik7XG4gICAgICAgICAgICBwYXJlbnRzLnNldChjdXJyZW50TmVpZ2hib3IsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBwcmV2aW91c2x5IHZpc2l0ZWQgdGhpcyBuZWlnaGJvciBhbmRcbiAgICAgICAgICAvLyB0aGlzIG5laWdoYm9yIGlzIG5vdCBwYXJlbnQgb2YgY3VycmVudE5vZGUsIGdpdmVuXG4gICAgICAgICAgLy8gZ3JhcGggY29udGFpbnMgYSBjb21wb25lbnQgdGhhdCBpcyBub3QgdHJlZSwgaGVuY2VcbiAgICAgICAgICAvLyBpdCBpcyBub3QgYSBmb3Jlc3QuXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlzRm9yZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGdyYXBoIGNvbnRhaW5zIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IGEgdHJlZS4gRW1wdHlcbiAgICAvLyBwcmV2aW91c2x5IGZvdW5kIHRyZWVzLiBUaGUgbWV0aG9kIHdpbGwgZW5kLlxuICAgIGlmICghaXNGb3Jlc3QpIHtcbiAgICAgIGZsYXRGb3Jlc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gU2F2ZSBjdXJyZW50bHkgdmlzaXRlZCBub2RlcyBhcyBhIHRyZWUgaW4gb3VyIGZvcmVzdC4gUmVzZXRcbiAgICAvLyB2aXNpdGVkIGFuZCBwYXJlbnRzIGxpc3RzLiBDb250aW51ZSB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudCBvZlxuICAgIC8vIHRoZSBncmFwaCwgaWYgYW55LlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdGVtcCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmlzaXRlZCkpO1xuICAgICAgICBmbGF0Rm9yZXN0LnB1c2godGVtcCk7XG4gICAgICAgIC8vZmxhdEZvcmVzdCA9IGZsYXRGb3Jlc3QuY29uY2F0KHRlbXApO1xuICAgICAgICAvL3VuUHJvY2Vzc2VkTm9kZXMucmVtb3ZlQWxsKHZpc2l0ZWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0ZW1wW2ldO1xuICAgICAgICAgIHZhciBpbmRleCA9IHVuUHJvY2Vzc2VkTm9kZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHVuUHJvY2Vzc2VkTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbGF0Rm9yZXN0O1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgZHVtbXkgbm9kZXMgKGFuIGwtbGV2ZWwgbm9kZSB3aXRoIG1pbmltYWwgZGltZW5zaW9ucylcclxuICogZm9yIHRoZSBnaXZlbiBlZGdlIChvbmUgcGVyIGJlbmRwb2ludCkuIFRoZSBleGlzdGluZyBsLWxldmVsIHN0cnVjdHVyZVxyXG4gKiBpcyB1cGRhdGVkIGFjY29yZGluZ2x5LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgZHVtbXlOb2RlcyA9IFtdO1xuICB2YXIgcHJldiA9IGVkZ2Uuc291cmNlO1xuXG4gIHZhciBncmFwaCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcihlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZS5iZW5kcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gY3JlYXRlIG5ldyBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15Tm9kZSA9IHRoaXMubmV3Tm9kZShudWxsKTtcbiAgICBkdW1teU5vZGUuc2V0UmVjdChuZXcgUG9pbnQoMCwgMCksIG5ldyBEaW1lbnNpb24oMSwgMSkpO1xuXG4gICAgZ3JhcGguYWRkKGR1bW15Tm9kZSk7XG5cbiAgICAvLyBjcmVhdGUgbmV3IGR1bW15IGVkZ2UgYmV0d2VlbiBwcmV2IGFuZCBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5hZGQoZHVtbXlFZGdlLCBwcmV2LCBkdW1teU5vZGUpO1xuXG4gICAgZHVtbXlOb2Rlcy5hZGQoZHVtbXlOb2RlKTtcbiAgICBwcmV2ID0gZHVtbXlOb2RlO1xuICB9XG5cbiAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGR1bW15RWRnZSwgcHJldiwgZWRnZS50YXJnZXQpO1xuXG4gIHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5zZXQoZWRnZSwgZHVtbXlOb2Rlcyk7XG5cbiAgLy8gcmVtb3ZlIHJlYWwgZWRnZSBmcm9tIGdyYXBoIG1hbmFnZXIgaWYgaXQgaXMgaW50ZXItZ3JhcGhcbiAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKCkpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gIH1cbiAgLy8gZWxzZSwgcmVtb3ZlIHRoZSBlZGdlIGZyb20gdGhlIGN1cnJlbnQgZ3JhcGhcbiAgZWxzZSB7XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gIHJldHVybiBkdW1teU5vZGVzO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYmVuZHBvaW50cyBmb3IgZWRnZXMgZnJvbSB0aGUgZHVtbXkgbm9kZXNcclxuICogYXQgbC1sZXZlbC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICBlZGdlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5lZGdlVG9EdW1teU5vZGVzLmtleXMoKSkpLmNvbmNhdChlZGdlcyk7XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBlZGdlcy5sZW5ndGg7IGsrKykge1xuICAgIHZhciBsRWRnZSA9IGVkZ2VzW2tdO1xuXG4gICAgaWYgKGxFZGdlLmJlbmRwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMuZ2V0KGxFZGdlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkdW1teU5vZGUgPSBwYXRoW2ldO1xuICAgICAgICB2YXIgcCA9IG5ldyBQb2ludEQoZHVtbXlOb2RlLmdldENlbnRlclgoKSwgZHVtbXlOb2RlLmdldENlbnRlclkoKSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJlbmRwb2ludCdzIGxvY2F0aW9uIGFjY29yZGluZyB0byBkdW1teSBub2RlXG4gICAgICAgIHZhciBlYnAgPSBsRWRnZS5iZW5kcG9pbnRzLmdldChpKTtcbiAgICAgICAgZWJwLnggPSBwLng7XG4gICAgICAgIGVicC55ID0gcC55O1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZHVtbXkgbm9kZSwgZHVtbXkgZWRnZXMgaW5jaWRlbnQgd2l0aCB0aGlzXG4gICAgICAgIC8vIGR1bW15IG5vZGUgaXMgYWxzbyByZW1vdmVkICh3aXRoaW4gdGhlIHJlbW92ZSBtZXRob2QpXG4gICAgICAgIGR1bW15Tm9kZS5nZXRPd25lcigpLnJlbW92ZShkdW1teU5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhlIHJlYWwgZWRnZSB0byBncmFwaFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGxFZGdlLCBsRWRnZS5zb3VyY2UsIGxFZGdlLnRhcmdldCk7XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQudHJhbnNmb3JtID0gZnVuY3Rpb24gKHNsaWRlclZhbHVlLCBkZWZhdWx0VmFsdWUsIG1pbkRpdiwgbWF4TXVsKSB7XG4gIGlmIChtaW5EaXYgIT0gdW5kZWZpbmVkICYmIG1heE11bCAhPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoc2xpZGVyVmFsdWUgPD0gNTApIHtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IGRlZmF1bHRWYWx1ZSAvIG1pbkRpdjtcbiAgICAgIHZhbHVlIC09IChkZWZhdWx0VmFsdWUgLSBtaW5WYWx1ZSkgLyA1MCAqICg1MCAtIHNsaWRlclZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heFZhbHVlID0gZGVmYXVsdFZhbHVlICogbWF4TXVsO1xuICAgICAgdmFsdWUgKz0gKG1heFZhbHVlIC0gZGVmYXVsdFZhbHVlKSAvIDUwICogKHNsaWRlclZhbHVlIC0gNTApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSwgYjtcblxuICAgIGlmIChzbGlkZXJWYWx1ZSA8PSA1MCkge1xuICAgICAgYSA9IDkuMCAqIGRlZmF1bHRWYWx1ZSAvIDUwMC4wO1xuICAgICAgYiA9IGRlZmF1bHRWYWx1ZSAvIDEwLjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSA5LjAgKiBkZWZhdWx0VmFsdWUgLyA1MC4wO1xuICAgICAgYiA9IC04ICogZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhICogc2xpZGVyVmFsdWUgKyBiO1xuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgZmluZHMgYW5kIHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gbm9kZXMsIGFzc3VtaW5nXHJcbiAqIHRoYXQgdGhlIGdpdmVuIG5vZGVzIGZvcm0gYSB0cmVlIGluIHRoZW1zZWx2ZXMuXHJcbiAqL1xuTGF5b3V0LmZpbmRDZW50ZXJPZlRyZWUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgbGlzdCA9IGxpc3QuY29uY2F0KG5vZGVzKTtcblxuICB2YXIgcmVtb3ZlZE5vZGVzID0gW107XG4gIHZhciByZW1haW5pbmdEZWdyZWVzID0gbmV3IE1hcCgpO1xuICB2YXIgZm91bmRDZW50ZXIgPSBmYWxzZTtcbiAgdmFyIGNlbnRlck5vZGUgPSBudWxsO1xuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PSAxIHx8IGxpc3QubGVuZ3RoID09IDIpIHtcbiAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgY2VudGVyTm9kZSA9IGxpc3RbMF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGxpc3RbaV07XG4gICAgdmFyIGRlZ3JlZSA9IG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpLnNpemU7XG4gICAgcmVtYWluaW5nRGVncmVlcy5zZXQobm9kZSwgbm9kZS5nZXROZWlnaGJvcnNMaXN0KCkuc2l6ZSk7XG5cbiAgICBpZiAoZGVncmVlID09IDEpIHtcbiAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZW1wTGlzdCA9IFtdO1xuICB0ZW1wTGlzdCA9IHRlbXBMaXN0LmNvbmNhdChyZW1vdmVkTm9kZXMpO1xuXG4gIHdoaWxlICghZm91bmRDZW50ZXIpIHtcbiAgICB2YXIgdGVtcExpc3QyID0gW107XG4gICAgdGVtcExpc3QyID0gdGVtcExpc3QyLmNvbmNhdCh0ZW1wTGlzdCk7XG4gICAgdGVtcExpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBsaXN0W2ldO1xuXG4gICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2Yobm9kZSk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvdXJzID0gbm9kZS5nZXROZWlnaGJvcnNMaXN0KCk7XG5cbiAgICAgIG5laWdoYm91cnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3VyKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaW5kZXhPZihuZWlnaGJvdXIpIDwgMCkge1xuICAgICAgICAgIHZhciBvdGhlckRlZ3JlZSA9IHJlbWFpbmluZ0RlZ3JlZXMuZ2V0KG5laWdoYm91cik7XG4gICAgICAgICAgdmFyIG5ld0RlZ3JlZSA9IG90aGVyRGVncmVlIC0gMTtcblxuICAgICAgICAgIGlmIChuZXdEZWdyZWUgPT0gMSkge1xuICAgICAgICAgICAgdGVtcExpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbWFpbmluZ0RlZ3JlZXMuc2V0KG5laWdoYm91ciwgbmV3RGVncmVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzLmNvbmNhdCh0ZW1wTGlzdCk7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMSB8fCBsaXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgICBjZW50ZXJOb2RlID0gbGlzdFswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2VudGVyTm9kZTtcbn07XG5cbi8qKlxyXG4gKiBEdXJpbmcgdGhlIGNvYXJzZW5pbmcgcHJvY2VzcywgdGhpcyBsYXlvdXQgbWF5IGJlIHJlZmVyZW5jZWQgYnkgdHdvIGdyYXBoIG1hbmFnZXJzXHJcbiAqIHRoaXMgc2V0dGVyIGZ1bmN0aW9uIGdyYW50cyBhY2Nlc3MgdG8gY2hhbmdlIHRoZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBncmFwaCBtYW5hZ2VyXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5zZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoZ20pIHtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJhbmRvbVNlZWQoKSB7fVxuLy8gYWRhcHRlZCBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTkzMDM3MjVcblJhbmRvbVNlZWQuc2VlZCA9IDE7XG5SYW5kb21TZWVkLnggPSAwO1xuXG5SYW5kb21TZWVkLm5leHREb3VibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFJhbmRvbVNlZWQueCA9IE1hdGguc2luKFJhbmRvbVNlZWQuc2VlZCsrKSAqIDEwMDAwO1xuICByZXR1cm4gUmFuZG9tU2VlZC54IC0gTWF0aC5mbG9vcihSYW5kb21TZWVkLngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21TZWVkO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oeCwgeSkge1xuICB0aGlzLmx3b3JsZE9yZ1ggPSAwLjA7XG4gIHRoaXMubHdvcmxkT3JnWSA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWCA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWSA9IDAuMDtcbiAgdGhpcy5sd29ybGRFeHRYID0gMS4wO1xuICB0aGlzLmx3b3JsZEV4dFkgPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFggPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFkgPSAxLjA7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1ggPSBmdW5jdGlvbiAod294KSB7XG4gIHRoaXMubHdvcmxkT3JnWCA9IHdveDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1kgPSBmdW5jdGlvbiAod295KSB7XG4gIHRoaXMubHdvcmxkT3JnWSA9IHdveTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFggPSBmdW5jdGlvbiAod2V4KSB7XG4gIHRoaXMubHdvcmxkRXh0WCA9IHdleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFkgPSBmdW5jdGlvbiAod2V5KSB7XG4gIHRoaXMubHdvcmxkRXh0WSA9IHdleTtcbn07XG5cbi8qIERldmljZSByZWxhdGVkICovXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlT3JnWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZU9yZ1g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZU9yZ1ggPSBmdW5jdGlvbiAoZG94KSB7XG4gIHRoaXMubGRldmljZU9yZ1ggPSBkb3g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZU9yZ1kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VPcmdZID0gZnVuY3Rpb24gKGRveSkge1xuICB0aGlzLmxkZXZpY2VPcmdZID0gZG95O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlRXh0WDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlRXh0WCA9IGZ1bmN0aW9uIChkZXgpIHtcbiAgdGhpcy5sZGV2aWNlRXh0WCA9IGRleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlRXh0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZUV4dFk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZUV4dFkgPSBmdW5jdGlvbiAoZGV5KSB7XG4gIHRoaXMubGRldmljZUV4dFkgPSBkZXk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVggPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgeERldmljZSA9IDAuMDtcbiAgdmFyIHdvcmxkRXh0WCA9IHRoaXMubHdvcmxkRXh0WDtcbiAgaWYgKHdvcmxkRXh0WCAhPSAwLjApIHtcbiAgICB4RGV2aWNlID0gdGhpcy5sZGV2aWNlT3JnWCArICh4IC0gdGhpcy5sd29ybGRPcmdYKSAqIHRoaXMubGRldmljZUV4dFggLyB3b3JsZEV4dFg7XG4gIH1cblxuICByZXR1cm4geERldmljZTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5RGV2aWNlID0gMC4wO1xuICB2YXIgd29ybGRFeHRZID0gdGhpcy5sd29ybGRFeHRZO1xuICBpZiAod29ybGRFeHRZICE9IDAuMCkge1xuICAgIHlEZXZpY2UgPSB0aGlzLmxkZXZpY2VPcmdZICsgKHkgLSB0aGlzLmx3b3JsZE9yZ1kpICogdGhpcy5sZGV2aWNlRXh0WSAvIHdvcmxkRXh0WTtcbiAgfVxuXG4gIHJldHVybiB5RGV2aWNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciB4V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRYID0gdGhpcy5sZGV2aWNlRXh0WDtcbiAgaWYgKGRldmljZUV4dFggIT0gMC4wKSB7XG4gICAgeFdvcmxkID0gdGhpcy5sd29ybGRPcmdYICsgKHggLSB0aGlzLmxkZXZpY2VPcmdYKSAqIHRoaXMubHdvcmxkRXh0WCAvIGRldmljZUV4dFg7XG4gIH1cblxuICByZXR1cm4geFdvcmxkO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRZID0gdGhpcy5sZGV2aWNlRXh0WTtcbiAgaWYgKGRldmljZUV4dFkgIT0gMC4wKSB7XG4gICAgeVdvcmxkID0gdGhpcy5sd29ybGRPcmdZICsgKHkgLSB0aGlzLmxkZXZpY2VPcmdZKSAqIHRoaXMubHdvcmxkRXh0WSAvIGRldmljZUV4dFk7XG4gIH1cbiAgcmV0dXJuIHlXb3JsZDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24gKGluUG9pbnQpIHtcbiAgdmFyIG91dFBvaW50ID0gbmV3IFBvaW50RCh0aGlzLmludmVyc2VUcmFuc2Zvcm1YKGluUG9pbnQueCksIHRoaXMuaW52ZXJzZVRyYW5zZm9ybVkoaW5Qb2ludC55KSk7XG4gIHJldHVybiBvdXRQb2ludDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0KCkge1xuICBMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTjtcbiAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gIHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSA9IDMuMCAqIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMDA7XG4gIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gIHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBGRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUztcbn1cblxuRkRMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXQpIHtcbiAgRkRMYXlvdXRbcHJvcF0gPSBMYXlvdXRbcHJvcF07XG59XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycy5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMgPSAwO1xuICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9IDA7XG5cbiAgdGhpcy51c2VGUkdyaWRWYXJpYW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OO1xuXG4gIHRoaXMuZ3JpZCA9IFtdO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNJZGVhbEVkZ2VMZW5ndGhzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIG9yaWdpbmFsSWRlYWxMZW5ndGg7XG4gIHZhciBsY2FEZXB0aDtcbiAgdmFyIHNvdXJjZTtcbiAgdmFyIHRhcmdldDtcbiAgdmFyIHNpemVPZlNvdXJjZUluTGNhO1xuICB2YXIgc2l6ZU9mVGFyZ2V0SW5MY2E7XG5cbiAgdmFyIGFsbEVkZ2VzID0gdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRBbGxFZGdlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuXG4gICAgb3JpZ2luYWxJZGVhbExlbmd0aCA9IGVkZ2UuaWRlYWxMZW5ndGg7XG5cbiAgICBpZiAoZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgIHNvdXJjZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gICAgICB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBzaXplT2ZTb3VyY2VJbkxjYSA9IGVkZ2UuZ2V0U291cmNlSW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG4gICAgICBzaXplT2ZUYXJnZXRJbkxjYSA9IGVkZ2UuZ2V0VGFyZ2V0SW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG5cbiAgICAgIGlmICh0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgZWRnZS5pZGVhbExlbmd0aCArPSBzaXplT2ZTb3VyY2VJbkxjYSArIHNpemVPZlRhcmdldEluTGNhIC0gMiAqIExheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFO1xuICAgICAgfVxuXG4gICAgICBsY2FEZXB0aCA9IGVkZ2UuZ2V0TGNhKCkuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCk7XG5cbiAgICAgIGVkZ2UuaWRlYWxMZW5ndGggKz0gb3JpZ2luYWxJZGVhbExlbmd0aCAqIEZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgKiAoc291cmNlLmdldEluY2x1c2lvblRyZWVEZXB0aCgpICsgdGFyZ2V0LmdldEluY2x1c2lvblRyZWVEZXB0aCgpIC0gMiAqIGxjYURlcHRoKTtcbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHMgPSB0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoO1xuICBpZiAodGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIGlmIChzID4gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmNvb2xpbmdGYWN0b3IgKiBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SLCB0aGlzLmNvb2xpbmdGYWN0b3IgLSAocyAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgLyAoRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAqIHRoaXMuY29vbGluZ0ZhY3RvciAqICgxIC0gRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUikpO1xuICAgIH1cbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUw7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHMgPiBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IsIDEuMCAtIChzIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAvIChGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpICogKDEgLSBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IDEuMDtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciA9IHRoaXMuY29vbGluZ0ZhY3RvcjtcbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlQ7XG4gIH1cblxuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCh0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoICogNSwgdGhpcy5tYXhJdGVyYXRpb25zKTtcblxuICAvLyBSZWFzc2lnbiB0aGlzIGF0dHJpYnV0ZSBieSB1c2luZyBuZXcgY29uc3RhbnQgdmFsdWVcbiAgdGhpcy5kaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlID0gMy4wICogRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwMDtcbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZCA9IHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSAqIHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG5cbiAgdGhpcy5yZXB1bHNpb25SYW5nZSA9IHRoaXMuY2FsY1JlcHVsc2lvblJhbmdlKCk7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1NwcmluZ0ZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxFZGdlcyA9IHRoaXMuZ2V0QWxsRWRnZXMoKTtcbiAgdmFyIGVkZ2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlZGdlID0gbEVkZ2VzW2ldO1xuXG4gICAgdGhpcy5jYWxjU3ByaW5nRm9yY2UoZWRnZSwgZWRnZS5pZGVhbExlbmd0aCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ3JpZFVwZGF0ZUFsbG93ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaSwgajtcbiAgdmFyIG5vZGVBLCBub2RlQjtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHByb2Nlc3NlZE5vZGVTZXQ7XG5cbiAgaWYgKHRoaXMudXNlRlJHcmlkVmFyaWFudCkge1xuICAgIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cblxuICAgIHByb2Nlc3NlZE5vZGVTZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGVhY2ggbm9kZXMgYW5kIGl0cyBzdXJyb3VuZGluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuICAgICAgdGhpcy5jYWxjdWxhdGVSZXB1bHNpb25Gb3JjZU9mQU5vZGUobm9kZUEsIHByb2Nlc3NlZE5vZGVTZXQsIGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgICAgIHByb2Nlc3NlZE5vZGVTZXQuYWRkKG5vZGVBKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZUEgPSBsTm9kZXNbaV07XG5cbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5vZGVCID0gbE5vZGVzW2pdO1xuXG4gICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIG5vdCBtZW1iZXJzIG9mIHRoZSBzYW1lIGdyYXBoLCBza2lwLlxuICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZShub2RlQSwgbm9kZUIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlKG5vZGUpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUubW92ZU5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICB2YXIgbm9kZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5tb3ZlKCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjU3ByaW5nRm9yY2UgPSBmdW5jdGlvbiAoZWRnZSwgaWRlYWxMZW5ndGgpIHtcbiAgdmFyIHNvdXJjZU5vZGUgPSBlZGdlLmdldFNvdXJjZSgpO1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgdmFyIGxlbmd0aDtcbiAgdmFyIHNwcmluZ0ZvcmNlO1xuICB2YXIgc3ByaW5nRm9yY2VYO1xuICB2YXIgc3ByaW5nRm9yY2VZO1xuXG4gIC8vIFVwZGF0ZSBlZGdlIGxlbmd0aFxuICBpZiAodGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyAmJiBzb3VyY2VOb2RlLmdldENoaWxkKCkgPT0gbnVsbCAmJiB0YXJnZXROb2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIGVkZ2UudXBkYXRlTGVuZ3RoU2ltcGxlKCk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZS51cGRhdGVMZW5ndGgoKTtcblxuICAgIGlmIChlZGdlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxlbmd0aCA9IGVkZ2UuZ2V0TGVuZ3RoKCk7XG5cbiAgaWYgKGxlbmd0aCA9PSAwKSByZXR1cm47XG5cbiAgLy8gQ2FsY3VsYXRlIHNwcmluZyBmb3JjZXNcbiAgc3ByaW5nRm9yY2UgPSBlZGdlLmVkZ2VFbGFzdGljaXR5ICogKGxlbmd0aCAtIGlkZWFsTGVuZ3RoKTtcblxuICAvLyBQcm9qZWN0IGZvcmNlIG9udG8geCBhbmQgeSBheGVzXG4gIHNwcmluZ0ZvcmNlWCA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWCAvIGxlbmd0aCk7XG4gIHNwcmluZ0ZvcmNlWSA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWSAvIGxlbmd0aCk7XG5cbiAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSBlbmQgbm9kZXNcbiAgc291cmNlTm9kZS5zcHJpbmdGb3JjZVggKz0gc3ByaW5nRm9yY2VYO1xuICBzb3VyY2VOb2RlLnNwcmluZ0ZvcmNlWSArPSBzcHJpbmdGb3JjZVk7XG4gIHRhcmdldE5vZGUuc3ByaW5nRm9yY2VYIC09IHNwcmluZ0ZvcmNlWDtcbiAgdGFyZ2V0Tm9kZS5zcHJpbmdGb3JjZVkgLT0gc3ByaW5nRm9yY2VZO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25Gb3JjZSA9IGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgdmFyIHJlY3RBID0gbm9kZUEuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEIgPSBub2RlQi5nZXRSZWN0KCk7XG4gIHZhciBvdmVybGFwQW1vdW50ID0gbmV3IEFycmF5KDIpO1xuICB2YXIgY2xpcFBvaW50cyA9IG5ldyBBcnJheSg0KTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGRpc3RhbmNlU3F1YXJlZDtcbiAgdmFyIGRpc3RhbmNlO1xuICB2YXIgcmVwdWxzaW9uRm9yY2U7XG4gIHZhciByZXB1bHNpb25Gb3JjZVg7XG4gIHZhciByZXB1bHNpb25Gb3JjZVk7XG5cbiAgaWYgKHJlY3RBLmludGVyc2VjdHMocmVjdEIpKSAvLyB0d28gbm9kZXMgb3ZlcmxhcFxuICAgIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBzZXBhcmF0aW9uIGFtb3VudCBpbiB4IGFuZCB5IGRpcmVjdGlvbnNcbiAgICAgIElHZW9tZXRyeS5jYWxjU2VwYXJhdGlvbkFtb3VudChyZWN0QSwgcmVjdEIsIG92ZXJsYXBBbW91bnQsIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAyLjApO1xuXG4gICAgICByZXB1bHNpb25Gb3JjZVggPSAyICogb3ZlcmxhcEFtb3VudFswXTtcbiAgICAgIHJlcHVsc2lvbkZvcmNlWSA9IDIgKiBvdmVybGFwQW1vdW50WzFdO1xuXG4gICAgICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IG5vZGVBLm5vT2ZDaGlsZHJlbiAqIG5vZGVCLm5vT2ZDaGlsZHJlbiAvIChub2RlQS5ub09mQ2hpbGRyZW4gKyBub2RlQi5ub09mQ2hpbGRyZW4pO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2Rlc1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VYIC09IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWTtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWCArPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VZICs9IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVk7XG4gICAgfSBlbHNlIC8vIG5vIG92ZXJsYXBcbiAgICB7XG4gICAgICAvLyBjYWxjdWxhdGUgZGlzdGFuY2VcblxuICAgICAgaWYgKHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgJiYgbm9kZUEuZ2V0Q2hpbGQoKSA9PSBudWxsICYmIG5vZGVCLmdldENoaWxkKCkgPT0gbnVsbCkgLy8gc2ltcGx5IGJhc2UgcmVwdWxzaW9uIG9uIGRpc3RhbmNlIG9mIG5vZGUgY2VudGVyc1xuICAgICAgICB7XG4gICAgICAgICAgZGlzdGFuY2VYID0gcmVjdEIuZ2V0Q2VudGVyWCgpIC0gcmVjdEEuZ2V0Q2VudGVyWCgpO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IHJlY3RCLmdldENlbnRlclkoKSAtIHJlY3RBLmdldENlbnRlclkoKTtcbiAgICAgICAgfSBlbHNlIC8vIHVzZSBjbGlwcGluZyBwb2ludHNcbiAgICAgICAge1xuICAgICAgICAgIElHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24ocmVjdEEsIHJlY3RCLCBjbGlwUG9pbnRzKTtcblxuICAgICAgICAgIGRpc3RhbmNlWCA9IGNsaXBQb2ludHNbMl0gLSBjbGlwUG9pbnRzWzBdO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IGNsaXBQb2ludHNbM10gLSBjbGlwUG9pbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vIHJlcHVsc2lvbiByYW5nZS4gRlIgZ3JpZCB2YXJpYW50IHNob3VsZCB0YWtlIGNhcmUgb2YgdGhpcy5cbiAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpIDwgRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUKSB7XG4gICAgICAgIGRpc3RhbmNlWCA9IElNYXRoLnNpZ24oZGlzdGFuY2VYKSAqIEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVDtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWSkgPCBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QpIHtcbiAgICAgICAgZGlzdGFuY2VZID0gSU1hdGguc2lnbihkaXN0YW5jZVkpICogRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkaXN0YW5jZVNxdWFyZWQpO1xuXG4gICAgICAvLyBIZXJlIHdlIHVzZSBoYWxmIG9mIHRoZSBub2RlcycgcmVwdWxzaW9uIHZhbHVlcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgcmVwdWxzaW9uRm9yY2UgPSAobm9kZUEubm9kZVJlcHVsc2lvbiAvIDIgKyBub2RlQi5ub2RlUmVwdWxzaW9uIC8gMikgKiBub2RlQS5ub09mQ2hpbGRyZW4gKiBub2RlQi5ub09mQ2hpbGRyZW4gLyBkaXN0YW5jZVNxdWFyZWQ7XG5cbiAgICAgIC8vIFByb2plY3QgZm9yY2Ugb250byB4IGFuZCB5IGF4ZXNcbiAgICAgIHJlcHVsc2lvbkZvcmNlWCA9IHJlcHVsc2lvbkZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICByZXB1bHNpb25Gb3JjZVkgPSByZXB1bHNpb25Gb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2RlcyAgICBcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWCAtPSByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gcmVwdWxzaW9uRm9yY2VZO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VYICs9IHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWSArPSByZXB1bHNpb25Gb3JjZVk7XG4gICAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgb3duZXJHcmFwaDtcbiAgdmFyIG93bmVyQ2VudGVyWDtcbiAgdmFyIG93bmVyQ2VudGVyWTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGFic0Rpc3RhbmNlWDtcbiAgdmFyIGFic0Rpc3RhbmNlWTtcbiAgdmFyIGVzdGltYXRlZFNpemU7XG4gIG93bmVyR3JhcGggPSBub2RlLmdldE93bmVyKCk7XG5cbiAgb3duZXJDZW50ZXJYID0gKG93bmVyR3JhcGguZ2V0UmlnaHQoKSArIG93bmVyR3JhcGguZ2V0TGVmdCgpKSAvIDI7XG4gIG93bmVyQ2VudGVyWSA9IChvd25lckdyYXBoLmdldFRvcCgpICsgb3duZXJHcmFwaC5nZXRCb3R0b20oKSkgLyAyO1xuICBkaXN0YW5jZVggPSBub2RlLmdldENlbnRlclgoKSAtIG93bmVyQ2VudGVyWDtcbiAgZGlzdGFuY2VZID0gbm9kZS5nZXRDZW50ZXJZKCkgLSBvd25lckNlbnRlclk7XG4gIGFic0Rpc3RhbmNlWCA9IE1hdGguYWJzKGRpc3RhbmNlWCkgKyBub2RlLmdldFdpZHRoKCkgLyAyO1xuICBhYnNEaXN0YW5jZVkgPSBNYXRoLmFicyhkaXN0YW5jZVkpICsgbm9kZS5nZXRIZWlnaHQoKSAvIDI7XG5cbiAgaWYgKG5vZGUuZ2V0T3duZXIoKSA9PSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpIC8vIGluIHRoZSByb290IGdyYXBoXG4gICAge1xuICAgICAgZXN0aW1hdGVkU2l6ZSA9IG93bmVyR3JhcGguZ2V0RXN0aW1hdGVkU2l6ZSgpICogdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3I7XG5cbiAgICAgIGlmIChhYnNEaXN0YW5jZVggPiBlc3RpbWF0ZWRTaXplIHx8IGFic0Rpc3RhbmNlWSA+IGVzdGltYXRlZFNpemUpIHtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWCA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWDtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWSA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWTtcbiAgICAgIH1cbiAgICB9IGVsc2UgLy8gaW5zaWRlIGEgY29tcG91bmRcbiAgICB7XG4gICAgICBlc3RpbWF0ZWRTaXplID0gb3duZXJHcmFwaC5nZXRFc3RpbWF0ZWRTaXplKCkgKiB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yO1xuXG4gICAgICBpZiAoYWJzRGlzdGFuY2VYID4gZXN0aW1hdGVkU2l6ZSB8fCBhYnNEaXN0YW5jZVkgPiBlc3RpbWF0ZWRTaXplKSB7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVggPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVggKiB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50O1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VZID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VZICogdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudDtcbiAgICAgIH1cbiAgICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuaXNDb252ZXJnZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb252ZXJnZWQ7XG4gIHZhciBvc2NpbGF0aW5nID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID4gdGhpcy5tYXhJdGVyYXRpb25zIC8gMykge1xuICAgIG9zY2lsYXRpbmcgPSBNYXRoLmFicyh0aGlzLnRvdGFsRGlzcGxhY2VtZW50IC0gdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCkgPCAyO1xuICB9XG5cbiAgY29udmVyZ2VkID0gdGhpcy50b3RhbERpc3BsYWNlbWVudCA8IHRoaXMudG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG5cbiAgdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCA9IHRoaXMudG90YWxEaXNwbGFjZW1lbnQ7XG5cbiAgcmV0dXJuIGNvbnZlcmdlZCB8fCBvc2NpbGF0aW5nO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCAmJiAhdGhpcy5pc1N1YkxheW91dCkge1xuICAgIGlmICh0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9PSB0aGlzLmFuaW1hdGlvblBlcmlvZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMrKztcbiAgICB9XG4gIH1cbn07XG5cbi8vVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuICh3ZWlnaHQpIGZvciBhbGwgbm9kZXNcbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlO1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgbm9kZS5ub09mQ2hpbGRyZW4gPSBub2RlLmdldE5vT2ZDaGlsZHJlbigpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogRlItR3JpZCBWYXJpYW50IFJlcHVsc2lvbiBGb3JjZSBDYWxjdWxhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmlkID0gZnVuY3Rpb24gKGdyYXBoKSB7XG5cbiAgdmFyIHNpemVYID0gMDtcbiAgdmFyIHNpemVZID0gMDtcblxuICBzaXplWCA9IHBhcnNlSW50KE1hdGguY2VpbCgoZ3JhcGguZ2V0UmlnaHQoKSAtIGdyYXBoLmdldExlZnQoKSkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHNpemVZID0gcGFyc2VJbnQoTWF0aC5jZWlsKChncmFwaC5nZXRCb3R0b20oKSAtIGdyYXBoLmdldFRvcCgpKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcblxuICB2YXIgZ3JpZCA9IG5ldyBBcnJheShzaXplWCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWDsgaSsrKSB7XG4gICAgZ3JpZFtpXSA9IG5ldyBBcnJheShzaXplWSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVZOyBqKyspIHtcbiAgICAgIGdyaWRbaV1bal0gPSBuZXcgQXJyYXkoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3JpZDtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5hZGROb2RlVG9HcmlkID0gZnVuY3Rpb24gKHYsIGxlZnQsIHRvcCkge1xuXG4gIHZhciBzdGFydFggPSAwO1xuICB2YXIgZmluaXNoWCA9IDA7XG4gIHZhciBzdGFydFkgPSAwO1xuICB2YXIgZmluaXNoWSA9IDA7XG5cbiAgc3RhcnRYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkueCAtIGxlZnQpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkud2lkdGggKyB2LmdldFJlY3QoKS54IC0gbGVmdCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHN0YXJ0WSA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLnkgLSB0b3ApIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hZID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkuaGVpZ2h0ICsgdi5nZXRSZWN0KCkueSAtIHRvcCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0WDsgaSA8PSBmaW5pc2hYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gc3RhcnRZOyBqIDw9IGZpbmlzaFk7IGorKykge1xuICAgICAgdGhpcy5ncmlkW2ldW2pdLnB1c2godik7XG4gICAgICB2LnNldEdyaWRDb29yZGluYXRlcyhzdGFydFgsIGZpbmlzaFgsIHN0YXJ0WSwgZmluaXNoWSk7XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUudXBkYXRlR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIHZhciBub2RlQTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcblxuICB0aGlzLmdyaWQgPSB0aGlzLmNhbGNHcmlkKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSk7XG5cbiAgLy8gcHV0IGFsbCBub2RlcyB0byBwcm9wZXIgZ3JpZCBjZWxsc1xuICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZUEgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5hZGROb2RlVG9HcmlkKG5vZGVBLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0TGVmdCgpLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0VG9wKCkpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlID0gZnVuY3Rpb24gKG5vZGVBLCBwcm9jZXNzZWROb2RlU2V0LCBncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQgfHwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuICAgIHZhciBzdXJyb3VuZGluZyA9IG5ldyBTZXQoKTtcbiAgICBub2RlQS5zdXJyb3VuZGluZyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBub2RlQjtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZDtcblxuICAgIGZvciAodmFyIGkgPSBub2RlQS5zdGFydFggLSAxOyBpIDwgbm9kZUEuZmluaXNoWCArIDI7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IG5vZGVBLnN0YXJ0WSAtIDE7IGogPCBub2RlQS5maW5pc2hZICsgMjsgaisrKSB7XG4gICAgICAgIGlmICghKGkgPCAwIHx8IGogPCAwIHx8IGkgPj0gZ3JpZC5sZW5ndGggfHwgaiA+PSBncmlkWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyaWRbaV1bal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIG5vZGVCID0gZ3JpZFtpXVtqXVtrXTtcblxuICAgICAgICAgICAgLy8gSWYgYm90aCBub2RlcyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIHNhbWUgZ3JhcGgsIFxuICAgICAgICAgICAgLy8gb3IgYm90aCBub2RlcyBhcmUgdGhlIHNhbWUsIHNraXAuXG4gICAgICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpIHx8IG5vZGVBID09IG5vZGVCKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVwdWxzaW9uIGZvcmNlIGJldHdlZW5cbiAgICAgICAgICAgIC8vIG5vZGVBIGFuZCBub2RlQiBoYXMgYWxyZWFkeSBiZWVuIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkTm9kZVNldC5oYXMobm9kZUIpICYmICFzdXJyb3VuZGluZy5oYXMobm9kZUIpKSB7XG4gICAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLmFicyhub2RlQS5nZXRDZW50ZXJYKCkgLSBub2RlQi5nZXRDZW50ZXJYKCkpIC0gKG5vZGVBLmdldFdpZHRoKCkgLyAyICsgbm9kZUIuZ2V0V2lkdGgoKSAvIDIpO1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5hYnMobm9kZUEuZ2V0Q2VudGVyWSgpIC0gbm9kZUIuZ2V0Q2VudGVyWSgpKSAtIChub2RlQS5nZXRIZWlnaHQoKSAvIDIgKyBub2RlQi5nZXRIZWlnaHQoKSAvIDIpO1xuXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIG5vZGVBIGFuZCBub2RlQiBcbiAgICAgICAgICAgICAgLy8gaXMgbGVzcyB0aGVuIGNhbGN1bGF0aW9uIHJhbmdlXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZVggPD0gdGhpcy5yZXB1bHNpb25SYW5nZSAmJiBkaXN0YW5jZVkgPD0gdGhpcy5yZXB1bHNpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIC8vdGhlbiBhZGQgbm9kZUIgdG8gc3Vycm91bmRpbmcgb2Ygbm9kZUFcbiAgICAgICAgICAgICAgICBzdXJyb3VuZGluZy5hZGQobm9kZUIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZUEuc3Vycm91bmRpbmcgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHN1cnJvdW5kaW5nKSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG5vZGVBLnN1cnJvdW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2Uobm9kZUEsIG5vZGVBLnN1cnJvdW5kaW5nW2ldKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDAuMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0RWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgTEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xuXG4gIC8vIElkZWFsIGxlbmd0aCBhbmQgZWxhc3RpY2l0eSB2YWx1ZSBmb3IgdGhpcyBlZGdlXG4gIHRoaXMuaWRlYWxMZW5ndGggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICB0aGlzLmVkZ2VFbGFzdGljaXR5ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEg7XG59XG5cbkZETGF5b3V0RWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExFZGdlLnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTEVkZ2UpIHtcbiAgRkRMYXlvdXRFZGdlW3Byb3BdID0gTEVkZ2VbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXRFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBGRExheW91dE5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgLy8gYWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgaXMgaGFuZGxlZCBpbnNpZGUgTE5vZGVcbiAgTE5vZGUuY2FsbCh0aGlzLCBnbSwgbG9jLCBzaXplLCB2Tm9kZSk7XG5cbiAgLy8gUmVwdWxzaW9uIHZhbHVlIG9mIHRoaXMgbm9kZVxuICB0aGlzLm5vZGVSZXB1bHNpb24gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSDtcblxuICAvL1NwcmluZywgcmVwdWxzaW9uIGFuZCBncmF2aXRhdGlvbmFsIGZvcmNlcyBhY3Rpbmcgb24gdGhpcyBub2RlXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICAvL0Ftb3VudCBieSB3aGljaCB0aGlzIG5vZGUgaXMgdG8gYmUgbW92ZWQgaW4gdGhpcyBpdGVyYXRpb25cbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcblxuICAvL1N0YXJ0IGFuZCBmaW5pc2ggZ3JpZCBjb29yZGluYXRlcyB0aGF0IHRoaXMgbm9kZSBpcyBmYWxsZW4gaW50b1xuICB0aGlzLnN0YXJ0WCA9IDA7XG4gIHRoaXMuZmluaXNoWCA9IDA7XG4gIHRoaXMuc3RhcnRZID0gMDtcbiAgdGhpcy5maW5pc2hZID0gMDtcblxuICAvL0dlb21ldHJpYyBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gIHRoaXMuc3Vycm91bmRpbmcgPSBbXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTE5vZGUucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMTm9kZSkge1xuICBGRExheW91dE5vZGVbcHJvcF0gPSBMTm9kZVtwcm9wXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZS5zZXRHcmlkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoX3N0YXJ0WCwgX2ZpbmlzaFgsIF9zdGFydFksIF9maW5pc2hZKSB7XG4gIHRoaXMuc3RhcnRYID0gX3N0YXJ0WDtcbiAgdGhpcy5maW5pc2hYID0gX2ZpbmlzaFg7XG4gIHRoaXMuc3RhcnRZID0gX3N0YXJ0WTtcbiAgdGhpcy5maW5pc2hZID0gX2ZpbmlzaFk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Tm9kZTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBEaW1lbnNpb25EKHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgaWYgKHdpZHRoICE9PSBudWxsICYmIGhlaWdodCAhPT0gbnVsbCkge1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgfVxufVxuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbkQ7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hNYXAoKSB7XG4gIHRoaXMubWFwID0ge307XG4gIHRoaXMua2V5cyA9IFtdO1xufVxuXG5IYXNoTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICBpZiAoIXRoaXMuY29udGFpbnModGhlSWQpKSB7XG4gICAgdGhpcy5tYXBbdGhlSWRdID0gdmFsdWU7XG4gICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgfVxufTtcblxuSGFzaE1hcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFtrZXldICE9IG51bGw7XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFt0aGVJZF07XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5rZXlTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmtleXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hNYXA7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hTZXQoKSB7XG4gIHRoaXMuc2V0ID0ge307XG59XG47XG5cbkhhc2hTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKTtcbiAgaWYgKCF0aGlzLmNvbnRhaW5zKHRoZUlkKSkgdGhpcy5zZXRbdGhlSWRdID0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICBkZWxldGUgdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV07XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXQgPSB7fTtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV0gPT0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0KS5sZW5ndGg7XG59O1xuXG4vL2NvbmNhdHMgdGhpcy5zZXQgdG8gdGhlIGdpdmVuIGxpc3Rcbkhhc2hTZXQucHJvdG90eXBlLmFkZEFsbFRvID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnNldCk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxpc3QucHVzaCh0aGlzLnNldFtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNldCkubGVuZ3RoO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIHMgPSBsaXN0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgdiA9IGxpc3RbaV07XG4gICAgdGhpcy5hZGQodik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFNldDtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyBTb21lIG1hdHJpeCAoMWQgYW5kIDJkIGFycmF5KSBvcGVyYXRpb25zXG5mdW5jdGlvbiBNYXRyaXgoKSB7fVxuXG4vKipcbiAqIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICogYXJyYXkxLCBhcnJheTIgYW5kIHJlc3VsdCBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC5tdWx0TWF0ID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkyWzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICByZXN1bHRbaV1bal0gPSAwO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnJheTFbMF0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcmVzdWx0W2ldW2pdICs9IGFycmF5MVtpXVtrXSAqIGFycmF5MltrXVtqXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogbWF0cml4IHRyYW5zcG9zZVxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICByZXN1bHRbaV1bal0gPSBhcnJheVtqXVtpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBtdWx0aXBseSBhcnJheSB3aXRoIGNvbnN0YW50XG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAxZCBhcnJheXNcbiAqL1xuTWF0cml4Lm11bHRDb25zID0gZnVuY3Rpb24gKGFycmF5LCBjb25zdGFudCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGFycmF5W2ldICogY29uc3RhbnQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBzdWJzdHJhY3QgdHdvIGFycmF5c1xuICogYXJyYXkxLCBhcnJheTIgYW5kIHJlc3VsdCBhcmUgMWQgYXJyYXlzXG4gKi9cbk1hdHJpeC5taW51c09wID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGFycmF5MVtpXSAtIGFycmF5MltpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIGRvdCBwcm9kdWN0IG9mIHR3byBhcnJheXMgd2l0aCBzYW1lIHNpemVcbiAqIGFycmF5MSBhbmQgYXJyYXkyIGFyZSAxZCBhcnJheXNcbiAqL1xuTWF0cml4LmRvdFByb2R1Y3QgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIpIHtcbiAgdmFyIHByb2R1Y3QgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdCArPSBhcnJheTFbaV0gKiBhcnJheTJbaV07XG4gIH1cblxuICByZXR1cm4gcHJvZHVjdDtcbn07XG5cbi8qKlxuICogbWFnbml0dWRlIG9mIGFuIGFycmF5XG4gKiBhcnJheSBpcyAxZCBhcnJheVxuICovXG5NYXRyaXgubWFnID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5kb3RQcm9kdWN0KGFycmF5LCBhcnJheSkpO1xufTtcblxuLyoqXG4gKiBub3JtYWxpemF0aW9uIG9mIGFuIGFycmF5XG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAxZCBhcnJheVxuICovXG5NYXRyaXgubm9ybWFsaXplID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIG1hZ25pdHVkZSA9IHRoaXMubWFnKGFycmF5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gYXJyYXlbaV0gLyBtYWduaXR1ZGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBtdWx0aXBseSBhbiBhcnJheSB3aXRoIGNlbnRlcmluZyBtYXRyaXhcbiAqIGFycmF5IGFuZCByZXN1bHQgYXJlIDFkIGFycmF5XG4gKi9cbk1hdHJpeC5tdWx0R2FtbWEgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgc3VtID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtICs9IGFycmF5W2ldO1xuICB9XG5cbiAgc3VtICo9IC0xIC8gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICByZXN1bHRbX2ldID0gc3VtICsgYXJyYXlbX2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIGEgc3BlY2lhbCBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAqIHJlc3VsdCA9IDAuNSAqIEMgKiBJTlYgKiBDXlQgKiBhcnJheVxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMWQsIEMgYW5kIElOViBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC5tdWx0TCA9IGZ1bmN0aW9uIChhcnJheSwgQywgSU5WKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHRlbXAxID0gW107XG4gIHZhciB0ZW1wMiA9IFtdO1xuXG4gIC8vIG11bHRpcGx5IGJ5IENeVFxuICBmb3IgKHZhciBpID0gMDsgaSA8IENbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IEMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHN1bSArPSAtMC41ICogQ1tqXVtpXSAqIGFycmF5W2pdO1xuICAgIH1cbiAgICB0ZW1wMVtpXSA9IHN1bTtcbiAgfVxuICAvLyBtdWx0aXBseSB0aGUgcmVzdWx0IGJ5IElOVlxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBJTlYubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfc3VtID0gMDtcbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgSU5WLmxlbmd0aDsgX2orKykge1xuICAgICAgX3N1bSArPSBJTlZbX2kyXVtfal0gKiB0ZW1wMVtfal07XG4gICAgfVxuICAgIHRlbXAyW19pMl0gPSBfc3VtO1xuICB9XG4gIC8vIG11bHRpcGx5IHRoZSByZXN1bHQgYnkgQ1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBDLmxlbmd0aDsgX2kzKyspIHtcbiAgICB2YXIgX3N1bTIgPSAwO1xuICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IENbMF0ubGVuZ3RoOyBfajIrKykge1xuICAgICAgX3N1bTIgKz0gQ1tfaTNdW19qMl0gKiB0ZW1wMltfajJdO1xuICAgIH1cbiAgICByZXN1bHRbX2kzXSA9IF9zdW0yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBjbGFzc2ljIFF1aWNrc29ydCBhbGdvcml0aG0gd2l0aCBIb2FyZSdzIHBhcnRpdGlvblxuICogLSBXb3JrcyBhbHNvIG9uIExpbmtlZExpc3Qgb2JqZWN0c1xuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgUXVpY2tzb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1aWNrc29ydChBLCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrc29ydCk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmVGdW5jdGlvbiAhPT0gbnVsbCB8fCBjb21wYXJlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkgdGhpcy5jb21wYXJlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIGlmIChBIGluc3RhbmNlb2YgTGlua2VkTGlzdCkgbGVuZ3RoID0gQS5zaXplKCk7ZWxzZSBsZW5ndGggPSBBLmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgMCwgbGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFF1aWNrc29ydCwgW3tcbiAgICAgICAga2V5OiAnX3F1aWNrc29ydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcXVpY2tzb3J0KEEsIHAsIHIpIHtcbiAgICAgICAgICAgIGlmIChwIDwgcikge1xuICAgICAgICAgICAgICAgIHZhciBxID0gdGhpcy5fcGFydGl0aW9uKEEsIHAsIHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCBwLCBxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgcSArIDEsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcGFydGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJ0aXRpb24oQSwgcCwgcikge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLl9nZXQoQSwgcCk7XG4gICAgICAgICAgICB2YXIgaSA9IHA7XG4gICAgICAgICAgICB2YXIgaiA9IHI7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXBhcmVGdW5jdGlvbih4LCB0aGlzLl9nZXQoQSwgaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9d2hpbGUgKHRoaXMuY29tcGFyZUZ1bmN0aW9uKHRoaXMuX2dldChBLCBpKSwgeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1pZiAoaSA8IGopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcChBLCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHJldHVybiBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQob2JqZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExpbmtlZExpc3QpIHJldHVybiBvYmplY3QuZ2V0X29iamVjdF9hdChpbmRleCk7ZWxzZSByZXR1cm4gb2JqZWN0W2luZGV4XTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0KG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTGlua2VkTGlzdCkgb2JqZWN0LnNldF9vYmplY3RfYXQoaW5kZXgsIHZhbHVlKTtlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3N3YXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3N3YXAoQSwgaSwgaikge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLl9nZXQoQSwgaSk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoQSwgaSwgdGhpcy5fZ2V0KEEsIGopKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChBLCBqLCB0ZW1wKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgPiBhO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFF1aWNrc29ydDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWlja3NvcnQ7XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gU2luZ3VsYXIgVmFsdWUgRGVjb21wb3NpdGlvbiBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gU1ZEKCkge307XG5cbi8qIEJlbG93IHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gKHN2ZCkgY29kZSBpbmNsdWRpbmcgaHlwb3QgZnVuY3Rpb24gaXMgYWRvcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmFnb25mbHktYWkvSmFtYUpTXG4gICBTb21lIGNoYW5nZXMgYXJlIGFwcGxpZWQgdG8gbWFrZSB0aGUgY29kZSBjb21wYXRpYmxlIHdpdGggdGhlIGZjb3NlIGNvZGUgYW5kIHRvIG1ha2UgaXQgaW5kZXBlbmRlbnQgZnJvbSBKYW1hLlxuICAgSW5wdXQgbWF0cml4IGlzIGNoYW5nZWQgdG8gYSAyRCBhcnJheSBpbnN0ZWFkIG9mIEphbWEgbWF0cml4LiBNYXRyaXggZGltZW5zaW9ucyBhcmUgdGFrZW4gYWNjb3JkaW5nIHRvIDJEIGFycmF5IGluc3RlYWQgb2YgdXNpbmcgSmFtYSBmdW5jdGlvbnMuXG4gICBBbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBzaW5ndWxhciB2YWx1ZSBjb21wb25lbnRzIGlzIGNyZWF0ZWQgZm9yIHJldHVybi4gXG4gICBUaGUgdHlwZXMgb2YgaW5wdXQgcGFyYW1ldGVycyBvZiB0aGUgaHlwb3QgZnVuY3Rpb24gYXJlIHJlbW92ZWQuIFxuICAgbGV0IGlzIHVzZWQgaW5zdGVhZCBvZiB2YXIgZm9yIHRoZSB2YXJpYWJsZSBpbml0aWFsaXphdGlvbi5cbiovXG4vKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwYWNoZSBMaWNlbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0XG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvXG5cbiAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBVU0UsIFJFUFJPRFVDVElPTiwgQU5EIERJU1RSSUJVVElPTlxuXG4gICAxLiBEZWZpbml0aW9ucy5cblxuICAgICAgXCJMaWNlbnNlXCIgc2hhbGwgbWVhbiB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgZm9yIHVzZSwgcmVwcm9kdWN0aW9uLFxuICAgICAgYW5kIGRpc3RyaWJ1dGlvbiBhcyBkZWZpbmVkIGJ5IFNlY3Rpb25zIDEgdGhyb3VnaCA5IG9mIHRoaXMgZG9jdW1lbnQuXG5cbiAgICAgIFwiTGljZW5zb3JcIiBzaGFsbCBtZWFuIHRoZSBjb3B5cmlnaHQgb3duZXIgb3IgZW50aXR5IGF1dGhvcml6ZWQgYnlcbiAgICAgIHRoZSBjb3B5cmlnaHQgb3duZXIgdGhhdCBpcyBncmFudGluZyB0aGUgTGljZW5zZS5cblxuICAgICAgXCJMZWdhbCBFbnRpdHlcIiBzaGFsbCBtZWFuIHRoZSB1bmlvbiBvZiB0aGUgYWN0aW5nIGVudGl0eSBhbmQgYWxsXG4gICAgICBvdGhlciBlbnRpdGllcyB0aGF0IGNvbnRyb2wsIGFyZSBjb250cm9sbGVkIGJ5LCBvciBhcmUgdW5kZXIgY29tbW9uXG4gICAgICBjb250cm9sIHdpdGggdGhhdCBlbnRpdHkuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBkZWZpbml0aW9uLFxuICAgICAgXCJjb250cm9sXCIgbWVhbnMgKGkpIHRoZSBwb3dlciwgZGlyZWN0IG9yIGluZGlyZWN0LCB0byBjYXVzZSB0aGVcbiAgICAgIGRpcmVjdGlvbiBvciBtYW5hZ2VtZW50IG9mIHN1Y2ggZW50aXR5LCB3aGV0aGVyIGJ5IGNvbnRyYWN0IG9yXG4gICAgICBvdGhlcndpc2UsIG9yIChpaSkgb3duZXJzaGlwIG9mIGZpZnR5IHBlcmNlbnQgKDUwJSkgb3IgbW9yZSBvZiB0aGVcbiAgICAgIG91dHN0YW5kaW5nIHNoYXJlcywgb3IgKGlpaSkgYmVuZWZpY2lhbCBvd25lcnNoaXAgb2Ygc3VjaCBlbnRpdHkuXG5cbiAgICAgIFwiWW91XCIgKG9yIFwiWW91clwiKSBzaGFsbCBtZWFuIGFuIGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5XG4gICAgICBleGVyY2lzaW5nIHBlcm1pc3Npb25zIGdyYW50ZWQgYnkgdGhpcyBMaWNlbnNlLlxuXG4gICAgICBcIlNvdXJjZVwiIGZvcm0gc2hhbGwgbWVhbiB0aGUgcHJlZmVycmVkIGZvcm0gZm9yIG1ha2luZyBtb2RpZmljYXRpb25zLFxuICAgICAgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byBzb2Z0d2FyZSBzb3VyY2UgY29kZSwgZG9jdW1lbnRhdGlvblxuICAgICAgc291cmNlLCBhbmQgY29uZmlndXJhdGlvbiBmaWxlcy5cblxuICAgICAgXCJPYmplY3RcIiBmb3JtIHNoYWxsIG1lYW4gYW55IGZvcm0gcmVzdWx0aW5nIGZyb20gbWVjaGFuaWNhbFxuICAgICAgdHJhbnNmb3JtYXRpb24gb3IgdHJhbnNsYXRpb24gb2YgYSBTb3VyY2UgZm9ybSwgaW5jbHVkaW5nIGJ1dFxuICAgICAgbm90IGxpbWl0ZWQgdG8gY29tcGlsZWQgb2JqZWN0IGNvZGUsIGdlbmVyYXRlZCBkb2N1bWVudGF0aW9uLFxuICAgICAgYW5kIGNvbnZlcnNpb25zIHRvIG90aGVyIG1lZGlhIHR5cGVzLlxuXG4gICAgICBcIldvcmtcIiBzaGFsbCBtZWFuIHRoZSB3b3JrIG9mIGF1dGhvcnNoaXAsIHdoZXRoZXIgaW4gU291cmNlIG9yXG4gICAgICBPYmplY3QgZm9ybSwgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIExpY2Vuc2UsIGFzIGluZGljYXRlZCBieSBhXG4gICAgICBjb3B5cmlnaHQgbm90aWNlIHRoYXQgaXMgaW5jbHVkZWQgaW4gb3IgYXR0YWNoZWQgdG8gdGhlIHdvcmtcbiAgICAgIChhbiBleGFtcGxlIGlzIHByb3ZpZGVkIGluIHRoZSBBcHBlbmRpeCBiZWxvdykuXG5cbiAgICAgIFwiRGVyaXZhdGl2ZSBXb3Jrc1wiIHNoYWxsIG1lYW4gYW55IHdvcmssIHdoZXRoZXIgaW4gU291cmNlIG9yIE9iamVjdFxuICAgICAgZm9ybSwgdGhhdCBpcyBiYXNlZCBvbiAob3IgZGVyaXZlZCBmcm9tKSB0aGUgV29yayBhbmQgZm9yIHdoaWNoIHRoZVxuICAgICAgZWRpdG9yaWFsIHJldmlzaW9ucywgYW5ub3RhdGlvbnMsIGVsYWJvcmF0aW9ucywgb3Igb3RoZXIgbW9kaWZpY2F0aW9uc1xuICAgICAgcmVwcmVzZW50LCBhcyBhIHdob2xlLCBhbiBvcmlnaW5hbCB3b3JrIG9mIGF1dGhvcnNoaXAuIEZvciB0aGUgcHVycG9zZXNcbiAgICAgIG9mIHRoaXMgTGljZW5zZSwgRGVyaXZhdGl2ZSBXb3JrcyBzaGFsbCBub3QgaW5jbHVkZSB3b3JrcyB0aGF0IHJlbWFpblxuICAgICAgc2VwYXJhYmxlIGZyb20sIG9yIG1lcmVseSBsaW5rIChvciBiaW5kIGJ5IG5hbWUpIHRvIHRoZSBpbnRlcmZhY2VzIG9mLFxuICAgICAgdGhlIFdvcmsgYW5kIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZi5cblxuICAgICAgXCJDb250cmlidXRpb25cIiBzaGFsbCBtZWFuIGFueSB3b3JrIG9mIGF1dGhvcnNoaXAsIGluY2x1ZGluZ1xuICAgICAgdGhlIG9yaWdpbmFsIHZlcnNpb24gb2YgdGhlIFdvcmsgYW5kIGFueSBtb2RpZmljYXRpb25zIG9yIGFkZGl0aW9uc1xuICAgICAgdG8gdGhhdCBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiwgdGhhdCBpcyBpbnRlbnRpb25hbGx5XG4gICAgICBzdWJtaXR0ZWQgdG8gTGljZW5zb3IgZm9yIGluY2x1c2lvbiBpbiB0aGUgV29yayBieSB0aGUgY29weXJpZ2h0IG93bmVyXG4gICAgICBvciBieSBhbiBpbmRpdmlkdWFsIG9yIExlZ2FsIEVudGl0eSBhdXRob3JpemVkIHRvIHN1Ym1pdCBvbiBiZWhhbGYgb2ZcbiAgICAgIHRoZSBjb3B5cmlnaHQgb3duZXIuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBkZWZpbml0aW9uLCBcInN1Ym1pdHRlZFwiXG4gICAgICBtZWFucyBhbnkgZm9ybSBvZiBlbGVjdHJvbmljLCB2ZXJiYWwsIG9yIHdyaXR0ZW4gY29tbXVuaWNhdGlvbiBzZW50XG4gICAgICB0byB0aGUgTGljZW5zb3Igb3IgaXRzIHJlcHJlc2VudGF0aXZlcywgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0b1xuICAgICAgY29tbXVuaWNhdGlvbiBvbiBlbGVjdHJvbmljIG1haWxpbmcgbGlzdHMsIHNvdXJjZSBjb2RlIGNvbnRyb2wgc3lzdGVtcyxcbiAgICAgIGFuZCBpc3N1ZSB0cmFja2luZyBzeXN0ZW1zIHRoYXQgYXJlIG1hbmFnZWQgYnksIG9yIG9uIGJlaGFsZiBvZiwgdGhlXG4gICAgICBMaWNlbnNvciBmb3IgdGhlIHB1cnBvc2Ugb2YgZGlzY3Vzc2luZyBhbmQgaW1wcm92aW5nIHRoZSBXb3JrLCBidXRcbiAgICAgIGV4Y2x1ZGluZyBjb21tdW5pY2F0aW9uIHRoYXQgaXMgY29uc3BpY3VvdXNseSBtYXJrZWQgb3Igb3RoZXJ3aXNlXG4gICAgICBkZXNpZ25hdGVkIGluIHdyaXRpbmcgYnkgdGhlIGNvcHlyaWdodCBvd25lciBhcyBcIk5vdCBhIENvbnRyaWJ1dGlvbi5cIlxuXG4gICAgICBcIkNvbnRyaWJ1dG9yXCIgc2hhbGwgbWVhbiBMaWNlbnNvciBhbmQgYW55IGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5XG4gICAgICBvbiBiZWhhbGYgb2Ygd2hvbSBhIENvbnRyaWJ1dGlvbiBoYXMgYmVlbiByZWNlaXZlZCBieSBMaWNlbnNvciBhbmRcbiAgICAgIHN1YnNlcXVlbnRseSBpbmNvcnBvcmF0ZWQgd2l0aGluIHRoZSBXb3JrLlxuXG4gICAyLiBHcmFudCBvZiBDb3B5cmlnaHQgTGljZW5zZS4gU3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2ZcbiAgICAgIHRoaXMgTGljZW5zZSwgZWFjaCBDb250cmlidXRvciBoZXJlYnkgZ3JhbnRzIHRvIFlvdSBhIHBlcnBldHVhbCxcbiAgICAgIHdvcmxkd2lkZSwgbm9uLWV4Y2x1c2l2ZSwgbm8tY2hhcmdlLCByb3lhbHR5LWZyZWUsIGlycmV2b2NhYmxlXG4gICAgICBjb3B5cmlnaHQgbGljZW5zZSB0byByZXByb2R1Y2UsIHByZXBhcmUgRGVyaXZhdGl2ZSBXb3JrcyBvZixcbiAgICAgIHB1YmxpY2x5IGRpc3BsYXksIHB1YmxpY2x5IHBlcmZvcm0sIHN1YmxpY2Vuc2UsIGFuZCBkaXN0cmlidXRlIHRoZVxuICAgICAgV29yayBhbmQgc3VjaCBEZXJpdmF0aXZlIFdvcmtzIGluIFNvdXJjZSBvciBPYmplY3QgZm9ybS5cblxuICAgMy4gR3JhbnQgb2YgUGF0ZW50IExpY2Vuc2UuIFN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mXG4gICAgICB0aGlzIExpY2Vuc2UsIGVhY2ggQ29udHJpYnV0b3IgaGVyZWJ5IGdyYW50cyB0byBZb3UgYSBwZXJwZXR1YWwsXG4gICAgICB3b3JsZHdpZGUsIG5vbi1leGNsdXNpdmUsIG5vLWNoYXJnZSwgcm95YWx0eS1mcmVlLCBpcnJldm9jYWJsZVxuICAgICAgKGV4Y2VwdCBhcyBzdGF0ZWQgaW4gdGhpcyBzZWN0aW9uKSBwYXRlbnQgbGljZW5zZSB0byBtYWtlLCBoYXZlIG1hZGUsXG4gICAgICB1c2UsIG9mZmVyIHRvIHNlbGwsIHNlbGwsIGltcG9ydCwgYW5kIG90aGVyd2lzZSB0cmFuc2ZlciB0aGUgV29yayxcbiAgICAgIHdoZXJlIHN1Y2ggbGljZW5zZSBhcHBsaWVzIG9ubHkgdG8gdGhvc2UgcGF0ZW50IGNsYWltcyBsaWNlbnNhYmxlXG4gICAgICBieSBzdWNoIENvbnRyaWJ1dG9yIHRoYXQgYXJlIG5lY2Vzc2FyaWx5IGluZnJpbmdlZCBieSB0aGVpclxuICAgICAgQ29udHJpYnV0aW9uKHMpIGFsb25lIG9yIGJ5IGNvbWJpbmF0aW9uIG9mIHRoZWlyIENvbnRyaWJ1dGlvbihzKVxuICAgICAgd2l0aCB0aGUgV29yayB0byB3aGljaCBzdWNoIENvbnRyaWJ1dGlvbihzKSB3YXMgc3VibWl0dGVkLiBJZiBZb3VcbiAgICAgIGluc3RpdHV0ZSBwYXRlbnQgbGl0aWdhdGlvbiBhZ2FpbnN0IGFueSBlbnRpdHkgKGluY2x1ZGluZyBhXG4gICAgICBjcm9zcy1jbGFpbSBvciBjb3VudGVyY2xhaW0gaW4gYSBsYXdzdWl0KSBhbGxlZ2luZyB0aGF0IHRoZSBXb3JrXG4gICAgICBvciBhIENvbnRyaWJ1dGlvbiBpbmNvcnBvcmF0ZWQgd2l0aGluIHRoZSBXb3JrIGNvbnN0aXR1dGVzIGRpcmVjdFxuICAgICAgb3IgY29udHJpYnV0b3J5IHBhdGVudCBpbmZyaW5nZW1lbnQsIHRoZW4gYW55IHBhdGVudCBsaWNlbnNlc1xuICAgICAgZ3JhbnRlZCB0byBZb3UgdW5kZXIgdGhpcyBMaWNlbnNlIGZvciB0aGF0IFdvcmsgc2hhbGwgdGVybWluYXRlXG4gICAgICBhcyBvZiB0aGUgZGF0ZSBzdWNoIGxpdGlnYXRpb24gaXMgZmlsZWQuXG5cbiAgIDQuIFJlZGlzdHJpYnV0aW9uLiBZb3UgbWF5IHJlcHJvZHVjZSBhbmQgZGlzdHJpYnV0ZSBjb3BpZXMgb2YgdGhlXG4gICAgICBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiBpbiBhbnkgbWVkaXVtLCB3aXRoIG9yIHdpdGhvdXRcbiAgICAgIG1vZGlmaWNhdGlvbnMsIGFuZCBpbiBTb3VyY2Ugb3IgT2JqZWN0IGZvcm0sIHByb3ZpZGVkIHRoYXQgWW91XG4gICAgICBtZWV0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgICAgKGEpIFlvdSBtdXN0IGdpdmUgYW55IG90aGVyIHJlY2lwaWVudHMgb2YgdGhlIFdvcmsgb3JcbiAgICAgICAgICBEZXJpdmF0aXZlIFdvcmtzIGEgY29weSBvZiB0aGlzIExpY2Vuc2U7IGFuZFxuXG4gICAgICAoYikgWW91IG11c3QgY2F1c2UgYW55IG1vZGlmaWVkIGZpbGVzIHRvIGNhcnJ5IHByb21pbmVudCBub3RpY2VzXG4gICAgICAgICAgc3RhdGluZyB0aGF0IFlvdSBjaGFuZ2VkIHRoZSBmaWxlczsgYW5kXG5cbiAgICAgIChjKSBZb3UgbXVzdCByZXRhaW4sIGluIHRoZSBTb3VyY2UgZm9ybSBvZiBhbnkgRGVyaXZhdGl2ZSBXb3Jrc1xuICAgICAgICAgIHRoYXQgWW91IGRpc3RyaWJ1dGUsIGFsbCBjb3B5cmlnaHQsIHBhdGVudCwgdHJhZGVtYXJrLCBhbmRcbiAgICAgICAgICBhdHRyaWJ1dGlvbiBub3RpY2VzIGZyb20gdGhlIFNvdXJjZSBmb3JtIG9mIHRoZSBXb3JrLFxuICAgICAgICAgIGV4Y2x1ZGluZyB0aG9zZSBub3RpY2VzIHRoYXQgZG8gbm90IHBlcnRhaW4gdG8gYW55IHBhcnQgb2ZcbiAgICAgICAgICB0aGUgRGVyaXZhdGl2ZSBXb3JrczsgYW5kXG5cbiAgICAgIChkKSBJZiB0aGUgV29yayBpbmNsdWRlcyBhIFwiTk9USUNFXCIgdGV4dCBmaWxlIGFzIHBhcnQgb2YgaXRzXG4gICAgICAgICAgZGlzdHJpYnV0aW9uLCB0aGVuIGFueSBEZXJpdmF0aXZlIFdvcmtzIHRoYXQgWW91IGRpc3RyaWJ1dGUgbXVzdFxuICAgICAgICAgIGluY2x1ZGUgYSByZWFkYWJsZSBjb3B5IG9mIHRoZSBhdHRyaWJ1dGlvbiBub3RpY2VzIGNvbnRhaW5lZFxuICAgICAgICAgIHdpdGhpbiBzdWNoIE5PVElDRSBmaWxlLCBleGNsdWRpbmcgdGhvc2Ugbm90aWNlcyB0aGF0IGRvIG5vdFxuICAgICAgICAgIHBlcnRhaW4gdG8gYW55IHBhcnQgb2YgdGhlIERlcml2YXRpdmUgV29ya3MsIGluIGF0IGxlYXN0IG9uZVxuICAgICAgICAgIG9mIHRoZSBmb2xsb3dpbmcgcGxhY2VzOiB3aXRoaW4gYSBOT1RJQ0UgdGV4dCBmaWxlIGRpc3RyaWJ1dGVkXG4gICAgICAgICAgYXMgcGFydCBvZiB0aGUgRGVyaXZhdGl2ZSBXb3Jrczsgd2l0aGluIHRoZSBTb3VyY2UgZm9ybSBvclxuICAgICAgICAgIGRvY3VtZW50YXRpb24sIGlmIHByb3ZpZGVkIGFsb25nIHdpdGggdGhlIERlcml2YXRpdmUgV29ya3M7IG9yLFxuICAgICAgICAgIHdpdGhpbiBhIGRpc3BsYXkgZ2VuZXJhdGVkIGJ5IHRoZSBEZXJpdmF0aXZlIFdvcmtzLCBpZiBhbmRcbiAgICAgICAgICB3aGVyZXZlciBzdWNoIHRoaXJkLXBhcnR5IG5vdGljZXMgbm9ybWFsbHkgYXBwZWFyLiBUaGUgY29udGVudHNcbiAgICAgICAgICBvZiB0aGUgTk9USUNFIGZpbGUgYXJlIGZvciBpbmZvcm1hdGlvbmFsIHB1cnBvc2VzIG9ubHkgYW5kXG4gICAgICAgICAgZG8gbm90IG1vZGlmeSB0aGUgTGljZW5zZS4gWW91IG1heSBhZGQgWW91ciBvd24gYXR0cmlidXRpb25cbiAgICAgICAgICBub3RpY2VzIHdpdGhpbiBEZXJpdmF0aXZlIFdvcmtzIHRoYXQgWW91IGRpc3RyaWJ1dGUsIGFsb25nc2lkZVxuICAgICAgICAgIG9yIGFzIGFuIGFkZGVuZHVtIHRvIHRoZSBOT1RJQ0UgdGV4dCBmcm9tIHRoZSBXb3JrLCBwcm92aWRlZFxuICAgICAgICAgIHRoYXQgc3VjaCBhZGRpdGlvbmFsIGF0dHJpYnV0aW9uIG5vdGljZXMgY2Fubm90IGJlIGNvbnN0cnVlZFxuICAgICAgICAgIGFzIG1vZGlmeWluZyB0aGUgTGljZW5zZS5cblxuICAgICAgWW91IG1heSBhZGQgWW91ciBvd24gY29weXJpZ2h0IHN0YXRlbWVudCB0byBZb3VyIG1vZGlmaWNhdGlvbnMgYW5kXG4gICAgICBtYXkgcHJvdmlkZSBhZGRpdGlvbmFsIG9yIGRpZmZlcmVudCBsaWNlbnNlIHRlcm1zIGFuZCBjb25kaXRpb25zXG4gICAgICBmb3IgdXNlLCByZXByb2R1Y3Rpb24sIG9yIGRpc3RyaWJ1dGlvbiBvZiBZb3VyIG1vZGlmaWNhdGlvbnMsIG9yXG4gICAgICBmb3IgYW55IHN1Y2ggRGVyaXZhdGl2ZSBXb3JrcyBhcyBhIHdob2xlLCBwcm92aWRlZCBZb3VyIHVzZSxcbiAgICAgIHJlcHJvZHVjdGlvbiwgYW5kIGRpc3RyaWJ1dGlvbiBvZiB0aGUgV29yayBvdGhlcndpc2UgY29tcGxpZXMgd2l0aFxuICAgICAgdGhlIGNvbmRpdGlvbnMgc3RhdGVkIGluIHRoaXMgTGljZW5zZS5cblxuICAgNS4gU3VibWlzc2lvbiBvZiBDb250cmlidXRpb25zLiBVbmxlc3MgWW91IGV4cGxpY2l0bHkgc3RhdGUgb3RoZXJ3aXNlLFxuICAgICAgYW55IENvbnRyaWJ1dGlvbiBpbnRlbnRpb25hbGx5IHN1Ym1pdHRlZCBmb3IgaW5jbHVzaW9uIGluIHRoZSBXb3JrXG4gICAgICBieSBZb3UgdG8gdGhlIExpY2Vuc29yIHNoYWxsIGJlIHVuZGVyIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxuICAgICAgdGhpcyBMaWNlbnNlLCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIHRlcm1zIG9yIGNvbmRpdGlvbnMuXG4gICAgICBOb3R3aXRoc3RhbmRpbmcgdGhlIGFib3ZlLCBub3RoaW5nIGhlcmVpbiBzaGFsbCBzdXBlcnNlZGUgb3IgbW9kaWZ5XG4gICAgICB0aGUgdGVybXMgb2YgYW55IHNlcGFyYXRlIGxpY2Vuc2UgYWdyZWVtZW50IHlvdSBtYXkgaGF2ZSBleGVjdXRlZFxuICAgICAgd2l0aCBMaWNlbnNvciByZWdhcmRpbmcgc3VjaCBDb250cmlidXRpb25zLlxuXG4gICA2LiBUcmFkZW1hcmtzLiBUaGlzIExpY2Vuc2UgZG9lcyBub3QgZ3JhbnQgcGVybWlzc2lvbiB0byB1c2UgdGhlIHRyYWRlXG4gICAgICBuYW1lcywgdHJhZGVtYXJrcywgc2VydmljZSBtYXJrcywgb3IgcHJvZHVjdCBuYW1lcyBvZiB0aGUgTGljZW5zb3IsXG4gICAgICBleGNlcHQgYXMgcmVxdWlyZWQgZm9yIHJlYXNvbmFibGUgYW5kIGN1c3RvbWFyeSB1c2UgaW4gZGVzY3JpYmluZyB0aGVcbiAgICAgIG9yaWdpbiBvZiB0aGUgV29yayBhbmQgcmVwcm9kdWNpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIE5PVElDRSBmaWxlLlxuXG4gICA3LiBEaXNjbGFpbWVyIG9mIFdhcnJhbnR5LiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3JcbiAgICAgIGFncmVlZCB0byBpbiB3cml0aW5nLCBMaWNlbnNvciBwcm92aWRlcyB0aGUgV29yayAoYW5kIGVhY2hcbiAgICAgIENvbnRyaWJ1dG9yIHByb3ZpZGVzIGl0cyBDb250cmlidXRpb25zKSBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3JcbiAgICAgIGltcGxpZWQsIGluY2x1ZGluZywgd2l0aG91dCBsaW1pdGF0aW9uLCBhbnkgd2FycmFudGllcyBvciBjb25kaXRpb25zXG4gICAgICBvZiBUSVRMRSwgTk9OLUlORlJJTkdFTUVOVCwgTUVSQ0hBTlRBQklMSVRZLCBvciBGSVRORVNTIEZPUiBBXG4gICAgICBQQVJUSUNVTEFSIFBVUlBPU0UuIFlvdSBhcmUgc29sZWx5IHJlc3BvbnNpYmxlIGZvciBkZXRlcm1pbmluZyB0aGVcbiAgICAgIGFwcHJvcHJpYXRlbmVzcyBvZiB1c2luZyBvciByZWRpc3RyaWJ1dGluZyB0aGUgV29yayBhbmQgYXNzdW1lIGFueVxuICAgICAgcmlza3MgYXNzb2NpYXRlZCB3aXRoIFlvdXIgZXhlcmNpc2Ugb2YgcGVybWlzc2lvbnMgdW5kZXIgdGhpcyBMaWNlbnNlLlxuXG4gICA4LiBMaW1pdGF0aW9uIG9mIExpYWJpbGl0eS4gSW4gbm8gZXZlbnQgYW5kIHVuZGVyIG5vIGxlZ2FsIHRoZW9yeSxcbiAgICAgIHdoZXRoZXIgaW4gdG9ydCAoaW5jbHVkaW5nIG5lZ2xpZ2VuY2UpLCBjb250cmFjdCwgb3Igb3RoZXJ3aXNlLFxuICAgICAgdW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IChzdWNoIGFzIGRlbGliZXJhdGUgYW5kIGdyb3NzbHlcbiAgICAgIG5lZ2xpZ2VudCBhY3RzKSBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc2hhbGwgYW55IENvbnRyaWJ1dG9yIGJlXG4gICAgICBsaWFibGUgdG8gWW91IGZvciBkYW1hZ2VzLCBpbmNsdWRpbmcgYW55IGRpcmVjdCwgaW5kaXJlY3QsIHNwZWNpYWwsXG4gICAgICBpbmNpZGVudGFsLCBvciBjb25zZXF1ZW50aWFsIGRhbWFnZXMgb2YgYW55IGNoYXJhY3RlciBhcmlzaW5nIGFzIGFcbiAgICAgIHJlc3VsdCBvZiB0aGlzIExpY2Vuc2Ugb3Igb3V0IG9mIHRoZSB1c2Ugb3IgaW5hYmlsaXR5IHRvIHVzZSB0aGVcbiAgICAgIFdvcmsgKGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gZGFtYWdlcyBmb3IgbG9zcyBvZiBnb29kd2lsbCxcbiAgICAgIHdvcmsgc3RvcHBhZ2UsIGNvbXB1dGVyIGZhaWx1cmUgb3IgbWFsZnVuY3Rpb24sIG9yIGFueSBhbmQgYWxsXG4gICAgICBvdGhlciBjb21tZXJjaWFsIGRhbWFnZXMgb3IgbG9zc2VzKSwgZXZlbiBpZiBzdWNoIENvbnRyaWJ1dG9yXG4gICAgICBoYXMgYmVlbiBhZHZpc2VkIG9mIHRoZSBwb3NzaWJpbGl0eSBvZiBzdWNoIGRhbWFnZXMuXG5cbiAgIDkuIEFjY2VwdGluZyBXYXJyYW50eSBvciBBZGRpdGlvbmFsIExpYWJpbGl0eS4gV2hpbGUgcmVkaXN0cmlidXRpbmdcbiAgICAgIHRoZSBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiwgWW91IG1heSBjaG9vc2UgdG8gb2ZmZXIsXG4gICAgICBhbmQgY2hhcmdlIGEgZmVlIGZvciwgYWNjZXB0YW5jZSBvZiBzdXBwb3J0LCB3YXJyYW50eSwgaW5kZW1uaXR5LFxuICAgICAgb3Igb3RoZXIgbGlhYmlsaXR5IG9ibGlnYXRpb25zIGFuZC9vciByaWdodHMgY29uc2lzdGVudCB3aXRoIHRoaXNcbiAgICAgIExpY2Vuc2UuIEhvd2V2ZXIsIGluIGFjY2VwdGluZyBzdWNoIG9ibGlnYXRpb25zLCBZb3UgbWF5IGFjdCBvbmx5XG4gICAgICBvbiBZb3VyIG93biBiZWhhbGYgYW5kIG9uIFlvdXIgc29sZSByZXNwb25zaWJpbGl0eSwgbm90IG9uIGJlaGFsZlxuICAgICAgb2YgYW55IG90aGVyIENvbnRyaWJ1dG9yLCBhbmQgb25seSBpZiBZb3UgYWdyZWUgdG8gaW5kZW1uaWZ5LFxuICAgICAgZGVmZW5kLCBhbmQgaG9sZCBlYWNoIENvbnRyaWJ1dG9yIGhhcm1sZXNzIGZvciBhbnkgbGlhYmlsaXR5XG4gICAgICBpbmN1cnJlZCBieSwgb3IgY2xhaW1zIGFzc2VydGVkIGFnYWluc3QsIHN1Y2ggQ29udHJpYnV0b3IgYnkgcmVhc29uXG4gICAgICBvZiB5b3VyIGFjY2VwdGluZyBhbnkgc3VjaCB3YXJyYW50eSBvciBhZGRpdGlvbmFsIGxpYWJpbGl0eS5cblxuICAgRU5EIE9GIFRFUk1TIEFORCBDT05ESVRJT05TXG5cbiAgIEFQUEVORElYOiBIb3cgdG8gYXBwbHkgdGhlIEFwYWNoZSBMaWNlbnNlIHRvIHlvdXIgd29yay5cblxuICAgICAgVG8gYXBwbHkgdGhlIEFwYWNoZSBMaWNlbnNlIHRvIHlvdXIgd29yaywgYXR0YWNoIHRoZSBmb2xsb3dpbmdcbiAgICAgIGJvaWxlcnBsYXRlIG5vdGljZSwgd2l0aCB0aGUgZmllbGRzIGVuY2xvc2VkIGJ5IGJyYWNrZXRzIFwie31cIlxuICAgICAgcmVwbGFjZWQgd2l0aCB5b3VyIG93biBpZGVudGlmeWluZyBpbmZvcm1hdGlvbi4gKERvbid0IGluY2x1ZGVcbiAgICAgIHRoZSBicmFja2V0cyEpICBUaGUgdGV4dCBzaG91bGQgYmUgZW5jbG9zZWQgaW4gdGhlIGFwcHJvcHJpYXRlXG4gICAgICBjb21tZW50IHN5bnRheCBmb3IgdGhlIGZpbGUgZm9ybWF0LiBXZSBhbHNvIHJlY29tbWVuZCB0aGF0IGFcbiAgICAgIGZpbGUgb3IgY2xhc3MgbmFtZSBhbmQgZGVzY3JpcHRpb24gb2YgcHVycG9zZSBiZSBpbmNsdWRlZCBvbiB0aGVcbiAgICAgIHNhbWUgXCJwcmludGVkIHBhZ2VcIiBhcyB0aGUgY29weXJpZ2h0IG5vdGljZSBmb3IgZWFzaWVyXG4gICAgICBpZGVudGlmaWNhdGlvbiB3aXRoaW4gdGhpcmQtcGFydHkgYXJjaGl2ZXMuXG5cbiAgIENvcHlyaWdodCB7eXl5eX0ge25hbWUgb2YgY29weXJpZ2h0IG93bmVyfVxuXG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblNWRC5zdmQgPSBmdW5jdGlvbiAoQSkge1xuICB0aGlzLlUgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuICB0aGlzLnMgPSBudWxsO1xuICB0aGlzLm0gPSAwO1xuICB0aGlzLm4gPSAwO1xuICB0aGlzLm0gPSBBLmxlbmd0aDtcbiAgdGhpcy5uID0gQVswXS5sZW5ndGg7XG4gIHZhciBudSA9IE1hdGgubWluKHRoaXMubSwgdGhpcy5uKTtcbiAgdGhpcy5zID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KE1hdGgubWluKHRoaXMubSArIDEsIHRoaXMubikpO1xuICB0aGlzLlUgPSBmdW5jdGlvbiAoZGltcykge1xuICAgIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlKGRpbXMpIHtcbiAgICAgIGlmIChkaW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltc1swXTsgaSsrKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChhbGxvY2F0ZShkaW1zLnNsaWNlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFsbG9jYXRlKGRpbXMpO1xuICB9KFt0aGlzLm0sIG51XSk7XG4gIHRoaXMuViA9IGZ1bmN0aW9uIChkaW1zKSB7XG4gICAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUoZGltcykge1xuICAgICAgaWYgKGRpbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1zWzBdOyBpKyspIHtcbiAgICAgICAgICBhcnJheS5wdXNoKGFsbG9jYXRlKGRpbXMuc2xpY2UoMSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYWxsb2NhdGUoZGltcyk7XG4gIH0oW3RoaXMubiwgdGhpcy5uXSk7XG4gIHZhciBlID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KHRoaXMubik7XG4gIHZhciB3b3JrID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KHRoaXMubSk7XG4gIHZhciB3YW50dSA9IHRydWU7XG4gIHZhciB3YW50diA9IHRydWU7XG4gIHZhciBuY3QgPSBNYXRoLm1pbih0aGlzLm0gLSAxLCB0aGlzLm4pO1xuICB2YXIgbnJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5uIC0gMiwgdGhpcy5tKSk7XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgTWF0aC5tYXgobmN0LCBucnQpOyBrKyspIHtcbiAgICBpZiAoayA8IG5jdCkge1xuICAgICAgdGhpcy5zW2tdID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSBrOyBpIDwgdGhpcy5tOyBpKyspIHtcbiAgICAgICAgdGhpcy5zW2tdID0gU1ZELmh5cG90KHRoaXMuc1trXSwgQVtpXVtrXSk7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBpZiAodGhpcy5zW2tdICE9PSAwLjApIHtcbiAgICAgICAgaWYgKEFba11ba10gPCAwLjApIHtcbiAgICAgICAgICB0aGlzLnNba10gPSAtdGhpcy5zW2tdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gazsgX2kgPCB0aGlzLm07IF9pKyspIHtcbiAgICAgICAgICBBW19pXVtrXSAvPSB0aGlzLnNba107XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBBW2tdW2tdICs9IDEuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc1trXSA9IC10aGlzLnNba107XG4gICAgfVxuICAgIGZvciAodmFyIGogPSBrICsgMTsgaiA8IHRoaXMubjsgaisrKSB7XG4gICAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiBsaHMgJiYgcmhzO1xuICAgICAgfShrIDwgbmN0LCB0aGlzLnNba10gIT09IDAuMCkpIHtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSBrOyBfaTIgPCB0aGlzLm07IF9pMisrKSB7XG4gICAgICAgICAgdCArPSBBW19pMl1ba10gKiBBW19pMl1bal07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB0ID0gLXQgLyBBW2tdW2tdO1xuICAgICAgICBmb3IgKHZhciBfaTMgPSBrOyBfaTMgPCB0aGlzLm07IF9pMysrKSB7XG4gICAgICAgICAgQVtfaTNdW2pdICs9IHQgKiBBW19pM11ba107XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgfVxuICAgICAgZVtqXSA9IEFba11bal07XG4gICAgfVxuICAgIDtcbiAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICByZXR1cm4gbGhzICYmIHJocztcbiAgICB9KHdhbnR1LCBrIDwgbmN0KSkge1xuICAgICAgZm9yICh2YXIgX2k0ID0gazsgX2k0IDwgdGhpcy5tOyBfaTQrKykge1xuICAgICAgICB0aGlzLlVbX2k0XVtrXSA9IEFbX2k0XVtrXTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICB9XG4gICAgaWYgKGsgPCBucnQpIHtcbiAgICAgIGVba10gPSAwO1xuICAgICAgZm9yICh2YXIgX2k1ID0gayArIDE7IF9pNSA8IHRoaXMubjsgX2k1KyspIHtcbiAgICAgICAgZVtrXSA9IFNWRC5oeXBvdChlW2tdLCBlW19pNV0pO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgaWYgKGVba10gIT09IDAuMCkge1xuICAgICAgICBpZiAoZVtrICsgMV0gPCAwLjApIHtcbiAgICAgICAgICBlW2tdID0gLWVba107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2k2ID0gayArIDE7IF9pNiA8IHRoaXMubjsgX2k2KyspIHtcbiAgICAgICAgICBlW19pNl0gLz0gZVtrXTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGVbayArIDFdICs9IDEuMDtcbiAgICAgIH1cbiAgICAgIGVba10gPSAtZVtrXTtcbiAgICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIGxocyAmJiByaHM7XG4gICAgICB9KGsgKyAxIDwgdGhpcy5tLCBlW2tdICE9PSAwLjApKSB7XG4gICAgICAgIGZvciAodmFyIF9pNyA9IGsgKyAxOyBfaTcgPCB0aGlzLm07IF9pNysrKSB7XG4gICAgICAgICAgd29ya1tfaTddID0gMC4wO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZm9yICh2YXIgX2ogPSBrICsgMTsgX2ogPCB0aGlzLm47IF9qKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTggPSBrICsgMTsgX2k4IDwgdGhpcy5tOyBfaTgrKykge1xuICAgICAgICAgICAgd29ya1tfaThdICs9IGVbX2pdICogQVtfaThdW19qXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gayArIDE7IF9qMiA8IHRoaXMubjsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX3QgPSAtZVtfajJdIC8gZVtrICsgMV07XG4gICAgICAgICAgZm9yICh2YXIgX2k5ID0gayArIDE7IF9pOSA8IHRoaXMubTsgX2k5KyspIHtcbiAgICAgICAgICAgIEFbX2k5XVtfajJdICs9IF90ICogd29ya1tfaTldO1xuICAgICAgICAgIH1cbiAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgfVxuICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgIGZvciAodmFyIF9pMTAgPSBrICsgMTsgX2kxMCA8IHRoaXMubjsgX2kxMCsrKSB7XG4gICAgICAgICAgdGhpcy5WW19pMTBdW2tdID0gZVtfaTEwXTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBwID0gTWF0aC5taW4odGhpcy5uLCB0aGlzLm0gKyAxKTtcbiAgaWYgKG5jdCA8IHRoaXMubikge1xuICAgIHRoaXMuc1tuY3RdID0gQVtuY3RdW25jdF07XG4gIH1cbiAgaWYgKHRoaXMubSA8IHApIHtcbiAgICB0aGlzLnNbcCAtIDFdID0gMC4wO1xuICB9XG4gIGlmIChucnQgKyAxIDwgcCkge1xuICAgIGVbbnJ0XSA9IEFbbnJ0XVtwIC0gMV07XG4gIH1cbiAgZVtwIC0gMV0gPSAwLjA7XG4gIGlmICh3YW50dSkge1xuICAgIGZvciAodmFyIF9qMyA9IG5jdDsgX2ozIDwgbnU7IF9qMysrKSB7XG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IHRoaXMubTsgX2kxMSsrKSB7XG4gICAgICAgIHRoaXMuVVtfaTExXVtfajNdID0gMC4wO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgdGhpcy5VW19qM11bX2ozXSA9IDEuMDtcbiAgICB9O1xuICAgIGZvciAodmFyIF9rID0gbmN0IC0gMTsgX2sgPj0gMDsgX2stLSkge1xuICAgICAgaWYgKHRoaXMuc1tfa10gIT09IDAuMCkge1xuICAgICAgICBmb3IgKHZhciBfajQgPSBfayArIDE7IF9qNCA8IG51OyBfajQrKykge1xuICAgICAgICAgIHZhciBfdDIgPSAwO1xuICAgICAgICAgIGZvciAodmFyIF9pMTIgPSBfazsgX2kxMiA8IHRoaXMubTsgX2kxMisrKSB7XG4gICAgICAgICAgICBfdDIgKz0gdGhpcy5VW19pMTJdW19rXSAqIHRoaXMuVVtfaTEyXVtfajRdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3QyID0gLV90MiAvIHRoaXMuVVtfa11bX2tdO1xuICAgICAgICAgIGZvciAodmFyIF9pMTMgPSBfazsgX2kxMyA8IHRoaXMubTsgX2kxMysrKSB7XG4gICAgICAgICAgICB0aGlzLlVbX2kxM11bX2o0XSArPSBfdDIgKiB0aGlzLlVbX2kxM11bX2tdO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pMTQgPSBfazsgX2kxNCA8IHRoaXMubTsgX2kxNCsrKSB7XG4gICAgICAgICAgdGhpcy5VW19pMTRdW19rXSA9IC10aGlzLlVbX2kxNF1bX2tdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLlVbX2tdW19rXSA9IDEuMCArIHRoaXMuVVtfa11bX2tdO1xuICAgICAgICBmb3IgKHZhciBfaTE1ID0gMDsgX2kxNSA8IF9rIC0gMTsgX2kxNSsrKSB7XG4gICAgICAgICAgdGhpcy5VW19pMTVdW19rXSA9IDAuMDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pMTYgPSAwOyBfaTE2IDwgdGhpcy5tOyBfaTE2KyspIHtcbiAgICAgICAgICB0aGlzLlVbX2kxNl1bX2tdID0gMC4wO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLlVbX2tdW19rXSA9IDEuMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGlmICh3YW50dikge1xuICAgIGZvciAodmFyIF9rMiA9IHRoaXMubiAtIDE7IF9rMiA+PSAwOyBfazItLSkge1xuICAgICAgaWYgKGZ1bmN0aW9uIChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gbGhzICYmIHJocztcbiAgICAgIH0oX2syIDwgbnJ0LCBlW19rMl0gIT09IDAuMCkpIHtcbiAgICAgICAgZm9yICh2YXIgX2o1ID0gX2syICsgMTsgX2o1IDwgbnU7IF9qNSsrKSB7XG4gICAgICAgICAgdmFyIF90MyA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgX2kxNyA9IF9rMiArIDE7IF9pMTcgPCB0aGlzLm47IF9pMTcrKykge1xuICAgICAgICAgICAgX3QzICs9IHRoaXMuVltfaTE3XVtfazJdICogdGhpcy5WW19pMTddW19qNV07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdDMgPSAtX3QzIC8gdGhpcy5WW19rMiArIDFdW19rMl07XG4gICAgICAgICAgZm9yICh2YXIgX2kxOCA9IF9rMiArIDE7IF9pMTggPCB0aGlzLm47IF9pMTgrKykge1xuICAgICAgICAgICAgdGhpcy5WW19pMThdW19qNV0gKz0gX3QzICogdGhpcy5WW19pMThdW19rMl07XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMTkgPSAwOyBfaTE5IDwgdGhpcy5uOyBfaTE5KyspIHtcbiAgICAgICAgdGhpcy5WW19pMTldW19rMl0gPSAwLjA7XG4gICAgICB9O1xuICAgICAgdGhpcy5WW19rMl1bX2syXSA9IDEuMDtcbiAgICB9O1xuICB9XG4gIHZhciBwcCA9IHAgLSAxO1xuICB2YXIgaXRlciA9IDA7XG4gIHZhciBlcHMgPSBNYXRoLnBvdygyLjAsIC01Mi4wKTtcbiAgdmFyIHRpbnkgPSBNYXRoLnBvdygyLjAsIC05NjYuMCk7XG4gIHdoaWxlIChwID4gMCkge1xuICAgIHZhciBfazMgPSB2b2lkIDA7XG4gICAgdmFyIGthc2UgPSB2b2lkIDA7XG4gICAgZm9yIChfazMgPSBwIC0gMjsgX2szID49IC0xOyBfazMtLSkge1xuICAgICAgaWYgKF9rMyA9PT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoZVtfazNdKSA8PSB0aW55ICsgZXBzICogKE1hdGguYWJzKHRoaXMuc1tfazNdKSArIE1hdGguYWJzKHRoaXMuc1tfazMgKyAxXSkpKSB7XG4gICAgICAgIGVbX2szXSA9IDAuMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoX2szID09PSBwIC0gMikge1xuICAgICAga2FzZSA9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrcyA9IHZvaWQgMDtcbiAgICAgIGZvciAoa3MgPSBwIC0gMTsga3MgPj0gX2szOyBrcy0tKSB7XG4gICAgICAgIGlmIChrcyA9PT0gX2szKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90NCA9IChrcyAhPT0gcCA/IE1hdGguYWJzKGVba3NdKSA6IDAuMCkgKyAoa3MgIT09IF9rMyArIDEgPyBNYXRoLmFicyhlW2tzIC0gMV0pIDogMC4wKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuc1trc10pIDw9IHRpbnkgKyBlcHMgKiBfdDQpIHtcbiAgICAgICAgICB0aGlzLnNba3NdID0gMC4wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGtzID09PSBfazMpIHtcbiAgICAgICAga2FzZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKGtzID09PSBwIC0gMSkge1xuICAgICAgICBrYXNlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGthc2UgPSAyO1xuICAgICAgICBfazMgPSBrcztcbiAgICAgIH1cbiAgICB9XG4gICAgX2szKys7XG4gICAgc3dpdGNoIChrYXNlKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZiA9IGVbcCAtIDJdO1xuICAgICAgICAgIGVbcCAtIDJdID0gMC4wO1xuICAgICAgICAgIGZvciAodmFyIF9qNiA9IHAgLSAyOyBfajYgPj0gX2szOyBfajYtLSkge1xuICAgICAgICAgICAgdmFyIF90NSA9IFNWRC5oeXBvdCh0aGlzLnNbX2o2XSwgZik7XG4gICAgICAgICAgICB2YXIgY3MgPSB0aGlzLnNbX2o2XSAvIF90NTtcbiAgICAgICAgICAgIHZhciBzbiA9IGYgLyBfdDU7XG4gICAgICAgICAgICB0aGlzLnNbX2o2XSA9IF90NTtcbiAgICAgICAgICAgIGlmIChfajYgIT09IF9rMykge1xuICAgICAgICAgICAgICBmID0gLXNuICogZVtfajYgLSAxXTtcbiAgICAgICAgICAgICAgZVtfajYgLSAxXSA9IGNzICogZVtfajYgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTIwID0gMDsgX2kyMCA8IHRoaXMubjsgX2kyMCsrKSB7XG4gICAgICAgICAgICAgICAgX3Q1ID0gY3MgKiB0aGlzLlZbX2kyMF1bX2o2XSArIHNuICogdGhpcy5WW19pMjBdW3AgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyMF1bcCAtIDFdID0gLXNuICogdGhpcy5WW19pMjBdW19qNl0gKyBjcyAqIHRoaXMuVltfaTIwXVtwIC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjBdW19qNl0gPSBfdDU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2YgPSBlW19rMyAtIDFdO1xuICAgICAgICAgIGVbX2szIC0gMV0gPSAwLjA7XG4gICAgICAgICAgZm9yICh2YXIgX2o3ID0gX2szOyBfajcgPCBwOyBfajcrKykge1xuICAgICAgICAgICAgdmFyIF90NiA9IFNWRC5oeXBvdCh0aGlzLnNbX2o3XSwgX2YpO1xuICAgICAgICAgICAgdmFyIF9jcyA9IHRoaXMuc1tfajddIC8gX3Q2O1xuICAgICAgICAgICAgdmFyIF9zbiA9IF9mIC8gX3Q2O1xuICAgICAgICAgICAgdGhpcy5zW19qN10gPSBfdDY7XG4gICAgICAgICAgICBfZiA9IC1fc24gKiBlW19qN107XG4gICAgICAgICAgICBlW19qN10gPSBfY3MgKiBlW19qN107XG4gICAgICAgICAgICBpZiAod2FudHUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMSA9IDA7IF9pMjEgPCB0aGlzLm07IF9pMjErKykge1xuICAgICAgICAgICAgICAgIF90NiA9IF9jcyAqIHRoaXMuVVtfaTIxXVtfajddICsgX3NuICogdGhpcy5VW19pMjFdW19rMyAtIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVVtfaTIxXVtfazMgLSAxXSA9IC1fc24gKiB0aGlzLlVbX2kyMV1bX2o3XSArIF9jcyAqIHRoaXMuVVtfaTIxXVtfazMgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlVbX2kyMV1bX2o3XSA9IF90NjtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWF4KE1hdGguYWJzKHRoaXMuc1twIC0gMV0pLCBNYXRoLmFicyh0aGlzLnNbcCAtIDJdKSksIE1hdGguYWJzKGVbcCAtIDJdKSksIE1hdGguYWJzKHRoaXMuc1tfazNdKSksIE1hdGguYWJzKGVbX2szXSkpO1xuICAgICAgICAgIHZhciBzcCA9IHRoaXMuc1twIC0gMV0gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgc3BtMSA9IHRoaXMuc1twIC0gMl0gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgZXBtMSA9IGVbcCAtIDJdIC8gc2NhbGU7XG4gICAgICAgICAgdmFyIHNrID0gdGhpcy5zW19rM10gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgZWsgPSBlW19rM10gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgYiA9ICgoc3BtMSArIHNwKSAqIChzcG0xIC0gc3ApICsgZXBtMSAqIGVwbTEpIC8gMi4wO1xuICAgICAgICAgIHZhciBjID0gc3AgKiBlcG0xICogKHNwICogZXBtMSk7XG4gICAgICAgICAgdmFyIHNoaWZ0ID0gMC4wO1xuICAgICAgICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgICAgIHJldHVybiBsaHMgfHwgcmhzO1xuICAgICAgICAgIH0oYiAhPT0gMC4wLCBjICE9PSAwLjApKSB7XG4gICAgICAgICAgICBzaGlmdCA9IE1hdGguc3FydChiICogYiArIGMpO1xuICAgICAgICAgICAgaWYgKGIgPCAwLjApIHtcbiAgICAgICAgICAgICAgc2hpZnQgPSAtc2hpZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGlmdCA9IGMgLyAoYiArIHNoaWZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9mMiA9IChzayArIHNwKSAqIChzayAtIHNwKSArIHNoaWZ0O1xuICAgICAgICAgIHZhciBnID0gc2sgKiBlaztcbiAgICAgICAgICBmb3IgKHZhciBfajggPSBfazM7IF9qOCA8IHAgLSAxOyBfajgrKykge1xuICAgICAgICAgICAgdmFyIF90NyA9IFNWRC5oeXBvdChfZjIsIGcpO1xuICAgICAgICAgICAgdmFyIF9jczIgPSBfZjIgLyBfdDc7XG4gICAgICAgICAgICB2YXIgX3NuMiA9IGcgLyBfdDc7XG4gICAgICAgICAgICBpZiAoX2o4ICE9PSBfazMpIHtcbiAgICAgICAgICAgICAgZVtfajggLSAxXSA9IF90NztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mMiA9IF9jczIgKiB0aGlzLnNbX2o4XSArIF9zbjIgKiBlW19qOF07XG4gICAgICAgICAgICBlW19qOF0gPSBfY3MyICogZVtfajhdIC0gX3NuMiAqIHRoaXMuc1tfajhdO1xuICAgICAgICAgICAgZyA9IF9zbjIgKiB0aGlzLnNbX2o4ICsgMV07XG4gICAgICAgICAgICB0aGlzLnNbX2o4ICsgMV0gPSBfY3MyICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjIgPSAwOyBfaTIyIDwgdGhpcy5uOyBfaTIyKyspIHtcbiAgICAgICAgICAgICAgICBfdDcgPSBfY3MyICogdGhpcy5WW19pMjJdW19qOF0gKyBfc24yICogdGhpcy5WW19pMjJdW19qOCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTIyXVtfajggKyAxXSA9IC1fc24yICogdGhpcy5WW19pMjJdW19qOF0gKyBfY3MyICogdGhpcy5WW19pMjJdW19qOCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTIyXVtfajhdID0gX3Q3O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3Q3ID0gU1ZELmh5cG90KF9mMiwgZyk7XG4gICAgICAgICAgICBfY3MyID0gX2YyIC8gX3Q3O1xuICAgICAgICAgICAgX3NuMiA9IGcgLyBfdDc7XG4gICAgICAgICAgICB0aGlzLnNbX2o4XSA9IF90NztcbiAgICAgICAgICAgIF9mMiA9IF9jczIgKiBlW19qOF0gKyBfc24yICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgdGhpcy5zW19qOCArIDFdID0gLV9zbjIgKiBlW19qOF0gKyBfY3MyICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgZyA9IF9zbjIgKiBlW19qOCArIDFdO1xuICAgICAgICAgICAgZVtfajggKyAxXSA9IF9jczIgKiBlW19qOCArIDFdO1xuICAgICAgICAgICAgaWYgKHdhbnR1ICYmIF9qOCA8IHRoaXMubSAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMyA9IDA7IF9pMjMgPCB0aGlzLm07IF9pMjMrKykge1xuICAgICAgICAgICAgICAgIF90NyA9IF9jczIgKiB0aGlzLlVbX2kyM11bX2o4XSArIF9zbjIgKiB0aGlzLlVbX2kyM11bX2o4ICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjNdW19qOCArIDFdID0gLV9zbjIgKiB0aGlzLlVbX2kyM11bX2o4XSArIF9jczIgKiB0aGlzLlVbX2kyM11bX2o4ICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjNdW19qOF0gPSBfdDc7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlW3AgLSAyXSA9IF9mMjtcbiAgICAgICAgICBpdGVyID0gaXRlciArIDE7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuc1tfazNdIDw9IDAuMCkge1xuICAgICAgICAgICAgdGhpcy5zW19rM10gPSB0aGlzLnNbX2szXSA8IDAuMCA/IC10aGlzLnNbX2szXSA6IDAuMDtcbiAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTI0ID0gMDsgX2kyNCA8PSBwcDsgX2kyNCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjRdW19rM10gPSAtdGhpcy5WW19pMjRdW19rM107XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChfazMgPCBwcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc1tfazNdID49IHRoaXMuc1tfazMgKyAxXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdDggPSB0aGlzLnNbX2szXTtcbiAgICAgICAgICAgIHRoaXMuc1tfazNdID0gdGhpcy5zW19rMyArIDFdO1xuICAgICAgICAgICAgdGhpcy5zW19rMyArIDFdID0gX3Q4O1xuICAgICAgICAgICAgaWYgKHdhbnR2ICYmIF9rMyA8IHRoaXMubiAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyNSA9IDA7IF9pMjUgPCB0aGlzLm47IF9pMjUrKykge1xuICAgICAgICAgICAgICAgIF90OCA9IHRoaXMuVltfaTI1XVtfazMgKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyNV1bX2szICsgMV0gPSB0aGlzLlZbX2kyNV1bX2szXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyNV1bX2szXSA9IF90ODtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YW50dSAmJiBfazMgPCB0aGlzLm0gLSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjYgPSAwOyBfaTI2IDwgdGhpcy5tOyBfaTI2KyspIHtcbiAgICAgICAgICAgICAgICBfdDggPSB0aGlzLlVbX2kyNl1bX2szICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjZdW19rMyArIDFdID0gdGhpcy5VW19pMjZdW19rM107XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjZdW19rM10gPSBfdDg7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfazMrKztcbiAgICAgICAgICB9O1xuICAgICAgICAgIGl0ZXIgPSAwO1xuICAgICAgICAgIHAtLTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICB2YXIgcmVzdWx0ID0geyBVOiB0aGlzLlUsIFY6IHRoaXMuViwgUzogdGhpcy5zIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBzcXJ0KGFeMiArIGJeMikgd2l0aG91dCB1bmRlci9vdmVyZmxvdy5cblNWRC5oeXBvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciByID0gdm9pZCAwO1xuICBpZiAoTWF0aC5hYnMoYSkgPiBNYXRoLmFicyhiKSkge1xuICAgIHIgPSBiIC8gYTtcbiAgICByID0gTWF0aC5hYnMoYSkgKiBNYXRoLnNxcnQoMSArIHIgKiByKTtcbiAgfSBlbHNlIGlmIChiICE9IDApIHtcbiAgICByID0gYSAvIGI7XG4gICAgciA9IE1hdGguYWJzKGIpICogTWF0aC5zcXJ0KDEgKyByICogcik7XG4gIH0gZWxzZSB7XG4gICAgciA9IDAuMDtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZEO1xuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogICBOZWVkbGVtYW4tV3Vuc2NoIGFsZ29yaXRobSBpcyBhbiBwcm9jZWR1cmUgdG8gY29tcHV0ZSB0aGUgb3B0aW1hbCBnbG9iYWwgYWxpZ25tZW50IG9mIHR3byBzdHJpbmdcbiAqICAgc2VxdWVuY2VzIGJ5IFMuQi5OZWVkbGVtYW4gYW5kIEMuRC5XdW5zY2ggKDE5NzApLlxuICpcbiAqICAgQXNpZGUgZnJvbSB0aGUgaW5wdXRzLCB5b3UgY2FuIGFzc2lnbiB0aGUgc2NvcmVzIGZvcixcbiAqICAgLSBNYXRjaDogVGhlIHR3byBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IGluZGV4IGFyZSBzYW1lLlxuICogICAtIE1pc21hdGNoOiBUaGUgdHdvIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgaW5kZXggYXJlIGRpZmZlcmVudC5cbiAqICAgLSBJbnNlcnRpb24vRGVsZXRpb24oZ2Fwcyk6IFRoZSBiZXN0IGFsaWdubWVudCBpbnZvbHZlcyBvbmUgbGV0dGVyIGFsaWduaW5nIHRvIGEgZ2FwIGluIHRoZSBvdGhlciBzdHJpbmcuXG4gKi9cblxudmFyIE5lZWRsZW1hbld1bnNjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZWVkbGVtYW5XdW5zY2goc2VxdWVuY2UxLCBzZXF1ZW5jZTIpIHtcbiAgICAgICAgdmFyIG1hdGNoX3Njb3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgICB2YXIgbWlzbWF0Y2hfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogLTE7XG4gICAgICAgIHZhciBnYXBfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogLTE7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5lZWRsZW1hbld1bnNjaCk7XG5cbiAgICAgICAgdGhpcy5zZXF1ZW5jZTEgPSBzZXF1ZW5jZTE7XG4gICAgICAgIHRoaXMuc2VxdWVuY2UyID0gc2VxdWVuY2UyO1xuICAgICAgICB0aGlzLm1hdGNoX3Njb3JlID0gbWF0Y2hfc2NvcmU7XG4gICAgICAgIHRoaXMubWlzbWF0Y2hfcGVuYWx0eSA9IG1pc21hdGNoX3BlbmFsdHk7XG4gICAgICAgIHRoaXMuZ2FwX3BlbmFsdHkgPSBnYXBfcGVuYWx0eTtcblxuICAgICAgICAvLyBKdXN0IHRoZSByZW1vdmUgcmVkdW5kYW5jeVxuICAgICAgICB0aGlzLmlNYXggPSBzZXF1ZW5jZTEubGVuZ3RoICsgMTtcbiAgICAgICAgdGhpcy5qTWF4ID0gc2VxdWVuY2UyLmxlbmd0aCArIDE7XG5cbiAgICAgICAgLy8gR3JpZCBtYXRyaXggb2Ygc2NvcmVzXG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBBcnJheSh0aGlzLmlNYXgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaU1heDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRbaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjZWJhY2sgbWF0cml4ICgyRCBhcnJheSwgZWFjaCBjZWxsIGlzIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzIGZvciBbYERpYWdgLCBgVXBgLCBgTGVmdGBdIHBvc2l0aW9ucylcbiAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkID0gbmV3IEFycmF5KHRoaXMuaU1heCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmlNYXg7IF9pKyspIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHRoaXMuak1heDsgX2orKykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV1bX2pdID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGFsaWduZWQgc2VxdWVuY2VzIChyZXR1cm4gbXVsdGlwbGUgcG9zc2liaWxpdGllcylcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgLy8gRmluYWwgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgIHRoaXMuc2NvcmUgPSAtMTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NvcmVzIGFuZCB0cmFjZWJhY2tzXG4gICAgICAgIHRoaXMuY29tcHV0ZUdyaWRzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE5lZWRsZW1hbld1bnNjaCwgW3tcbiAgICAgICAga2V5OiBcImdldFNjb3JlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY29yZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3JlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0QWxpZ25tZW50c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxpZ25tZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWluIGR5bmFtaWMgcHJvZ3JhbW1pbmcgcHJvY2VkdXJlXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb21wdXRlR3JpZHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVHcmlkcygpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFswXVtqXSA9IHRoaXMuZ3JpZFswXVtqIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFswXVtqXSA9IFtmYWxzZSwgZmFsc2UsIHRydWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIGluIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbaV1bMF0gPSB0aGlzLmdyaWRbaSAtIDFdWzBdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbaV1bMF0gPSBbZmFsc2UsIHRydWUsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCB0aGUgcmVzdCBvZiB0aGUgZ3JpZFxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMTsgX2kyIDwgdGhpcy5pTWF4OyBfaTIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDE7IF9qMiA8IHRoaXMuak1heDsgX2oyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF4IHNjb3JlKHMpIGFtb25nIFtgRGlhZ2AsIGBVcGAsIGBMZWZ0YF1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbmNlMVtfaTIgLSAxXSA9PT0gdGhpcy5zZXF1ZW5jZTJbX2oyIC0gMV0pIGRpYWcgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyIC0gMV0gKyB0aGlzLm1hdGNoX3Njb3JlO2Vsc2UgZGlhZyA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajIgLSAxXSArIHRoaXMubWlzbWF0Y2hfcGVuYWx0eTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXAgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5ncmlkW19pMl1bX2oyIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBtdWx0aXBsZSBtYXggdmFsdWVzLCBjYXB0dXJlIHRoZW0gZm9yIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhPZiA9IFtkaWFnLCB1cCwgbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5hcnJheUFsbE1heEluZGV4ZXMobWF4T2YpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBHcmlkc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRbX2kyXVtfajJdID0gbWF4T2ZbaW5kaWNlc1swXV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaTJdW19qMl0gPSBbaW5kaWNlcy5pbmNsdWRlcygwKSwgaW5kaWNlcy5pbmNsdWRlcygxKSwgaW5kaWNlcy5pbmNsdWRlcygyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgICAgICB0aGlzLnNjb3JlID0gdGhpcy5ncmlkW3RoaXMuaU1heCAtIDFdW3RoaXMuak1heCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0cyBhbGwgcG9zc2libGUgdmFsaWQgc2VxdWVuY2UgY29tYmluYXRpb25zXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbGlnbm1lbnRUcmFjZWJhY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsaWdubWVudFRyYWNlYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBpblByb2Nlc3NBbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW3RoaXMuc2VxdWVuY2UxLmxlbmd0aCwgdGhpcy5zZXF1ZW5jZTIubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICBzZXExOiBcIlwiLFxuICAgICAgICAgICAgICAgIHNlcTI6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5Qcm9jZXNzQWxpZ25tZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaW5Qcm9jZXNzQWxpZ25tZW50c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IHRoaXMudHJhY2ViYWNrR3JpZFtjdXJyZW50LnBvc1swXV1bY3VycmVudC5wb3NbMV1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0gLSAxLCBjdXJyZW50LnBvc1sxXSAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6IHRoaXMuc2VxdWVuY2UyW2N1cnJlbnQucG9zWzFdIC0gMV0gKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdIC0gMSwgY3VycmVudC5wb3NbMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6ICctJyArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0sIGN1cnJlbnQucG9zWzFdIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiAnLScgKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiB0aGlzLnNlcXVlbmNlMltjdXJyZW50LnBvc1sxXSAtIDFdICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBvc1swXSA9PT0gMCAmJiBjdXJyZW50LnBvc1sxXSA9PT0gMCkgdGhpcy5hbGlnbm1lbnRzLnB1c2goeyBzZXF1ZW5jZTE6IGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UyOiBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlbHBlciBGdW5jdGlvbnNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldEFsbEluZGV4ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbEluZGV4ZXMoYXJyLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKChpID0gYXJyLmluZGV4T2YodmFsLCBpICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYXJyYXlBbGxNYXhJbmRleGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcnJheUFsbE1heEluZGV4ZXMoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbEluZGV4ZXMoYXJyYXksIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5KSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmVlZGxlbWFuV3Vuc2NoO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5lZWRsZW1hbld1bnNjaDtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGF5b3V0QmFzZSA9IGZ1bmN0aW9uIGxheW91dEJhc2UoKSB7XG4gIHJldHVybjtcbn07XG5cbmxheW91dEJhc2UuRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xubGF5b3V0QmFzZS5GRExheW91dEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbmxheW91dEJhc2UuRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5sYXlvdXRCYXNlLkRpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbmxheW91dEJhc2UuSGFzaE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xubGF5b3V0QmFzZS5IYXNoU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5sYXlvdXRCYXNlLklHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5sYXlvdXRCYXNlLklNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmxheW91dEJhc2UuSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xubGF5b3V0QmFzZS5Qb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xubGF5b3V0QmFzZS5Qb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xubGF5b3V0QmFzZS5SYW5kb21TZWVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5sYXlvdXRCYXNlLlJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbmxheW91dEJhc2UuVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5sYXlvdXRCYXNlLlVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5sYXlvdXRCYXNlLlF1aWNrc29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xubGF5b3V0QmFzZS5MaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5sYXlvdXRCYXNlLkxHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5sYXlvdXRCYXNlLkxHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5sYXlvdXRCYXNlLkxFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmxheW91dEJhc2UuTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5sYXlvdXRCYXNlLkxOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmxheW91dEJhc2UuTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5sYXlvdXRCYXNlLkxheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5sYXlvdXRCYXNlLk5lZWRsZW1hbld1bnNjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xubGF5b3V0QmFzZS5NYXRyaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbmxheW91dEJhc2UuU1ZEID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbm1vZHVsZS5leHBvcnRzID0gbGF5b3V0QmFzZTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBFbWl0dGVyKCkge1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG52YXIgcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xuXG5wLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICB0aGlzLmxpc3RlbmVycy5wdXNoKHtcbiAgICBldmVudDogZXZlbnQsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxucC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzW2ldO1xuXG4gICAgaWYgKGwuZXZlbnQgPT09IGV2ZW50ICYmIGwuY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG59O1xuXG5wLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsID0gdGhpcy5saXN0ZW5lcnNbaV07XG5cbiAgICBpZiAoZXZlbnQgPT09IGwuZXZlbnQpIHtcbiAgICAgIGwuY2FsbGJhY2soZGF0YSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJ2YWx1ZSIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsIm4iLCJfX2VzTW9kdWxlIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJMYXlvdXRDb25zdGFudHMiLCJRVUFMSVRZIiwiREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEIiwiREVGQVVMVF9JTkNSRU1FTlRBTCIsIkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVCIsIkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQiLCJERUZBVUxUX0FOSU1BVElPTl9QRVJJT0QiLCJERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTIiwiREVGQVVMVF9HUkFQSF9NQVJHSU4iLCJOT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMiLCJTSU1QTEVfTk9ERV9TSVpFIiwiU0lNUExFX05PREVfSEFMRl9TSVpFIiwiRU1QVFlfQ09NUE9VTkRfTk9ERV9TSVpFIiwiTUlOX0VER0VfTEVOR1RIIiwiV09STERfQk9VTkRBUlkiLCJJTklUSUFMX1dPUkxEX0JPVU5EQVJZIiwiV09STERfQ0VOVEVSX1giLCJXT1JMRF9DRU5URVJfWSIsIkxHcmFwaE9iamVjdCIsIklHZW9tZXRyeSIsIklNYXRoIiwiTEVkZ2UiLCJzb3VyY2UiLCJ0YXJnZXQiLCJ2RWRnZSIsImlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCIsInZHcmFwaE9iamVjdCIsImJlbmRwb2ludHMiLCJjcmVhdGUiLCJwcm9wIiwiZ2V0U291cmNlIiwiZ2V0VGFyZ2V0IiwiaXNJbnRlckdyYXBoIiwiZ2V0TGVuZ3RoIiwibGVuZ3RoIiwiZ2V0QmVuZHBvaW50cyIsImdldExjYSIsImxjYSIsImdldFNvdXJjZUluTGNhIiwic291cmNlSW5MY2EiLCJnZXRUYXJnZXRJbkxjYSIsInRhcmdldEluTGNhIiwiZ2V0T3RoZXJFbmQiLCJub2RlIiwiZ2V0T3RoZXJFbmRJbkdyYXBoIiwiZ3JhcGgiLCJvdGhlckVuZCIsImdldEdyYXBoTWFuYWdlciIsImdldFJvb3QiLCJnZXRPd25lciIsImdldFBhcmVudCIsInVwZGF0ZUxlbmd0aCIsImNsaXBQb2ludENvb3JkaW5hdGVzIiwiQXJyYXkiLCJnZXRJbnRlcnNlY3Rpb24iLCJnZXRSZWN0IiwibGVuZ3RoWCIsImxlbmd0aFkiLCJNYXRoIiwiYWJzIiwic2lnbiIsInNxcnQiLCJ1cGRhdGVMZW5ndGhTaW1wbGUiLCJnZXRDZW50ZXJYIiwiZ2V0Q2VudGVyWSIsIkludGVnZXIiLCJSZWN0YW5nbGVEIiwiUmFuZG9tU2VlZCIsIlBvaW50RCIsIkxOb2RlIiwiZ20iLCJsb2MiLCJzaXplIiwidk5vZGUiLCJncmFwaE1hbmFnZXIiLCJlc3RpbWF0ZWRTaXplIiwiTUlOX1ZBTFVFIiwiaW5jbHVzaW9uVHJlZURlcHRoIiwiTUFYX1ZBTFVFIiwiZWRnZXMiLCJyZWN0IiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsImdldEVkZ2VzIiwiZ2V0Q2hpbGQiLCJjaGlsZCIsIm93bmVyIiwiZ2V0V2lkdGgiLCJzZXRXaWR0aCIsImdldEhlaWdodCIsInNldEhlaWdodCIsImdldENlbnRlciIsImdldExvY2F0aW9uIiwiZ2V0RGlhZ29uYWwiLCJnZXRIYWxmVGhlRGlhZ29uYWwiLCJzZXRSZWN0IiwidXBwZXJMZWZ0IiwiZGltZW5zaW9uIiwic2V0Q2VudGVyIiwiY3giLCJjeSIsInNldExvY2F0aW9uIiwibW92ZUJ5IiwiZHgiLCJkeSIsImdldEVkZ2VMaXN0VG9Ob2RlIiwidG8iLCJlZGdlTGlzdCIsImVkZ2UiLCJzZWxmIiwiZm9yRWFjaCIsInB1c2giLCJnZXRFZGdlc0JldHdlZW4iLCJvdGhlciIsImdldE5laWdoYm9yc0xpc3QiLCJuZWlnaGJvcnMiLCJTZXQiLCJhZGQiLCJ3aXRoQ2hpbGRyZW4iLCJ3aXRoTmVpZ2hib3JzTGlzdCIsImNoaWxkTm9kZSIsImNoaWxkcmVuIiwibm9kZXMiLCJnZXROb2RlcyIsImdldE5vT2ZDaGlsZHJlbiIsIm5vT2ZDaGlsZHJlbiIsImdldEVzdGltYXRlZFNpemUiLCJjYWxjRXN0aW1hdGVkU2l6ZSIsInNjYXR0ZXIiLCJyYW5kb21DZW50ZXJYIiwicmFuZG9tQ2VudGVyWSIsIm1pblgiLCJtYXhYIiwibmV4dERvdWJsZSIsIm1pblkiLCJtYXhZIiwidXBkYXRlQm91bmRzIiwiY2hpbGRHcmFwaCIsImdldExlZnQiLCJnZXRUb3AiLCJnZXRSaWdodCIsImdldEJvdHRvbSIsImxhYmVsV2lkdGgiLCJsYWJlbFBvc0hvcml6b250YWwiLCJsYWJlbEhlaWdodCIsImxhYmVsUG9zVmVydGljYWwiLCJnZXRJbmNsdXNpb25UcmVlRGVwdGgiLCJ0cmFuc2Zvcm0iLCJ0cmFucyIsImxlZnQiLCJ0b3AiLCJsZWZ0VG9wIiwidkxlZnRUb3AiLCJpbnZlcnNlVHJhbnNmb3JtUG9pbnQiLCJGRExheW91dENvbnN0YW50cyIsIk1BWF9JVEVSQVRJT05TIiwiREVGQVVMVF9FREdFX0xFTkdUSCIsIkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIIiwiREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEgiLCJERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEgiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEgiLCJERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsIkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OIiwiREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OIiwiREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCIsIkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IiLCJBREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQiLCJBREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQiLCJNQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUwiLCJNQVhfTk9ERV9ESVNQTEFDRU1FTlQiLCJNSU5fUkVQVUxTSU9OX0RJU1QiLCJDT05WRVJHRU5DRV9DSEVDS19QRVJJT0QiLCJQRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SIiwiR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QiLCJnZXRYIiwiZ2V0WSIsInNldFgiLCJzZXRZIiwiZ2V0RGlmZmVyZW5jZSIsInB0IiwiRGltZW5zaW9uRCIsImdldENvcHkiLCJ0cmFuc2xhdGUiLCJkaW0iLCJMR3JhcGhNYW5hZ2VyIiwiUG9pbnQiLCJMaW5rZWRMaXN0IiwiTEdyYXBoIiwicGFyZW50Iiwib2JqMiIsInZHcmFwaCIsIm1hcmdpbiIsImlzQ29ubmVjdGVkIiwiTGF5b3V0IiwicmlnaHQiLCJib3R0b20iLCJvYmoxIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJuZXdOb2RlIiwiaW5kZXhPZiIsIm5ld0VkZ2UiLCJyZW1vdmUiLCJvYmoiLCJlZGdlc1RvQmVSZW1vdmVkIiwic2xpY2UiLCJpbmRleCIsInNwbGljZSIsInNvdXJjZUluZGV4IiwidGFyZ2V0SW5kZXgiLCJ1cGRhdGVMZWZ0VG9wIiwibm9kZVRvcCIsIm5vZGVMZWZ0IiwibE5vZGUiLCJwYWRkaW5nTGVmdCIsInVuZGVmaW5lZCIsInJlY3Vyc2l2ZSIsIm5vZGVSaWdodCIsIm5vZGVCb3R0b20iLCJib3VuZGluZ1JlY3QiLCJjYWxjdWxhdGVCb3VuZHMiLCJ1cGRhdGVDb25uZWN0ZWQiLCJxdWV1ZSIsInZpc2l0ZWQiLCJjdXJyZW50Tm9kZSIsIm5laWdoYm9yRWRnZXMiLCJjdXJyZW50TmVpZ2hib3IiLCJjaGlsZHJlbk9mTm9kZSIsInNoaWZ0IiwibmVpZ2hib3JFZGdlIiwiaGFzIiwiY2hpbGRyZW5PZk5laWdoYm9yIiwibm9PZlZpc2l0ZWRJblRoaXNHcmFwaCIsInZpc2l0ZWROb2RlIiwibGF5b3V0IiwiZ3JhcGhzIiwiYWRkUm9vdCIsIm5ncmFwaCIsIm5ld0dyYXBoIiwibm5vZGUiLCJzZXRSb290R3JhcGgiLCJyb290R3JhcGgiLCJwYXJlbnROb2RlIiwic291cmNlR3JhcGgiLCJ0YXJnZXRHcmFwaCIsImxPYmoiLCJjb25jYXQiLCJub2Rlc1RvQmVSZW1vdmVkIiwiZ2V0R3JhcGhzIiwiZ2V0QWxsTm9kZXMiLCJhbGxOb2RlcyIsIm5vZGVMaXN0IiwicmVzZXRBbGxOb2RlcyIsInJlc2V0QWxsRWRnZXMiLCJhbGxFZGdlcyIsInJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24iLCJhbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImdldEFsbEVkZ2VzIiwiZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24iLCJzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImdldExheW91dCIsImlzT25lQW5jZXN0b3JPZk90aGVyIiwiZmlyc3ROb2RlIiwic2Vjb25kTm9kZSIsIm93bmVyR3JhcGgiLCJjYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzIiwic291cmNlQW5jZXN0b3JHcmFwaCIsInRhcmdldEFuY2VzdG9yR3JhcGgiLCJjYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJmaXJzdE93bmVyR3JhcGgiLCJzZWNvbmRPd25lckdyYXBoIiwiY2FsY0luY2x1c2lvblRyZWVEZXB0aHMiLCJkZXB0aCIsImluY2x1ZGVzSW52YWxpZEVkZ2UiLCJlZGdlc1RvUmVtb3ZlIiwiY2FsY1NlcGFyYXRpb25BbW91bnQiLCJyZWN0QSIsInJlY3RCIiwib3ZlcmxhcEFtb3VudCIsInNlcGFyYXRpb25CdWZmZXIiLCJpbnRlcnNlY3RzIiwiZGlyZWN0aW9ucyIsImRlY2lkZURpcmVjdGlvbnNGb3JPdmVybGFwcGluZ05vZGVzIiwibWluIiwibWF4Iiwic2xvcGUiLCJtb3ZlQnlZIiwibW92ZUJ5WCIsImdldEludGVyc2VjdGlvbjIiLCJyZXN1bHQiLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJ0b3BMZWZ0QXgiLCJ0b3BMZWZ0QXkiLCJ0b3BSaWdodEF4IiwiYm90dG9tTGVmdEF4IiwiYm90dG9tTGVmdEF5IiwiYm90dG9tUmlnaHRBeCIsImhhbGZXaWR0aEEiLCJnZXRXaWR0aEhhbGYiLCJoYWxmSGVpZ2h0QSIsImdldEhlaWdodEhhbGYiLCJ0b3BMZWZ0QngiLCJ0b3BMZWZ0QnkiLCJ0b3BSaWdodEJ4IiwiYm90dG9tTGVmdEJ4IiwiYm90dG9tTGVmdEJ5IiwiYm90dG9tUmlnaHRCeCIsImhhbGZXaWR0aEIiLCJoYWxmSGVpZ2h0QiIsImNsaXBQb2ludEFGb3VuZCIsImNsaXBQb2ludEJGb3VuZCIsInNsb3BlQSIsInNsb3BlQiIsInNsb3BlUHJpbWUiLCJjYXJkaW5hbERpcmVjdGlvbkEiLCJjYXJkaW5hbERpcmVjdGlvbkIiLCJ0ZW1wUG9pbnRBeCIsInRlbXBQb2ludEF5IiwidGVtcFBvaW50QngiLCJ0ZW1wUG9pbnRCeSIsImdldENhcmRpbmFsRGlyZWN0aW9uIiwibGluZSIsInMxIiwiczIiLCJmMSIsImYyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4MyIsInkzIiwieDQiLCJ5NCIsImExIiwiYTIiLCJiMSIsImIyIiwiYzEiLCJjMiIsImRlbm9tIiwiYW5nbGVPZlZlY3RvciIsIkN4IiwiQ3kiLCJOeCIsIk55IiwiQ19hbmdsZSIsImF0YW4iLCJQSSIsIlRXT19QSSIsIk9ORV9BTkRfSEFMRl9QSSIsIkhBTEZfUEkiLCJkb0ludGVyc2VjdCIsInAxIiwicDIiLCJwMyIsInA0IiwiYSIsImIiLCJxIiwiciIsImRldCIsImxhbWJkYSIsImdhbW1hIiwiZmluZENpcmNsZUxpbmVJbnRlcnNlY3Rpb25zIiwiRXgiLCJFeSIsIkx4IiwiTHkiLCJkaXNjIiwidDEiLCJ0MiIsImludGVyc2VjdGlvbnMiLCJUSFJFRV9QSSIsImZsb29yIiwiY2VpbCIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJ3cml0YWJsZSIsImtleSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJUeXBlRXJyb3IiLCJub2RlRnJvbSIsIm5leHQiLCJwcmV2IiwibGlzdCIsImhlYWQiLCJ0YWlsIiwiX3JlbW92ZSIsInZhbHMiLCJfdGhpcyIsInYiLCJpbnNlcnRCZWZvcmUiLCJ2YWwiLCJvdGhlck5vZGUiLCJpbnNlcnRBZnRlciIsImluc2VydE5vZGVCZWZvcmUiLCJpbnNlcnROb2RlQWZ0ZXIiLCJ1bnNoaWZ0IiwicG9wIiwicG9wTm9kZSIsInNoaWZ0Tm9kZSIsImdldF9vYmplY3RfYXQiLCJjdXJyZW50Iiwic2V0X29iamVjdF9hdCIsImNvbnN0cnVjdG9yIiwicGFyc2VJbnQiLCJtb3ZlIiwiZXF1YWxzIiwidG9TdHJpbmciLCJnZXRNaW5YIiwiZ2V0TWF4WCIsImdldE1pblkiLCJnZXRNYXhZIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiVW5pcXVlSURHZW5lcmV0b3IiLCJsYXN0SUQiLCJjcmVhdGVJRCIsImlzUHJpbWl0aXZlIiwidW5pcXVlSUQiLCJnZXRTdHJpbmciLCJpZCIsImFyZyIsInR5cGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJpc0FycmF5IiwiYXJyMiIsImZyb20iLCJUcmFuc2Zvcm0iLCJFbWl0dGVyIiwiaXNSZW1vdGVVc2UiLCJsYXlvdXRRdWFsaXR5IiwiY3JlYXRlQmVuZHNBc05lZWRlZCIsImluY3JlbWVudGFsIiwiYW5pbWF0aW9uT25MYXlvdXQiLCJhbmltYXRpb25EdXJpbmdMYXlvdXQiLCJhbmltYXRpb25QZXJpb2QiLCJ1bmlmb3JtTGVhZk5vZGVTaXplcyIsImVkZ2VUb0R1bW15Tm9kZXMiLCJNYXAiLCJpc0xheW91dEZpbmlzaGVkIiwiaXNTdWJMYXlvdXQiLCJSQU5ET01fU0VFRCIsIm5ld0dyYXBoTWFuYWdlciIsImNoZWNrTGF5b3V0U3VjY2VzcyIsInJ1bkxheW91dCIsInRpbGluZ1ByZUxheW91dCIsImluaXRQYXJhbWV0ZXJzIiwiaXNMYXlvdXRTdWNjZXNzZnVsbCIsIkFOSU1BVEUiLCJkb1Bvc3RMYXlvdXQiLCJ0aWxpbmdQb3N0TGF5b3V0IiwidXBkYXRlIiwidXBkYXRlMiIsImNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcyIsIm5ld0xlZnRUb3AiLCJzZXRXb3JsZE9yZ1giLCJzZXRXb3JsZE9yZ1kiLCJzZXREZXZpY2VPcmdYIiwic2V0RGV2aWNlT3JnWSIsInBvc2l0aW9uTm9kZXNSYW5kb21seSIsImdldEZsYXRGb3Jlc3QiLCJmbGF0Rm9yZXN0IiwiaXNGb3Jlc3QiLCJpc0ZsYXQiLCJ0b0JlVmlzaXRlZCIsInBhcmVudHMiLCJ1blByb2Nlc3NlZE5vZGVzIiwic2V0IiwidGVtcCIsImNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzIiwiZHVtbXlOb2RlcyIsImR1bW15Tm9kZSIsIkRpbWVuc2lvbiIsImR1bW15RWRnZSIsImtleXMiLCJrIiwibEVkZ2UiLCJwYXRoIiwiZWJwIiwic2xpZGVyVmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJtaW5EaXYiLCJtYXhNdWwiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiZmluZENlbnRlck9mVHJlZSIsInJlbW92ZWROb2RlcyIsInJlbWFpbmluZ0RlZ3JlZXMiLCJmb3VuZENlbnRlciIsImNlbnRlck5vZGUiLCJkZWdyZWUiLCJ0ZW1wTGlzdCIsInRlbXBMaXN0MiIsIm5laWdoYm91cnMiLCJuZWlnaGJvdXIiLCJvdGhlckRlZ3JlZSIsIm5ld0RlZ3JlZSIsInNldEdyYXBoTWFuYWdlciIsInNlZWQiLCJzaW4iLCJsd29ybGRPcmdYIiwibHdvcmxkT3JnWSIsImxkZXZpY2VPcmdYIiwibGRldmljZU9yZ1kiLCJsd29ybGRFeHRYIiwibHdvcmxkRXh0WSIsImxkZXZpY2VFeHRYIiwibGRldmljZUV4dFkiLCJnZXRXb3JsZE9yZ1giLCJ3b3giLCJnZXRXb3JsZE9yZ1kiLCJ3b3kiLCJnZXRXb3JsZEV4dFgiLCJzZXRXb3JsZEV4dFgiLCJ3ZXgiLCJnZXRXb3JsZEV4dFkiLCJzZXRXb3JsZEV4dFkiLCJ3ZXkiLCJnZXREZXZpY2VPcmdYIiwiZG94IiwiZ2V0RGV2aWNlT3JnWSIsImRveSIsImdldERldmljZUV4dFgiLCJzZXREZXZpY2VFeHRYIiwiZGV4IiwiZ2V0RGV2aWNlRXh0WSIsInNldERldmljZUV4dFkiLCJkZXkiLCJ0cmFuc2Zvcm1YIiwieERldmljZSIsIndvcmxkRXh0WCIsInRyYW5zZm9ybVkiLCJ5RGV2aWNlIiwid29ybGRFeHRZIiwiaW52ZXJzZVRyYW5zZm9ybVgiLCJ4V29ybGQiLCJkZXZpY2VFeHRYIiwiaW52ZXJzZVRyYW5zZm9ybVkiLCJ5V29ybGQiLCJkZXZpY2VFeHRZIiwiaW5Qb2ludCIsIm91dFBvaW50IiwiRkRMYXlvdXQiLCJ1c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uIiwiZ3Jhdml0eUNvbnN0YW50IiwiY29tcG91bmRHcmF2aXR5Q29uc3RhbnQiLCJncmF2aXR5UmFuZ2VGYWN0b3IiLCJjb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciIsImRpc3BsYWNlbWVudFRocmVzaG9sZFBlck5vZGUiLCJjb29saW5nRmFjdG9yIiwiaW5pdGlhbENvb2xpbmdGYWN0b3IiLCJ0b3RhbERpc3BsYWNlbWVudCIsIm9sZFRvdGFsRGlzcGxhY2VtZW50IiwibWF4SXRlcmF0aW9ucyIsImFyZ3VtZW50cyIsInRvdGFsSXRlcmF0aW9ucyIsIm5vdEFuaW1hdGVkSXRlcmF0aW9ucyIsInVzZUZSR3JpZFZhcmlhbnQiLCJncmlkIiwiY2FsY0lkZWFsRWRnZUxlbmd0aHMiLCJvcmlnaW5hbElkZWFsTGVuZ3RoIiwibGNhRGVwdGgiLCJzaXplT2ZTb3VyY2VJbkxjYSIsInNpemVPZlRhcmdldEluTGNhIiwiaWRlYWxMZW5ndGgiLCJpbml0U3ByaW5nRW1iZWRkZXIiLCJtYXhOb2RlRGlzcGxhY2VtZW50IiwidG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQiLCJyZXB1bHNpb25SYW5nZSIsImNhbGNSZXB1bHNpb25SYW5nZSIsImNhbGNTcHJpbmdGb3JjZXMiLCJsRWRnZXMiLCJjYWxjU3ByaW5nRm9yY2UiLCJjYWxjUmVwdWxzaW9uRm9yY2VzIiwiZ3JpZFVwZGF0ZUFsbG93ZWQiLCJmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlIiwiaiIsIm5vZGVBIiwibm9kZUIiLCJsTm9kZXMiLCJwcm9jZXNzZWROb2RlU2V0IiwidXBkYXRlR3JpZCIsImNhbGN1bGF0ZVJlcHVsc2lvbkZvcmNlT2ZBTm9kZSIsImNhbGNSZXB1bHNpb25Gb3JjZSIsImNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzIiwiY2FsY0dyYXZpdGF0aW9uYWxGb3JjZSIsIm1vdmVOb2RlcyIsInNwcmluZ0ZvcmNlIiwic3ByaW5nRm9yY2VYIiwic3ByaW5nRm9yY2VZIiwiZWRnZUVsYXN0aWNpdHkiLCJjbGlwUG9pbnRzIiwiZGlzdGFuY2VYIiwiZGlzdGFuY2VZIiwiZGlzdGFuY2VTcXVhcmVkIiwiZGlzdGFuY2UiLCJyZXB1bHNpb25Gb3JjZSIsInJlcHVsc2lvbkZvcmNlWCIsInJlcHVsc2lvbkZvcmNlWSIsImNoaWxkcmVuQ29uc3RhbnQiLCJub2RlUmVwdWxzaW9uIiwib3duZXJDZW50ZXJYIiwib3duZXJDZW50ZXJZIiwiYWJzRGlzdGFuY2VYIiwiYWJzRGlzdGFuY2VZIiwiZ3Jhdml0YXRpb25Gb3JjZVgiLCJncmF2aXRhdGlvbkZvcmNlWSIsImlzQ29udmVyZ2VkIiwiY29udmVyZ2VkIiwib3NjaWxhdGluZyIsImFuaW1hdGUiLCJjYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMiLCJjYWxjR3JpZCIsInNpemVYIiwic2l6ZVkiLCJhZGROb2RlVG9HcmlkIiwic3RhcnRYIiwiZmluaXNoWCIsInN0YXJ0WSIsImZpbmlzaFkiLCJzZXRHcmlkQ29vcmRpbmF0ZXMiLCJzdXJyb3VuZGluZyIsIkZETGF5b3V0RWRnZSIsIkZETGF5b3V0Tm9kZSIsImRpc3BsYWNlbWVudFgiLCJkaXNwbGFjZW1lbnRZIiwiX3N0YXJ0WCIsIl9maW5pc2hYIiwiX3N0YXJ0WSIsIl9maW5pc2hZIiwiSGFzaE1hcCIsIm1hcCIsInB1dCIsInRoZUlkIiwiY29udGFpbnMiLCJrZXlTZXQiLCJIYXNoU2V0IiwiY2xlYXIiLCJpc0VtcHR5IiwiYWRkQWxsVG8iLCJhZGRBbGwiLCJNYXRyaXgiLCJtdWx0TWF0IiwiYXJyYXkxIiwiYXJyYXkyIiwidHJhbnNwb3NlIiwiYXJyYXkiLCJtdWx0Q29ucyIsImNvbnN0YW50IiwibWludXNPcCIsImRvdFByb2R1Y3QiLCJwcm9kdWN0IiwibWFnIiwibm9ybWFsaXplIiwibWFnbml0dWRlIiwibXVsdEdhbW1hIiwic3VtIiwiX2kiLCJtdWx0TCIsIkMiLCJJTlYiLCJ0ZW1wMSIsInRlbXAyIiwiX2kyIiwiX3N1bSIsIl9qIiwiX2kzIiwiX3N1bTIiLCJfajIiLCJRdWlja3NvcnQiLCJBIiwiY29tcGFyZUZ1bmN0aW9uIiwiX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24iLCJfcXVpY2tzb3J0IiwiX3BhcnRpdGlvbiIsIl9nZXQiLCJfc3dhcCIsIl9zZXQiLCJTVkQiLCJzdmQiLCJVIiwiViIsIm51IiwiZGltcyIsImFsbG9jYXRlIiwiZSIsIndvcmsiLCJ3YW50dSIsIndhbnR2IiwibmN0IiwibnJ0IiwiaHlwb3QiLCJsaHMiLCJyaHMiLCJ0IiwiX2k0IiwiX2k1IiwiX2k2IiwiX2k3IiwiX2k4IiwiX3QiLCJfaTkiLCJfaTEwIiwiX2ozIiwiX2kxMSIsIl9rIiwiX2o0IiwiX3QyIiwiX2kxMiIsIl9pMTMiLCJfaTE0IiwiX2kxNSIsIl9pMTYiLCJfazIiLCJfajUiLCJfdDMiLCJfaTE3IiwiX2kxOCIsIl9pMTkiLCJwcCIsIml0ZXIiLCJlcHMiLCJwb3ciLCJ0aW55IiwiX2szIiwia2FzZSIsImtzIiwiX3Q0IiwiZiIsIl9qNiIsIl90NSIsImNzIiwic24iLCJfaTIwIiwiX2YiLCJfajciLCJfdDYiLCJfY3MiLCJfc24iLCJfaTIxIiwic2NhbGUiLCJzcCIsInNwbTEiLCJlcG0xIiwic2siLCJlayIsIl9mMiIsImciLCJfajgiLCJfdDciLCJfY3MyIiwiX3NuMiIsIl9pMjIiLCJfaTIzIiwiX2kyNCIsIl90OCIsIl9pMjUiLCJfaTI2IiwiUyIsIk5lZWRsZW1hbld1bnNjaCIsInNlcXVlbmNlMSIsInNlcXVlbmNlMiIsIm1hdGNoX3Njb3JlIiwibWlzbWF0Y2hfcGVuYWx0eSIsImdhcF9wZW5hbHR5IiwiaU1heCIsImpNYXgiLCJ0cmFjZWJhY2tHcmlkIiwiYWxpZ25tZW50cyIsInNjb3JlIiwiY29tcHV0ZUdyaWRzIiwiZ2V0U2NvcmUiLCJnZXRBbGlnbm1lbnRzIiwiZGlhZyIsInVwIiwibWF4T2YiLCJpbmRpY2VzIiwiYXJyYXlBbGxNYXhJbmRleGVzIiwiaW5jbHVkZXMiLCJhbGlnbm1lbnRUcmFjZWJhY2siLCJpblByb2Nlc3NBbGlnbm1lbnRzIiwicG9zIiwic2VxMSIsInNlcTIiLCJnZXRBbGxJbmRleGVzIiwiaW5kZXhlcyIsImFwcGx5IiwibGF5b3V0QmFzZSIsImxpc3RlbmVycyIsImFkZExpc3RlbmVyIiwiZXZlbnQiLCJjYWxsYmFjayIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js\n");

/***/ })

};
;