/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape-cose-bilkent";
exports.ids = ["vendor-chunks/cytoscape-cose-bilkent"];
exports.modules = {

/***/ "(ssr)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! cose-base */ \"(ssr)/./node_modules/cose-base/cose-base.js\"));\n    else {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_691__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_691__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_691__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_691__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_691__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_691__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_691__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_691__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_691__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_691__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_691__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_691__(__nested_webpack_require_691__.s = 1);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_3704__) {\n            \"use strict\";\n            var LayoutConstants = __nested_webpack_require_3704__(0).layoutBase.LayoutConstants;\n            var FDLayoutConstants = __nested_webpack_require_3704__(0).layoutBase.FDLayoutConstants;\n            var CoSEConstants = __nested_webpack_require_3704__(0).CoSEConstants;\n            var CoSELayout = __nested_webpack_require_3704__(0).CoSELayout;\n            var CoSENode = __nested_webpack_require_3704__(0).CoSENode;\n            var PointD = __nested_webpack_require_3704__(0).layoutBase.PointD;\n            var DimensionD = __nested_webpack_require_3704__(0).layoutBase.DimensionD;\n            var defaults = {\n                // Called on `layoutready`\n                ready: function ready() {},\n                // Called on `layoutstop`\n                stop: function stop() {},\n                // 'draft', 'default' or 'proof\" \n                // - 'draft' fast cooling rate \n                // - 'default' moderate cooling rate \n                // - \"proof\" slow cooling rate\n                quality: \"default\",\n                // include labels in node dimensions\n                nodeDimensionsIncludeLabels: false,\n                // number of ticks per frame; higher is faster but more jerky\n                refresh: 30,\n                // Whether to fit the network view after when done\n                fit: true,\n                // Padding on fit\n                padding: 10,\n                // Whether to enable incremental mode\n                randomize: true,\n                // Node repulsion (non overlapping) multiplier\n                nodeRepulsion: 4500,\n                // Ideal edge (non nested) length\n                idealEdgeLength: 50,\n                // Divisor to compute edge forces\n                edgeElasticity: 0.45,\n                // Nesting factor (multiplier) to compute ideal edge length for nested edges\n                nestingFactor: 0.1,\n                // Gravity force (constant)\n                gravity: 0.25,\n                // Maximum number of iterations to perform\n                numIter: 2500,\n                // For enabling tiling\n                tile: true,\n                // Type of layout animation. The option set is {'during', 'end', false}\n                animate: \"end\",\n                // Duration for animate:end\n                animationDuration: 500,\n                // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n                tilingPaddingVertical: 10,\n                // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n                tilingPaddingHorizontal: 10,\n                // Gravity range (constant) for compounds\n                gravityRangeCompound: 1.5,\n                // Gravity force (constant) for compounds\n                gravityCompound: 1.0,\n                // Gravity range (constant)\n                gravityRange: 3.8,\n                // Initial cooling factor for incremental layout\n                initialEnergyOnIncremental: 0.5\n            };\n            function extend(defaults, options) {\n                var obj = {};\n                for(var i in defaults){\n                    obj[i] = defaults[i];\n                }\n                for(var i in options){\n                    obj[i] = options[i];\n                }\n                return obj;\n            }\n            ;\n            function _CoSELayout(_options) {\n                this.options = extend(defaults, _options);\n                getUserOptions(this.options);\n            }\n            var getUserOptions = function getUserOptions(options) {\n                if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n                if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n                if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n                if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n                if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n                if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n                if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n                if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n                if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n                if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n                if (options.quality == \"draft\") LayoutConstants.QUALITY = 0;\n                else if (options.quality == \"proof\") LayoutConstants.QUALITY = 2;\n                else LayoutConstants.QUALITY = 1;\n                CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n                CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n                CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n                CoSEConstants.TILE = options.tile;\n                CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === \"function\" ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n                CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === \"function\" ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n            };\n            _CoSELayout.prototype.run = function() {\n                var ready;\n                var frameId;\n                var options = this.options;\n                var idToLNode = this.idToLNode = {};\n                var layout = this.layout = new CoSELayout();\n                var self = this;\n                self.stopped = false;\n                this.cy = this.options.cy;\n                this.cy.trigger({\n                    type: \"layoutstart\",\n                    layout: this\n                });\n                var gm = layout.newGraphManager();\n                this.gm = gm;\n                var nodes = this.options.eles.nodes();\n                var edges = this.options.eles.edges();\n                this.root = gm.addRoot();\n                this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n                for(var i = 0; i < edges.length; i++){\n                    var edge = edges[i];\n                    var sourceNode = this.idToLNode[edge.data(\"source\")];\n                    var targetNode = this.idToLNode[edge.data(\"target\")];\n                    if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n                        e1.id = edge.id();\n                    }\n                }\n                var getPositions = function getPositions(ele, i) {\n                    if (typeof ele === \"number\") {\n                        ele = i;\n                    }\n                    var theId = ele.data(\"id\");\n                    var lNode = self.idToLNode[theId];\n                    return {\n                        x: lNode.getRect().getCenterX(),\n                        y: lNode.getRect().getCenterY()\n                    };\n                };\n                /*\n   * Reposition nodes in iterations animatedly\n   */ var iterateAnimated = function iterateAnimated() {\n                    // Thigs to perform after nodes are repositioned on screen\n                    var afterReposition = function afterReposition() {\n                        if (options.fit) {\n                            options.cy.fit(options.eles, options.padding);\n                        }\n                        if (!ready) {\n                            ready = true;\n                            self.cy.one(\"layoutready\", options.ready);\n                            self.cy.trigger({\n                                type: \"layoutready\",\n                                layout: self\n                            });\n                        }\n                    };\n                    var ticksPerFrame = self.options.refresh;\n                    var isDone;\n                    for(var i = 0; i < ticksPerFrame && !isDone; i++){\n                        isDone = self.stopped || self.layout.tick();\n                    }\n                    // If layout is done\n                    if (isDone) {\n                        // If the layout is not a sublayout and it is successful perform post layout.\n                        if (layout.checkLayoutSuccess() && !layout.isSubLayout) {\n                            layout.doPostLayout();\n                        }\n                        // If layout has a tilingPostLayout function property call it.\n                        if (layout.tilingPostLayout) {\n                            layout.tilingPostLayout();\n                        }\n                        layout.isLayoutFinished = true;\n                        self.options.eles.nodes().positions(getPositions);\n                        afterReposition();\n                        // trigger layoutstop when the layout stops (e.g. finishes)\n                        self.cy.one(\"layoutstop\", self.options.stop);\n                        self.cy.trigger({\n                            type: \"layoutstop\",\n                            layout: self\n                        });\n                        if (frameId) {\n                            cancelAnimationFrame(frameId);\n                        }\n                        ready = false;\n                        return;\n                    }\n                    var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n                    // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)\n                    // use position of their ancestors or dummy ancestors\n                    options.eles.nodes().positions(function(ele, i) {\n                        if (typeof ele === \"number\") {\n                            ele = i;\n                        }\n                        // If ele is a compound node, then its position will be defined by its children\n                        if (!ele.isParent()) {\n                            var theId = ele.id();\n                            var pNode = animationData[theId];\n                            var temp = ele;\n                            // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)\n                            while(pNode == null){\n                                pNode = animationData[temp.data(\"parent\")] || animationData[\"DummyCompound_\" + temp.data(\"parent\")];\n                                animationData[theId] = pNode;\n                                temp = temp.parent()[0];\n                                if (temp == undefined) {\n                                    break;\n                                }\n                            }\n                            if (pNode != null) {\n                                return {\n                                    x: pNode.x,\n                                    y: pNode.y\n                                };\n                            } else {\n                                return {\n                                    x: ele.position(\"x\"),\n                                    y: ele.position(\"y\")\n                                };\n                            }\n                        }\n                    });\n                    afterReposition();\n                    frameId = requestAnimationFrame(iterateAnimated);\n                };\n                /*\n  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n  */ layout.addListener(\"layoutstarted\", function() {\n                    if (self.options.animate === \"during\") {\n                        frameId = requestAnimationFrame(iterateAnimated);\n                    }\n                });\n                layout.runLayout(); // Run cose layout\n                /*\n   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n   */ if (this.options.animate !== \"during\") {\n                    self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n                    ready = false;\n                }\n                return this; // chaining\n            };\n            //Get the top most ones of a list of nodes\n            _CoSELayout.prototype.getTopMostNodes = function(nodes) {\n                var nodesMap = {};\n                for(var i = 0; i < nodes.length; i++){\n                    nodesMap[nodes[i].id()] = true;\n                }\n                var roots = nodes.filter(function(ele, i) {\n                    if (typeof ele === \"number\") {\n                        ele = i;\n                    }\n                    var parent = ele.parent()[0];\n                    while(parent != null){\n                        if (nodesMap[parent.id()]) {\n                            return false;\n                        }\n                        parent = parent.parent()[0];\n                    }\n                    return true;\n                });\n                return roots;\n            };\n            _CoSELayout.prototype.processChildrenList = function(parent, children, layout) {\n                var size = children.length;\n                for(var i = 0; i < size; i++){\n                    var theChild = children[i];\n                    var children_of_children = theChild.children();\n                    var theNode;\n                    var dimensions = theChild.layoutDimensions({\n                        nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels\n                    });\n                    if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position(\"x\") - dimensions.w / 2, theChild.position(\"y\") - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                    } else {\n                        theNode = parent.add(new CoSENode(this.graphManager));\n                    }\n                    // Attach id to the layout node\n                    theNode.id = theChild.data(\"id\");\n                    // Attach the paddings of cy node to layout node\n                    theNode.paddingLeft = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingTop = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingRight = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingBottom = parseInt(theChild.css(\"padding\"));\n                    //Attach the label properties to compound if labels will be included in node dimensions  \n                    if (this.options.nodeDimensionsIncludeLabels) {\n                        if (theChild.isParent()) {\n                            var labelWidth = theChild.boundingBox({\n                                includeLabels: true,\n                                includeNodes: false\n                            }).w;\n                            var labelHeight = theChild.boundingBox({\n                                includeLabels: true,\n                                includeNodes: false\n                            }).h;\n                            var labelPos = theChild.css(\"text-halign\");\n                            theNode.labelWidth = labelWidth;\n                            theNode.labelHeight = labelHeight;\n                            theNode.labelPos = labelPos;\n                        }\n                    }\n                    // Map the layout node\n                    this.idToLNode[theChild.data(\"id\")] = theNode;\n                    if (isNaN(theNode.rect.x)) {\n                        theNode.rect.x = 0;\n                    }\n                    if (isNaN(theNode.rect.y)) {\n                        theNode.rect.y = 0;\n                    }\n                    if (children_of_children != null && children_of_children.length > 0) {\n                        var theNewGraph;\n                        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                        this.processChildrenList(theNewGraph, children_of_children, layout);\n                    }\n                }\n            };\n            /**\n * @brief : called on continuous layouts to stop them before they finish\n */ _CoSELayout.prototype.stop = function() {\n                this.stopped = true;\n                return this; // chaining\n            };\n            var register = function register(cytoscape1) {\n                //  var Layout = getLayout( cytoscape );\n                cytoscape1(\"layout\", \"cose-bilkent\", _CoSELayout);\n            };\n            // auto reg for globals\n            if (typeof cytoscape !== \"undefined\") {\n                register(cytoscape);\n            }\n            module1.exports = register;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC9jeXRvc2NhcGUtY29zZS1iaWxrZW50LmpzIiwibWFwcGluZ3MiOiJBQUFDLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsOERBQVc7U0FDeEMsRUFLcUQ7QUFDM0QsR0FBRyxJQUFJLEVBQUUsU0FBU0csNkJBQTZCO0lBQy9DLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDVCxPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNNLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVgsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtNLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNYLFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFUSw4QkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS1AsUUFBT1UsQ0FB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Y29zZS1iaWxrZW50L2N5dG9zY2FwZS1jb3NlLWJpbGtlbnQuanM/MGExNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJjb3NlLWJhc2VcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiY29zZS1iYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImN5dG9zY2FwZUNvc2VCaWxrZW50XCJdID0gZmFjdG9yeShyZXF1aXJlKFwiY29zZS1iYXNlXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjeXRvc2NhcGVDb3NlQmlsa2VudFwiXSA9IGZhY3Rvcnkocm9vdFtcImNvc2VCYXNlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLkxheW91dENvbnN0YW50cztcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkubGF5b3V0QmFzZS5GRExheW91dENvbnN0YW50cztcbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Db1NFQ29uc3RhbnRzO1xudmFyIENvU0VMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkNvU0VMYXlvdXQ7XG52YXIgQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkNvU0VOb2RlO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkubGF5b3V0QmFzZS5Qb2ludEQ7XG52YXIgRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkubGF5b3V0QmFzZS5EaW1lbnNpb25EO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuICAvLyBDYWxsZWQgb24gYGxheW91dHN0b3BgXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSxcbiAgLy8gJ2RyYWZ0JywgJ2RlZmF1bHQnIG9yICdwcm9vZlwiIFxuICAvLyAtICdkcmFmdCcgZmFzdCBjb29saW5nIHJhdGUgXG4gIC8vIC0gJ2RlZmF1bHQnIG1vZGVyYXRlIGNvb2xpbmcgcmF0ZSBcbiAgLy8gLSBcInByb29mXCIgc2xvdyBjb29saW5nIHJhdGVcbiAgcXVhbGl0eTogJ2RlZmF1bHQnLFxuICAvLyBpbmNsdWRlIGxhYmVscyBpbiBub2RlIGRpbWVuc2lvbnNcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gbnVtYmVyIG9mIHRpY2tzIHBlciBmcmFtZTsgaGlnaGVyIGlzIGZhc3RlciBidXQgbW9yZSBqZXJreVxuICByZWZyZXNoOiAzMCxcbiAgLy8gV2hldGhlciB0byBmaXQgdGhlIG5ldHdvcmsgdmlldyBhZnRlciB3aGVuIGRvbmVcbiAgZml0OiB0cnVlLFxuICAvLyBQYWRkaW5nIG9uIGZpdFxuICBwYWRkaW5nOiAxMCxcbiAgLy8gV2hldGhlciB0byBlbmFibGUgaW5jcmVtZW50YWwgbW9kZVxuICByYW5kb21pemU6IHRydWUsXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogNDUwMCxcbiAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gIGlkZWFsRWRnZUxlbmd0aDogNTAsXG4gIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICBlZGdlRWxhc3RpY2l0eTogMC40NSxcbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yOiAwLjEsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5OiAwLjI1LFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMjUwMCxcbiAgLy8gRm9yIGVuYWJsaW5nIHRpbGluZ1xuICB0aWxlOiB0cnVlLFxuICAvLyBUeXBlIG9mIGxheW91dCBhbmltYXRpb24uIFRoZSBvcHRpb24gc2V0IGlzIHsnZHVyaW5nJywgJ2VuZCcsIGZhbHNlfVxuICBhbmltYXRlOiAnZW5kJyxcbiAgLy8gRHVyYXRpb24gZm9yIGFuaW1hdGU6ZW5kXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIFJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiB0aGUgdmVydGljYWwgc3BhY2UgdG8gcHV0IGJldHdlZW4gdGhlIHplcm8gZGVncmVlIG1lbWJlcnMgZHVyaW5nIHRoZSB0aWxpbmcgb3BlcmF0aW9uKGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24pXG4gIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDogMTAsXG4gIC8vIFJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiB0aGUgaG9yaXpvbnRhbCBzcGFjZSB0byBwdXQgYmV0d2VlbiB0aGUgemVybyBkZWdyZWUgbWVtYmVycyBkdXJpbmcgdGhlIHRpbGluZyBvcGVyYXRpb24oY2FuIGFsc28gYmUgYSBmdW5jdGlvbilcbiAgdGlsaW5nUGFkZGluZ0hvcml6b250YWw6IDEwLFxuICAvLyBHcmF2aXR5IHJhbmdlIChjb25zdGFudCkgZm9yIGNvbXBvdW5kc1xuICBncmF2aXR5UmFuZ2VDb21wb3VuZDogMS41LFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudCkgZm9yIGNvbXBvdW5kc1xuICBncmF2aXR5Q29tcG91bmQ6IDEuMCxcbiAgLy8gR3Jhdml0eSByYW5nZSAoY29uc3RhbnQpXG4gIGdyYXZpdHlSYW5nZTogMy44LFxuICAvLyBJbml0aWFsIGNvb2xpbmcgZmFjdG9yIGZvciBpbmNyZW1lbnRhbCBsYXlvdXRcbiAgaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw6IDAuNVxufTtcblxuZnVuY3Rpb24gZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gIHZhciBvYmogPSB7fTtcblxuICBmb3IgKHZhciBpIGluIGRlZmF1bHRzKSB7XG4gICAgb2JqW2ldID0gZGVmYXVsdHNbaV07XG4gIH1cblxuICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICBvYmpbaV0gPSBvcHRpb25zW2ldO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIF9Db1NFTGF5b3V0KF9vcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgX29wdGlvbnMpO1xuICBnZXRVc2VyT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xufVxuXG52YXIgZ2V0VXNlck9wdGlvbnMgPSBmdW5jdGlvbiBnZXRVc2VyT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLm5vZGVSZXB1bHNpb24gIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIID0gb3B0aW9ucy5ub2RlUmVwdWxzaW9uO1xuICBpZiAob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGggIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuICBpZiAob3B0aW9ucy5lZGdlRWxhc3RpY2l0eSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSBvcHRpb25zLmVkZ2VFbGFzdGljaXR5O1xuICBpZiAob3B0aW9ucy5uZXN0aW5nRmFjdG9yICE9IG51bGwpIENvU0VDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gIGlmIChvcHRpb25zLmdyYXZpdHkgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSBvcHRpb25zLmdyYXZpdHk7XG4gIGlmIChvcHRpb25zLm51bUl0ZXIgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gb3B0aW9ucy5udW1JdGVyO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2UgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IG9wdGlvbnMuZ3Jhdml0eVJhbmdlO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5Q29tcG91bmQgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSBvcHRpb25zLmdyYXZpdHlDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eVJhbmdlQ29tcG91bmQgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IG9wdGlvbnMuZ3Jhdml0eVJhbmdlQ29tcG91bmQ7XG4gIGlmIChvcHRpb25zLmluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgPSBvcHRpb25zLmluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsO1xuXG4gIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gJ2RyYWZ0JykgTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAwO2Vsc2UgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSAncHJvb2YnKSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDI7ZWxzZSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDE7XG5cbiAgQ29TRUNvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBGRExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gb3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM7XG4gIENvU0VDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9ICFvcHRpb25zLnJhbmRvbWl6ZTtcbiAgQ29TRUNvbnN0YW50cy5BTklNQVRFID0gRkRMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9IExheW91dENvbnN0YW50cy5BTklNQVRFID0gb3B0aW9ucy5hbmltYXRlO1xuICBDb1NFQ29uc3RhbnRzLlRJTEUgPSBvcHRpb25zLnRpbGU7XG4gIENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWwgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbC5jYWxsKCkgOiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbDtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19IT1JJWk9OVEFMID0gdHlwZW9mIG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWw7XG59O1xuXG5fQ29TRUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVhZHk7XG4gIHZhciBmcmFtZUlkO1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGlkVG9MTm9kZSA9IHRoaXMuaWRUb0xOb2RlID0ge307XG4gIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dCA9IG5ldyBDb1NFTGF5b3V0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLnN0b3BwZWQgPSBmYWxzZTtcblxuICB0aGlzLmN5ID0gdGhpcy5vcHRpb25zLmN5O1xuXG4gIHRoaXMuY3kudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogdGhpcyB9KTtcblxuICB2YXIgZ20gPSBsYXlvdXQubmV3R3JhcGhNYW5hZ2VyKCk7XG4gIHRoaXMuZ20gPSBnbTtcblxuICB2YXIgbm9kZXMgPSB0aGlzLm9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgZWRnZXMgPSB0aGlzLm9wdGlvbnMuZWxlcy5lZGdlcygpO1xuXG4gIHRoaXMucm9vdCA9IGdtLmFkZFJvb3QoKTtcbiAgdGhpcy5wcm9jZXNzQ2hpbGRyZW5MaXN0KHRoaXMucm9vdCwgdGhpcy5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBsYXlvdXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBzb3VyY2VOb2RlID0gdGhpcy5pZFRvTE5vZGVbZWRnZS5kYXRhKFwic291cmNlXCIpXTtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRoaXMuaWRUb0xOb2RlW2VkZ2UuZGF0YShcInRhcmdldFwiKV07XG4gICAgaWYgKHNvdXJjZU5vZGUgIT09IHRhcmdldE5vZGUgJiYgc291cmNlTm9kZS5nZXRFZGdlc0JldHdlZW4odGFyZ2V0Tm9kZSkubGVuZ3RoID09IDApIHtcbiAgICAgIHZhciBlMSA9IGdtLmFkZChsYXlvdXQubmV3RWRnZSgpLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKTtcbiAgICAgIGUxLmlkID0gZWRnZS5pZCgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBnZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiBnZXRQb3NpdGlvbnMoZWxlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGVsZSA9IGk7XG4gICAgfVxuICAgIHZhciB0aGVJZCA9IGVsZS5kYXRhKCdpZCcpO1xuICAgIHZhciBsTm9kZSA9IHNlbGYuaWRUb0xOb2RlW3RoZUlkXTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBsTm9kZS5nZXRSZWN0KCkuZ2V0Q2VudGVyWCgpLFxuICAgICAgeTogbE5vZGUuZ2V0UmVjdCgpLmdldENlbnRlclkoKVxuICAgIH07XG4gIH07XG5cbiAgLypcbiAgICogUmVwb3NpdGlvbiBub2RlcyBpbiBpdGVyYXRpb25zIGFuaW1hdGVkbHlcbiAgICovXG4gIHZhciBpdGVyYXRlQW5pbWF0ZWQgPSBmdW5jdGlvbiBpdGVyYXRlQW5pbWF0ZWQoKSB7XG4gICAgLy8gVGhpZ3MgdG8gcGVyZm9ybSBhZnRlciBub2RlcyBhcmUgcmVwb3NpdGlvbmVkIG9uIHNjcmVlblxuICAgIHZhciBhZnRlclJlcG9zaXRpb24gPSBmdW5jdGlvbiBhZnRlclJlcG9zaXRpb24oKSB7XG4gICAgICBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgICAgb3B0aW9ucy5jeS5maXQob3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlYWR5KSB7XG4gICAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5jeS5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIHNlbGYuY3kudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogc2VsZiB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRpY2tzUGVyRnJhbWUgPSBzZWxmLm9wdGlvbnMucmVmcmVzaDtcbiAgICB2YXIgaXNEb25lO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc1BlckZyYW1lICYmICFpc0RvbmU7IGkrKykge1xuICAgICAgaXNEb25lID0gc2VsZi5zdG9wcGVkIHx8IHNlbGYubGF5b3V0LnRpY2soKTtcbiAgICB9XG5cbiAgICAvLyBJZiBsYXlvdXQgaXMgZG9uZVxuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIC8vIElmIHRoZSBsYXlvdXQgaXMgbm90IGEgc3VibGF5b3V0IGFuZCBpdCBpcyBzdWNjZXNzZnVsIHBlcmZvcm0gcG9zdCBsYXlvdXQuXG4gICAgICBpZiAobGF5b3V0LmNoZWNrTGF5b3V0U3VjY2VzcygpICYmICFsYXlvdXQuaXNTdWJMYXlvdXQpIHtcbiAgICAgICAgbGF5b3V0LmRvUG9zdExheW91dCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBsYXlvdXQgaGFzIGEgdGlsaW5nUG9zdExheW91dCBmdW5jdGlvbiBwcm9wZXJ0eSBjYWxsIGl0LlxuICAgICAgaWYgKGxheW91dC50aWxpbmdQb3N0TGF5b3V0KSB7XG4gICAgICAgIGxheW91dC50aWxpbmdQb3N0TGF5b3V0KCk7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5pc0xheW91dEZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgc2VsZi5vcHRpb25zLmVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZ2V0UG9zaXRpb25zKTtcblxuICAgICAgYWZ0ZXJSZXBvc2l0aW9uKCk7XG5cbiAgICAgIC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG4gICAgICBzZWxmLmN5Lm9uZSgnbGF5b3V0c3RvcCcsIHNlbGYub3B0aW9ucy5zdG9wKTtcbiAgICAgIHNlbGYuY3kudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBzZWxmIH0pO1xuXG4gICAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIH1cblxuICAgICAgcmVhZHkgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IHNlbGYubGF5b3V0LmdldFBvc2l0aW9uc0RhdGEoKTsgLy8gR2V0IHBvc2l0aW9ucyBvZiBsYXlvdXQgbm9kZXMgbm90ZSB0aGF0IGFsbCBub2RlcyBtYXkgbm90IGJlIGxheW91dCBub2RlcyBiZWNhdXNlIG9mIHRpbGluZ1xuXG4gICAgLy8gUG9zaXRpb24gbm9kZXMsIGZvciB0aGUgbm9kZXMgd2hvc2UgaWQgZG9lcyBub3QgaW5jbHVkZWQgaW4gZGF0YSAoYmVjYXVzZSB0aGV5IGFyZSByZW1vdmVkIGZyb20gdGhlaXIgcGFyZW50cyBhbmQgaW5jbHVkZWQgaW4gZHVtbXkgY29tcG91bmRzKVxuICAgIC8vIHVzZSBwb3NpdGlvbiBvZiB0aGVpciBhbmNlc3RvcnMgb3IgZHVtbXkgYW5jZXN0b3JzXG4gICAgb3B0aW9ucy5lbGVzLm5vZGVzKCkucG9zaXRpb25zKGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGVsZSA9IGk7XG4gICAgICB9XG4gICAgICAvLyBJZiBlbGUgaXMgYSBjb21wb3VuZCBub2RlLCB0aGVuIGl0cyBwb3NpdGlvbiB3aWxsIGJlIGRlZmluZWQgYnkgaXRzIGNoaWxkcmVuXG4gICAgICBpZiAoIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgIHZhciB0aGVJZCA9IGVsZS5pZCgpO1xuICAgICAgICB2YXIgcE5vZGUgPSBhbmltYXRpb25EYXRhW3RoZUlkXTtcbiAgICAgICAgdmFyIHRlbXAgPSBlbGU7XG4gICAgICAgIC8vIElmIHBOb2RlIGlzIHVuZGVmaW5lZCBzZWFyY2ggdW50aWwgZmluZGluZyBwb3NpdGlvbiBkYXRhIG9mIGl0cyBmaXJzdCBhbmNlc3RvciAoSXQgbWF5IGJlIGR1bW15IGFzIHdlbGwpXG4gICAgICAgIHdoaWxlIChwTm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgcE5vZGUgPSBhbmltYXRpb25EYXRhW3RlbXAuZGF0YSgncGFyZW50JyldIHx8IGFuaW1hdGlvbkRhdGFbJ0R1bW15Q29tcG91bmRfJyArIHRlbXAuZGF0YSgncGFyZW50JyldO1xuICAgICAgICAgIGFuaW1hdGlvbkRhdGFbdGhlSWRdID0gcE5vZGU7XG4gICAgICAgICAgdGVtcCA9IHRlbXAucGFyZW50KClbMF07XG4gICAgICAgICAgaWYgKHRlbXAgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcE5vZGUueCxcbiAgICAgICAgICAgIHk6IHBOb2RlLnlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBlbGUucG9zaXRpb24oJ3gnKSxcbiAgICAgICAgICAgIHk6IGVsZS5wb3NpdGlvbigneScpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWZ0ZXJSZXBvc2l0aW9uKCk7XG5cbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGl0ZXJhdGVBbmltYXRlZCk7XG4gIH07XG5cbiAgLypcbiAgKiBMaXN0ZW4gJ2xheW91dHN0YXJ0ZWQnIGV2ZW50IGFuZCBzdGFydCBhbmltYXRlZCBpdGVyYXRpb24gaWYgYW5pbWF0ZSBvcHRpb24gaXMgJ2R1cmluZydcbiAgKi9cbiAgbGF5b3V0LmFkZExpc3RlbmVyKCdsYXlvdXRzdGFydGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLm9wdGlvbnMuYW5pbWF0ZSA9PT0gJ2R1cmluZycpIHtcbiAgICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaXRlcmF0ZUFuaW1hdGVkKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxheW91dC5ydW5MYXlvdXQoKTsgLy8gUnVuIGNvc2UgbGF5b3V0XG5cbiAgLypcbiAgICogSWYgYW5pbWF0ZSBvcHRpb24gaXMgbm90ICdkdXJpbmcnICgnZW5kJyBvciBmYWxzZSkgcGVyZm9ybSB0aGVzZSBoZXJlIChJZiBpdCBpcyAnZHVyaW5nJyBzaW1pbGFyIHRoaW5ncyBhcmUgYWxyZWFkeSBwZXJmb3JtZWQpXG4gICAqL1xuICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUgIT09IFwiZHVyaW5nXCIpIHtcbiAgICBzZWxmLm9wdGlvbnMuZWxlcy5ub2RlcygpLm5vdChcIjpwYXJlbnRcIikubGF5b3V0UG9zaXRpb25zKHNlbGYsIHNlbGYub3B0aW9ucywgZ2V0UG9zaXRpb25zKTsgLy8gVXNlIGxheW91dCBwb3NpdGlvbnMgdG8gcmVwb3NpdGlvbiB0aGUgbm9kZXMgaXQgY29uc2lkZXJzIHRoZSBvcHRpb25zIHBhcmFtZXRlclxuICAgIHJlYWR5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vR2V0IHRoZSB0b3AgbW9zdCBvbmVzIG9mIGEgbGlzdCBvZiBub2Rlc1xuX0NvU0VMYXlvdXQucHJvdG90eXBlLmdldFRvcE1vc3ROb2RlcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbm9kZXNNYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGVzTWFwW25vZGVzW2ldLmlkKCldID0gdHJ1ZTtcbiAgfVxuICB2YXIgcm9vdHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBlbGUgPSBpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpWzBdO1xuICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGVzTWFwW3BhcmVudC5pZCgpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KClbMF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gcm9vdHM7XG59O1xuXG5fQ29TRUxheW91dC5wcm90b3R5cGUucHJvY2Vzc0NoaWxkcmVuTGlzdCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkcmVuLCBsYXlvdXQpIHtcbiAgdmFyIHNpemUgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdmFyIHRoZUNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGNoaWxkcmVuX29mX2NoaWxkcmVuID0gdGhlQ2hpbGQuY2hpbGRyZW4oKTtcbiAgICB2YXIgdGhlTm9kZTtcblxuICAgIHZhciBkaW1lbnNpb25zID0gdGhlQ2hpbGQubGF5b3V0RGltZW5zaW9ucyh7XG4gICAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IHRoaXMub3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHNcbiAgICB9KTtcblxuICAgIGlmICh0aGVDaGlsZC5vdXRlcldpZHRoKCkgIT0gbnVsbCAmJiB0aGVDaGlsZC5vdXRlckhlaWdodCgpICE9IG51bGwpIHtcbiAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHRoZUNoaWxkLnBvc2l0aW9uKCd4JykgLSBkaW1lbnNpb25zLncgLyAyLCB0aGVDaGlsZC5wb3NpdGlvbigneScpIC0gZGltZW5zaW9ucy5oIC8gMiksIG5ldyBEaW1lbnNpb25EKHBhcnNlRmxvYXQoZGltZW5zaW9ucy53KSwgcGFyc2VGbG9hdChkaW1lbnNpb25zLmgpKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIpKTtcbiAgICB9XG4gICAgLy8gQXR0YWNoIGlkIHRvIHRoZSBsYXlvdXQgbm9kZVxuICAgIHRoZU5vZGUuaWQgPSB0aGVDaGlsZC5kYXRhKFwiaWRcIik7XG4gICAgLy8gQXR0YWNoIHRoZSBwYWRkaW5ncyBvZiBjeSBub2RlIHRvIGxheW91dCBub2RlXG4gICAgdGhlTm9kZS5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICB0aGVOb2RlLnBhZGRpbmdUb3AgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgdGhlTm9kZS5wYWRkaW5nUmlnaHQgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgdGhlTm9kZS5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuXG4gICAgLy9BdHRhY2ggdGhlIGxhYmVsIHByb3BlcnRpZXMgdG8gY29tcG91bmQgaWYgbGFiZWxzIHdpbGwgYmUgaW5jbHVkZWQgaW4gbm9kZSBkaW1lbnNpb25zICBcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKHRoZUNoaWxkLmlzUGFyZW50KCkpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UgfSkudztcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlIH0pLmg7XG4gICAgICAgIHZhciBsYWJlbFBvcyA9IHRoZUNoaWxkLmNzcyhcInRleHQtaGFsaWduXCIpO1xuICAgICAgICB0aGVOb2RlLmxhYmVsV2lkdGggPSBsYWJlbFdpZHRoO1xuICAgICAgICB0aGVOb2RlLmxhYmVsSGVpZ2h0ID0gbGFiZWxIZWlnaHQ7XG4gICAgICAgIHRoZU5vZGUubGFiZWxQb3MgPSBsYWJlbFBvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYXAgdGhlIGxheW91dCBub2RlXG4gICAgdGhpcy5pZFRvTE5vZGVbdGhlQ2hpbGQuZGF0YShcImlkXCIpXSA9IHRoZU5vZGU7XG5cbiAgICBpZiAoaXNOYU4odGhlTm9kZS5yZWN0LngpKSB7XG4gICAgICB0aGVOb2RlLnJlY3QueCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKHRoZU5vZGUucmVjdC55KSkge1xuICAgICAgdGhlTm9kZS5yZWN0LnkgPSAwO1xuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbl9vZl9jaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuX29mX2NoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0aGVOZXdHcmFwaDtcbiAgICAgIHRoZU5ld0dyYXBoID0gbGF5b3V0LmdldEdyYXBoTWFuYWdlcigpLmFkZChsYXlvdXQubmV3R3JhcGgoKSwgdGhlTm9kZSk7XG4gICAgICB0aGlzLnByb2Nlc3NDaGlsZHJlbkxpc3QodGhlTmV3R3JhcGgsIGNoaWxkcmVuX29mX2NoaWxkcmVuLCBsYXlvdXQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAqL1xuX0NvU0VMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjeXRvc2NhcGUpIHtcbiAgLy8gIHZhciBMYXlvdXQgPSBnZXRMYXlvdXQoIGN5dG9zY2FwZSApO1xuXG4gIGN5dG9zY2FwZSgnbGF5b3V0JywgJ2Nvc2UtYmlsa2VudCcsIF9Db1NFTGF5b3V0KTtcbn07XG5cbi8vIGF1dG8gcmVnIGZvciBnbG9iYWxzXG5pZiAodHlwZW9mIGN5dG9zY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcmVnaXN0ZXIoY3l0b3NjYXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcjtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsInZhbHVlIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibiIsIl9fZXNNb2R1bGUiLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIkxheW91dENvbnN0YW50cyIsImxheW91dEJhc2UiLCJGRExheW91dENvbnN0YW50cyIsIkNvU0VDb25zdGFudHMiLCJDb1NFTGF5b3V0IiwiQ29TRU5vZGUiLCJQb2ludEQiLCJEaW1lbnNpb25EIiwiZGVmYXVsdHMiLCJyZWFkeSIsInN0b3AiLCJxdWFsaXR5Iiwibm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzIiwicmVmcmVzaCIsImZpdCIsInBhZGRpbmciLCJyYW5kb21pemUiLCJub2RlUmVwdWxzaW9uIiwiaWRlYWxFZGdlTGVuZ3RoIiwiZWRnZUVsYXN0aWNpdHkiLCJuZXN0aW5nRmFjdG9yIiwiZ3Jhdml0eSIsIm51bUl0ZXIiLCJ0aWxlIiwiYW5pbWF0ZSIsImFuaW1hdGlvbkR1cmF0aW9uIiwidGlsaW5nUGFkZGluZ1ZlcnRpY2FsIiwidGlsaW5nUGFkZGluZ0hvcml6b250YWwiLCJncmF2aXR5UmFuZ2VDb21wb3VuZCIsImdyYXZpdHlDb21wb3VuZCIsImdyYXZpdHlSYW5nZSIsImluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsIiwiZXh0ZW5kIiwib3B0aW9ucyIsIm9iaiIsIl9Db1NFTGF5b3V0IiwiX29wdGlvbnMiLCJnZXRVc2VyT3B0aW9ucyIsIkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIIiwiREVGQVVMVF9FREdFX0xFTkdUSCIsIkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIIiwiUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiIsIkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCIsIk1BWF9JVEVSQVRJT05TIiwiREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsIkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCIsIkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IiLCJERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIiwiUVVBTElUWSIsIk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyIsIkRFRkFVTFRfSU5DUkVNRU5UQUwiLCJBTklNQVRFIiwiVElMRSIsIlRJTElOR19QQURESU5HX1ZFUlRJQ0FMIiwiVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCIsInJ1biIsImZyYW1lSWQiLCJpZFRvTE5vZGUiLCJsYXlvdXQiLCJzZWxmIiwic3RvcHBlZCIsImN5IiwidHJpZ2dlciIsInR5cGUiLCJnbSIsIm5ld0dyYXBoTWFuYWdlciIsIm5vZGVzIiwiZWxlcyIsImVkZ2VzIiwiYWRkUm9vdCIsInByb2Nlc3NDaGlsZHJlbkxpc3QiLCJnZXRUb3BNb3N0Tm9kZXMiLCJsZW5ndGgiLCJlZGdlIiwic291cmNlTm9kZSIsImRhdGEiLCJ0YXJnZXROb2RlIiwiZ2V0RWRnZXNCZXR3ZWVuIiwiZTEiLCJhZGQiLCJuZXdFZGdlIiwiaWQiLCJnZXRQb3NpdGlvbnMiLCJlbGUiLCJ0aGVJZCIsImxOb2RlIiwieCIsImdldFJlY3QiLCJnZXRDZW50ZXJYIiwieSIsImdldENlbnRlclkiLCJpdGVyYXRlQW5pbWF0ZWQiLCJhZnRlclJlcG9zaXRpb24iLCJvbmUiLCJ0aWNrc1BlckZyYW1lIiwiaXNEb25lIiwidGljayIsImNoZWNrTGF5b3V0U3VjY2VzcyIsImlzU3ViTGF5b3V0IiwiZG9Qb3N0TGF5b3V0IiwidGlsaW5nUG9zdExheW91dCIsImlzTGF5b3V0RmluaXNoZWQiLCJwb3NpdGlvbnMiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImFuaW1hdGlvbkRhdGEiLCJnZXRQb3NpdGlvbnNEYXRhIiwiaXNQYXJlbnQiLCJwTm9kZSIsInRlbXAiLCJwYXJlbnQiLCJ1bmRlZmluZWQiLCJwb3NpdGlvbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFkZExpc3RlbmVyIiwicnVuTGF5b3V0Iiwibm90IiwibGF5b3V0UG9zaXRpb25zIiwibm9kZXNNYXAiLCJyb290cyIsImZpbHRlciIsImNoaWxkcmVuIiwic2l6ZSIsInRoZUNoaWxkIiwiY2hpbGRyZW5fb2ZfY2hpbGRyZW4iLCJ0aGVOb2RlIiwiZGltZW5zaW9ucyIsImxheW91dERpbWVuc2lvbnMiLCJvdXRlcldpZHRoIiwib3V0ZXJIZWlnaHQiLCJncmFwaE1hbmFnZXIiLCJ3IiwiaCIsInBhcnNlRmxvYXQiLCJwYWRkaW5nTGVmdCIsInBhcnNlSW50IiwiY3NzIiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJsYWJlbFdpZHRoIiwiYm91bmRpbmdCb3giLCJpbmNsdWRlTGFiZWxzIiwiaW5jbHVkZU5vZGVzIiwibGFiZWxIZWlnaHQiLCJsYWJlbFBvcyIsImlzTmFOIiwicmVjdCIsInRoZU5ld0dyYXBoIiwiZ2V0R3JhcGhNYW5hZ2VyIiwibmV3R3JhcGgiLCJyZWdpc3RlciIsImN5dG9zY2FwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\n");

/***/ })

};
;