"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vscode-languageserver-types";
exports.ids = ["vendor-chunks/vscode-languageserver-types"];
exports.modules = {

/***/ "(ssr)/./node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnnotatedTextEdit: () => (/* binding */ AnnotatedTextEdit),\n/* harmony export */   ChangeAnnotation: () => (/* binding */ ChangeAnnotation),\n/* harmony export */   ChangeAnnotationIdentifier: () => (/* binding */ ChangeAnnotationIdentifier),\n/* harmony export */   CodeAction: () => (/* binding */ CodeAction),\n/* harmony export */   CodeActionContext: () => (/* binding */ CodeActionContext),\n/* harmony export */   CodeActionKind: () => (/* binding */ CodeActionKind),\n/* harmony export */   CodeActionTriggerKind: () => (/* binding */ CodeActionTriggerKind),\n/* harmony export */   CodeDescription: () => (/* binding */ CodeDescription),\n/* harmony export */   CodeLens: () => (/* binding */ CodeLens),\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   ColorInformation: () => (/* binding */ ColorInformation),\n/* harmony export */   ColorPresentation: () => (/* binding */ ColorPresentation),\n/* harmony export */   Command: () => (/* binding */ Command),\n/* harmony export */   CompletionItem: () => (/* binding */ CompletionItem),\n/* harmony export */   CompletionItemKind: () => (/* binding */ CompletionItemKind),\n/* harmony export */   CompletionItemLabelDetails: () => (/* binding */ CompletionItemLabelDetails),\n/* harmony export */   CompletionItemTag: () => (/* binding */ CompletionItemTag),\n/* harmony export */   CompletionList: () => (/* binding */ CompletionList),\n/* harmony export */   CreateFile: () => (/* binding */ CreateFile),\n/* harmony export */   DeleteFile: () => (/* binding */ DeleteFile),\n/* harmony export */   Diagnostic: () => (/* binding */ Diagnostic),\n/* harmony export */   DiagnosticRelatedInformation: () => (/* binding */ DiagnosticRelatedInformation),\n/* harmony export */   DiagnosticSeverity: () => (/* binding */ DiagnosticSeverity),\n/* harmony export */   DiagnosticTag: () => (/* binding */ DiagnosticTag),\n/* harmony export */   DocumentHighlight: () => (/* binding */ DocumentHighlight),\n/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),\n/* harmony export */   DocumentLink: () => (/* binding */ DocumentLink),\n/* harmony export */   DocumentSymbol: () => (/* binding */ DocumentSymbol),\n/* harmony export */   DocumentUri: () => (/* binding */ DocumentUri),\n/* harmony export */   EOL: () => (/* binding */ EOL),\n/* harmony export */   FoldingRange: () => (/* binding */ FoldingRange),\n/* harmony export */   FoldingRangeKind: () => (/* binding */ FoldingRangeKind),\n/* harmony export */   FormattingOptions: () => (/* binding */ FormattingOptions),\n/* harmony export */   Hover: () => (/* binding */ Hover),\n/* harmony export */   InlayHint: () => (/* binding */ InlayHint),\n/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),\n/* harmony export */   InlayHintLabelPart: () => (/* binding */ InlayHintLabelPart),\n/* harmony export */   InlineCompletionContext: () => (/* binding */ InlineCompletionContext),\n/* harmony export */   InlineCompletionItem: () => (/* binding */ InlineCompletionItem),\n/* harmony export */   InlineCompletionList: () => (/* binding */ InlineCompletionList),\n/* harmony export */   InlineCompletionTriggerKind: () => (/* binding */ InlineCompletionTriggerKind),\n/* harmony export */   InlineValueContext: () => (/* binding */ InlineValueContext),\n/* harmony export */   InlineValueEvaluatableExpression: () => (/* binding */ InlineValueEvaluatableExpression),\n/* harmony export */   InlineValueText: () => (/* binding */ InlineValueText),\n/* harmony export */   InlineValueVariableLookup: () => (/* binding */ InlineValueVariableLookup),\n/* harmony export */   InsertReplaceEdit: () => (/* binding */ InsertReplaceEdit),\n/* harmony export */   InsertTextFormat: () => (/* binding */ InsertTextFormat),\n/* harmony export */   InsertTextMode: () => (/* binding */ InsertTextMode),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   LocationLink: () => (/* binding */ LocationLink),\n/* harmony export */   MarkedString: () => (/* binding */ MarkedString),\n/* harmony export */   MarkupContent: () => (/* binding */ MarkupContent),\n/* harmony export */   MarkupKind: () => (/* binding */ MarkupKind),\n/* harmony export */   OptionalVersionedTextDocumentIdentifier: () => (/* binding */ OptionalVersionedTextDocumentIdentifier),\n/* harmony export */   ParameterInformation: () => (/* binding */ ParameterInformation),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RenameFile: () => (/* binding */ RenameFile),\n/* harmony export */   SelectedCompletionInfo: () => (/* binding */ SelectedCompletionInfo),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   SemanticTokenModifiers: () => (/* binding */ SemanticTokenModifiers),\n/* harmony export */   SemanticTokenTypes: () => (/* binding */ SemanticTokenTypes),\n/* harmony export */   SemanticTokens: () => (/* binding */ SemanticTokens),\n/* harmony export */   SignatureInformation: () => (/* binding */ SignatureInformation),\n/* harmony export */   StringValue: () => (/* binding */ StringValue),\n/* harmony export */   SymbolInformation: () => (/* binding */ SymbolInformation),\n/* harmony export */   SymbolKind: () => (/* binding */ SymbolKind),\n/* harmony export */   SymbolTag: () => (/* binding */ SymbolTag),\n/* harmony export */   TextDocument: () => (/* binding */ TextDocument),\n/* harmony export */   TextDocumentEdit: () => (/* binding */ TextDocumentEdit),\n/* harmony export */   TextDocumentIdentifier: () => (/* binding */ TextDocumentIdentifier),\n/* harmony export */   TextDocumentItem: () => (/* binding */ TextDocumentItem),\n/* harmony export */   TextEdit: () => (/* binding */ TextEdit),\n/* harmony export */   URI: () => (/* binding */ URI),\n/* harmony export */   VersionedTextDocumentIdentifier: () => (/* binding */ VersionedTextDocumentIdentifier),\n/* harmony export */   WorkspaceChange: () => (/* binding */ WorkspaceChange),\n/* harmony export */   WorkspaceEdit: () => (/* binding */ WorkspaceEdit),\n/* harmony export */   WorkspaceFolder: () => (/* binding */ WorkspaceFolder),\n/* harmony export */   WorkspaceSymbol: () => (/* binding */ WorkspaceSymbol),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   uinteger: () => (/* binding */ uinteger)\n/* harmony export */ });\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ \nvar DocumentUri;\n(function(DocumentUri) {\n    function is(value) {\n        return typeof value === \"string\";\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nvar URI;\n(function(URI) {\n    function is(value) {\n        return typeof value === \"string\";\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nvar integer;\n(function(integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === \"number\" && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nvar uinteger;\n(function(uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === \"number\" && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * {@link Position} literals.\n */ var Position;\n(function(Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */ function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return {\n            line,\n            character\n        };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Position} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * {@link Range} literals.\n */ var Range;\n(function(Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return {\n                start: Position.create(one, two),\n                end: Position.create(three, four)\n            };\n        } else if (Position.is(one) && Position.is(two)) {\n            return {\n                start: one,\n                end: two\n            };\n        } else {\n            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Range} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * {@link Location} literals.\n */ var Location;\n(function(Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */ function create(uri, range) {\n        return {\n            uri,\n            range\n        };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Location} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * {@link LocationLink} literals.\n */ var LocationLink;\n(function(LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return {\n            targetUri,\n            targetRange,\n            targetSelectionRange,\n            originSelectionRange\n        };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link Color} literals.\n */ var Color;\n(function(Color) {\n    /**\n     * Creates a new Color literal.\n     */ function create(red, green, blue, alpha) {\n        return {\n            red,\n            green,\n            blue,\n            alpha\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Color} interface.\n     */ function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * {@link ColorInformation} literals.\n */ var ColorInformation;\n(function(ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */ function create(range, color) {\n        return {\n            range,\n            color\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */ function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link ColorPresentation} literals.\n */ var ColorPresentation;\n(function(ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */ function create(label, textEdit, additionalTextEdits) {\n        return {\n            label,\n            textEdit,\n            additionalTextEdits\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */ function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */ var FoldingRangeKind;\n(function(FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */ FoldingRangeKind.Comment = \"comment\";\n    /**\n     * Folding range for an import or include\n     */ FoldingRangeKind.Imports = \"imports\";\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */ FoldingRangeKind.Region = \"region\";\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * {@link FoldingRange} literals.\n */ var FoldingRange;\n(function(FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        const result = {\n            startLine,\n            endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n     */ function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * {@link DiagnosticRelatedInformation} literals.\n */ var DiagnosticRelatedInformation;\n(function(DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */ function create(location, message) {\n        return {\n            location,\n            message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */ var DiagnosticSeverity;\n(function(DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */ DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */ DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */ DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */ DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */ var DiagnosticTag;\n(function(DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */ DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */ DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */ var CodeDescription;\n(function(CodeDescription) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * {@link Diagnostic} literals.\n */ var Diagnostic;\n(function(Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */ function create(range, message, severity, code, source, relatedInformation) {\n        let result = {\n            range,\n            message\n        };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n     */ function is(value) {\n        var _a;\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * {@link Command} literals.\n */ var Command;\n(function(Command) {\n    /**\n     * Creates a new Command literal.\n     */ function create(title, command, ...args) {\n        let result = {\n            title,\n            command\n        };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Command} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */ var TextEdit;\n(function(TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */ function replace(range, newText) {\n        return {\n            range,\n            newText\n        };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */ function insert(position, newText) {\n        return {\n            range: {\n                start: position,\n                end: position\n            },\n            newText\n        };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */ function del(range) {\n        return {\n            range,\n            newText: \"\"\n        };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nvar ChangeAnnotation;\n(function(ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        const result = {\n            label\n        };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nvar ChangeAnnotationIdentifier;\n(function(ChangeAnnotationIdentifier) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nvar AnnotatedTextEdit;\n(function(AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */ function replace(range, newText, annotation) {\n        return {\n            range,\n            newText,\n            annotationId: annotation\n        };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */ function insert(position, newText, annotation) {\n        return {\n            range: {\n                start: position,\n                end: position\n            },\n            newText,\n            annotationId: annotation\n        };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */ function del(range, annotation) {\n        return {\n            range,\n            newText: \"\",\n            annotationId: annotation\n        };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */ var TextDocumentEdit;\n(function(TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */ function create(textDocument, edits) {\n        return {\n            textDocument,\n            edits\n        };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function(CreateFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: \"create\",\n            uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \"create\" && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function(RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        let result = {\n            kind: \"rename\",\n            oldUri,\n            newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \"rename\" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function(DeleteFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: \"delete\",\n            uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \"delete\" && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function(WorkspaceEdit) {\n    function is(value) {\n        let candidate = value;\n        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every((change)=>{\n            if (Is.string(change.kind)) {\n                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n            } else {\n                return TextDocumentEdit.is(change);\n            }\n        }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nclass TextEditChangeImpl {\n    constructor(edits, changeAnnotations){\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    insert(position, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        } else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        } else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    replace(range, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        } else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        } else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    delete(range, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        } else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        } else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    add(edit) {\n        this.edits.push(edit);\n    }\n    all() {\n        return this.edits;\n    }\n    clear() {\n        this.edits.splice(0, this.edits.length);\n    }\n    assertChangeAnnotations(value) {\n        if (value === undefined) {\n            throw new Error(`Text edit change is not configured to manage change annotations.`);\n        }\n    }\n}\n/**\n * A helper class\n */ class ChangeAnnotations {\n    constructor(annotations){\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    all() {\n        return this._annotations;\n    }\n    get size() {\n        return this._size;\n    }\n    manage(idOrAnnotation, annotation) {\n        let id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        } else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(`Id ${id} is already in use.`);\n        }\n        if (annotation === undefined) {\n            throw new Error(`No annotation provided for id ${id}`);\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    }\n    nextId() {\n        this._counter++;\n        return this._counter.toString();\n    }\n}\n/**\n * A workspace change helps constructing changes to a workspace.\n */ class WorkspaceChange {\n    constructor(workspaceEdit){\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach((change)=>{\n                    if (TextDocumentEdit.is(change)) {\n                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);\n                        this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            } else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach((key)=>{\n                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    this._textEditChanges[key] = textEditChange;\n                });\n            }\n        } else {\n            this._workspaceEdit = {};\n        }\n    }\n    /**\n     * Returns the underlying {@link WorkspaceEdit} literal\n     * use to be returned from a workspace edit operation like rename.\n     */ get edit() {\n        this.initDocumentChanges();\n        if (this._changeAnnotations !== undefined) {\n            if (this._changeAnnotations.size === 0) {\n                this._workspaceEdit.changeAnnotations = undefined;\n            } else {\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        }\n        return this._workspaceEdit;\n    }\n    getTextEditChange(key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error(\"Workspace edit is not configured for document changes.\");\n            }\n            const textDocument = {\n                uri: key.uri,\n                version: key.version\n            };\n            let result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                const edits = [];\n                const textDocumentEdit = {\n                    textDocument,\n                    edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        } else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error(\"Workspace edit is not configured for normal text edit changes.\");\n            }\n            let result = this._textEditChanges[key];\n            if (!result) {\n                let edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    }\n    initDocumentChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    }\n    initChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    }\n    createFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\"Workspace edit is not configured for document changes.\");\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        } else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        } else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    renameFile(oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\"Workspace edit is not configured for document changes.\");\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        } else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        } else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    deleteFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\"Workspace edit is not configured for document changes.\");\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        } else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        } else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n}\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * {@link TextDocumentIdentifier} literals.\n */ var TextDocumentIdentifier;\n(function(TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */ function create(uri) {\n        return {\n            uri\n        };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link VersionedTextDocumentIdentifier} literals.\n */ var VersionedTextDocumentIdentifier;\n(function(VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */ function create(uri, version) {\n        return {\n            uri,\n            version\n        };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\n */ var OptionalVersionedTextDocumentIdentifier;\n(function(OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */ function create(uri, version) {\n        return {\n            uri,\n            version\n        };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * {@link TextDocumentItem} literals.\n */ var TextDocumentItem;\n(function(TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */ function create(uri, languageId, version, text) {\n        return {\n            uri,\n            languageId,\n            version,\n            text\n        };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */ var MarkupKind;\n(function(MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */ MarkupKind.PlainText = \"plaintext\";\n    /**\n     * Markdown is supported as a content format\n     */ MarkupKind.Markdown = \"markdown\";\n    /**\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\n     */ function is(value) {\n        const candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function(MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\n     */ function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */ var CompletionItemKind;\n(function(CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */ var InsertTextFormat;\n(function(InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */ InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */ InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */ var CompletionItemTag;\n(function(CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */ CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */ var InsertReplaceEdit;\n(function(InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */ function create(newText, insert, replace) {\n        return {\n            newText,\n            insert,\n            replace\n        };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n     */ function is(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */ var InsertTextMode;\n(function(InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */ InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */ InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nvar CompletionItemLabelDetails;\n(function(CompletionItemLabelDetails) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */ var CompletionItem;\n(function(CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */ function create(label) {\n        return {\n            label\n        };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */ var CompletionList;\n(function(CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */ function create(items, isIncomplete) {\n        return {\n            items: items ? items : [],\n            isIncomplete: !!isIncomplete\n        };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function(MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */ function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the {@link MarkedString} type.\n     */ function is(value) {\n        const candidate = value;\n        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function(Hover) {\n    /**\n     * Checks whether the given value conforms to the {@link Hover} interface.\n     */ function is(value) {\n        let candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * {@link ParameterInformation} literals.\n */ var ParameterInformation;\n(function(ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */ function create(label, documentation) {\n        return documentation ? {\n            label,\n            documentation\n        } : {\n            label\n        };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * {@link SignatureInformation} literals.\n */ var SignatureInformation;\n(function(SignatureInformation) {\n    function create(label, documentation, ...parameters) {\n        let result = {\n            label\n        };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        } else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */ var DocumentHighlightKind;\n(function(DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */ DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */ DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */ DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * {@link DocumentHighlight} literals.\n */ var DocumentHighlight;\n(function(DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */ function create(range, kind) {\n        let result = {\n            range\n        };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */ var SymbolKind;\n(function(SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */ var SymbolTag;\n(function(SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */ SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nvar SymbolInformation;\n(function(SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */ function create(name, kind, range, uri, containerName) {\n        let result = {\n            name,\n            kind,\n            location: {\n                uri,\n                range\n            }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar WorkspaceSymbol;\n(function(WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */ function create(name, kind, uri, range) {\n        return range !== undefined ? {\n            name,\n            kind,\n            location: {\n                uri,\n                range\n            }\n        } : {\n            name,\n            kind,\n            location: {\n                uri\n            }\n        };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nvar DocumentSymbol;\n(function(DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */ function create(name, detail, kind, range, selectionRange, children) {\n        let result = {\n            name,\n            detail,\n            kind,\n            range,\n            selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n     */ function is(value) {\n        let candidate = value;\n        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */ var CodeActionKind;\n(function(CodeActionKind) {\n    /**\n     * Empty kind.\n     */ CodeActionKind.Empty = \"\";\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */ CodeActionKind.QuickFix = \"quickfix\";\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */ CodeActionKind.Refactor = \"refactor\";\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */ CodeActionKind.RefactorExtract = \"refactor.extract\";\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */ CodeActionKind.RefactorInline = \"refactor.inline\";\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */ CodeActionKind.RefactorRewrite = \"refactor.rewrite\";\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */ CodeActionKind.Source = \"source\";\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */ CodeActionKind.SourceOrganizeImports = \"source.organizeImports\";\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */ CodeActionKind.SourceFixAll = \"source.fixAll\";\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */ var CodeActionTriggerKind;\n(function(CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */ CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */ CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * {@link CodeActionContext} literals.\n */ var CodeActionContext;\n(function(CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */ function create(diagnostics, only, triggerKind) {\n        let result = {\n            diagnostics\n        };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function(CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        let result = {\n            title\n        };\n        let checkKind = true;\n        if (typeof kindOrCommandOrEdit === \"string\") {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        } else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        } else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * {@link CodeLens} literals.\n */ var CodeLens;\n(function(CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */ function create(range, data) {\n        let result = {\n            range\n        };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * {@link FormattingOptions} literals.\n */ var FormattingOptions;\n(function(FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */ function create(tabSize, insertSpaces) {\n        return {\n            tabSize,\n            insertSpaces\n        };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * {@link DocumentLink} literals.\n */ var DocumentLink;\n(function(DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */ function create(range, target, data) {\n        return {\n            range,\n            target,\n            data\n        };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */ var SelectionRange;\n(function(SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */ function create(range, parent) {\n        return {\n            range,\n            parent\n        };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */ var SemanticTokenTypes;\n(function(SemanticTokenTypes) {\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can't be mapped to\n     * a specific type like class or enum.\n     */ SemanticTokenTypes[\"type\"] = \"type\";\n    SemanticTokenTypes[\"class\"] = \"class\";\n    SemanticTokenTypes[\"enum\"] = \"enum\";\n    SemanticTokenTypes[\"interface\"] = \"interface\";\n    SemanticTokenTypes[\"struct\"] = \"struct\";\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes[\"variable\"] = \"variable\";\n    SemanticTokenTypes[\"property\"] = \"property\";\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes[\"event\"] = \"event\";\n    SemanticTokenTypes[\"function\"] = \"function\";\n    SemanticTokenTypes[\"method\"] = \"method\";\n    SemanticTokenTypes[\"macro\"] = \"macro\";\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes[\"comment\"] = \"comment\";\n    SemanticTokenTypes[\"string\"] = \"string\";\n    SemanticTokenTypes[\"number\"] = \"number\";\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes[\"operator\"] = \"operator\";\n    /**\n     * @since 3.17.0\n     */ SemanticTokenTypes[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */ var SemanticTokenModifiers;\n(function(SemanticTokenModifiers) {\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers[\"static\"] = \"static\";\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers[\"async\"] = \"async\";\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */ var SemanticTokens;\n(function(SemanticTokens) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === \"string\") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === \"number\");\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */ var InlineValueText;\n(function(InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */ function create(range, text) {\n        return {\n            range,\n            text\n        };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */ var InlineValueVariableLookup;\n(function(InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */ function create(range, variableName, caseSensitiveLookup) {\n        return {\n            range,\n            variableName,\n            caseSensitiveLookup\n        };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */ var InlineValueEvaluatableExpression;\n(function(InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */ function create(range, expression) {\n        return {\n            range,\n            expression\n        };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * {@link InlineValueContext} literals.\n *\n * @since 3.17.0\n */ var InlineValueContext;\n(function(InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */ function create(frameId, stoppedLocation) {\n        return {\n            frameId,\n            stoppedLocation\n        };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n     */ function is(value) {\n        const candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */ var InlayHintKind;\n(function(InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */ InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */ InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nvar InlayHintLabelPart;\n(function(InlayHintLabelPart) {\n    function create(value) {\n        return {\n            value\n        };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nvar InlayHint;\n(function(InlayHint) {\n    function create(position, label, kind) {\n        const result = {\n            position,\n            label\n        };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nvar StringValue;\n(function(StringValue) {\n    function createSnippet(value) {\n        return {\n            kind: \"snippet\",\n            value\n        };\n    }\n    StringValue.createSnippet = createSnippet;\n})(StringValue || (StringValue = {}));\nvar InlineCompletionItem;\n(function(InlineCompletionItem) {\n    function create(insertText, filterText, range, command) {\n        return {\n            insertText,\n            filterText,\n            range,\n            command\n        };\n    }\n    InlineCompletionItem.create = create;\n})(InlineCompletionItem || (InlineCompletionItem = {}));\nvar InlineCompletionList;\n(function(InlineCompletionList) {\n    function create(items) {\n        return {\n            items\n        };\n    }\n    InlineCompletionList.create = create;\n})(InlineCompletionList || (InlineCompletionList = {}));\n/**\n * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n *\n * @since 3.18.0\n * @proposed\n */ var InlineCompletionTriggerKind;\n(function(InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     */ InlineCompletionTriggerKind.Invoked = 0;\n    /**\n     * Completion was triggered automatically while editing.\n     */ InlineCompletionTriggerKind.Automatic = 1;\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nvar SelectedCompletionInfo;\n(function(SelectedCompletionInfo) {\n    function create(range, text) {\n        return {\n            range,\n            text\n        };\n    }\n    SelectedCompletionInfo.create = create;\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\nvar InlineCompletionContext;\n(function(InlineCompletionContext) {\n    function create(triggerKind, selectedCompletionInfo) {\n        return {\n            triggerKind,\n            selectedCompletionInfo\n        };\n    }\n    InlineCompletionContext.create = create;\n})(InlineCompletionContext || (InlineCompletionContext = {}));\nvar WorkspaceFolder;\n(function(WorkspaceFolder) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nconst EOL = [\n    \"\\n\",\n    \"\\r\\n\",\n    \"\\r\"\n];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */ var TextDocument;\n(function(TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId The document's language Id.\n     * @param version The document's version.\n     * @param content The document's content.\n     */ function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n     */ function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort(edits, (a, b)=>{\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = text.length;\n        for(let i = sortedEdits.length - 1; i >= 0; i--){\n            let e = sortedEdits[i];\n            let startOffset = document.offsetAt(e.range.start);\n            let endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            } else {\n                throw new Error(\"Overlapping edit\");\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        const p = data.length / 2 | 0;\n        const left = data.slice(0, p);\n        const right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        let leftIdx = 0;\n        let rightIdx = 0;\n        let i = 0;\n        while(leftIdx < left.length && rightIdx < right.length){\n            let ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            } else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while(leftIdx < left.length){\n            data[i++] = left[leftIdx++];\n        }\n        while(rightIdx < right.length){\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */ class FullTextDocument {\n    constructor(uri, languageId, version, content){\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            let start = this.offsetAt(range.start);\n            let end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            let lineOffsets = [];\n            let text = this._content;\n            let isLineStart = true;\n            for(let i = 0; i < text.length; i++){\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                let ch = text.charAt(i);\n                isLineStart = ch === \"\\r\" || ch === \"\\n\";\n                if (ch === \"\\r\" && i + 1 < text.length && text.charAt(i + 1) === \"\\n\") {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while(low < high){\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        } else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n}\nvar Is;\n(function(Is) {\n    const toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== \"undefined\";\n    }\n    Is.defined = defined;\n    function undefined1(value) {\n        return typeof value === \"undefined\";\n    }\n    Is.undefined = undefined1;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === \"[object String]\";\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === \"[object Number]\";\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === \"[object Number]\" && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === \"[object Number]\" && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === \"[object Number]\" && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === \"[object Function]\";\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === \"object\";\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi9lc20vbWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OzhGQUc4RixHQUM5RjtBQUNPLElBQUlBLFlBQVk7QUFDdEIsVUFBVUEsV0FBVztJQUNsQixTQUFTQyxHQUFHQyxLQUFLO1FBQ2IsT0FBTyxPQUFPQSxVQUFVO0lBQzVCO0lBQ0FGLFlBQVlDLEVBQUUsR0FBR0E7QUFDckIsR0FBR0QsZUFBZ0JBLENBQUFBLGNBQWMsQ0FBQztBQUMzQixJQUFJRyxJQUFJO0FBQ2QsVUFBVUEsR0FBRztJQUNWLFNBQVNGLEdBQUdDLEtBQUs7UUFDYixPQUFPLE9BQU9BLFVBQVU7SUFDNUI7SUFDQUMsSUFBSUYsRUFBRSxHQUFHQTtBQUNiLEdBQUdFLE9BQVFBLENBQUFBLE1BQU0sQ0FBQztBQUNYLElBQUlDLFFBQVE7QUFDbEIsVUFBVUEsT0FBTztJQUNkQSxRQUFRQyxTQUFTLEdBQUcsQ0FBQztJQUNyQkQsUUFBUUUsU0FBUyxHQUFHO0lBQ3BCLFNBQVNMLEdBQUdDLEtBQUs7UUFDYixPQUFPLE9BQU9BLFVBQVUsWUFBWUUsUUFBUUMsU0FBUyxJQUFJSCxTQUFTQSxTQUFTRSxRQUFRRSxTQUFTO0lBQ2hHO0lBQ0FGLFFBQVFILEVBQUUsR0FBR0E7QUFDakIsR0FBR0csV0FBWUEsQ0FBQUEsVUFBVSxDQUFDO0FBQ25CLElBQUlHLFNBQVM7QUFDbkIsVUFBVUEsUUFBUTtJQUNmQSxTQUFTRixTQUFTLEdBQUc7SUFDckJFLFNBQVNELFNBQVMsR0FBRztJQUNyQixTQUFTTCxHQUFHQyxLQUFLO1FBQ2IsT0FBTyxPQUFPQSxVQUFVLFlBQVlLLFNBQVNGLFNBQVMsSUFBSUgsU0FBU0EsU0FBU0ssU0FBU0QsU0FBUztJQUNsRztJQUNBQyxT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QUFTTCxLQUFLO1FBQ25CLE9BQU82SSxTQUFTcU4sSUFBSSxDQUFDbFcsV0FBVyxxQkFBcUIsS0FBS0EsU0FBU0EsU0FBUztJQUNoRjtJQUNBWSxHQUFHUCxRQUFRLEdBQUdBO0lBQ2QsU0FBUzZTLEtBQUtsVCxLQUFLO1FBQ2YsT0FBTzZJLFNBQVNxTixJQUFJLENBQUNsVyxXQUFXO0lBQ3BDO0lBQ0FZLEdBQUdzUyxJQUFJLEdBQUdBO0lBQ1YsU0FBU3JTLGNBQWNiLEtBQUs7UUFDeEIsMkVBQTJFO1FBQzNFLGdGQUFnRjtRQUNoRix3RUFBd0U7UUFDeEUsT0FBT0EsVUFBVSxRQUFRLE9BQU9BLFVBQVU7SUFDOUM7SUFDQVksR0FBR0MsYUFBYSxHQUFHQTtJQUNuQixTQUFTZ0MsV0FBVzdDLEtBQUssRUFBRW1XLEtBQUs7UUFDNUIsT0FBTzdQLE1BQU1DLE9BQU8sQ0FBQ3ZHLFVBQVVBLE1BQU1xSCxLQUFLLENBQUM4TztJQUMvQztJQUNBdlYsR0FBR2lDLFVBQVUsR0FBR0E7QUFDcEIsR0FBR2pDLE1BQU9BLENBQUFBLEtBQUssQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Npcm8tbmV0d29yay13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcy9saWIvZXNtL21haW4uanM/ZmNmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4ndXNlIHN0cmljdCc7XG5leHBvcnQgdmFyIERvY3VtZW50VXJpO1xuKGZ1bmN0aW9uIChEb2N1bWVudFVyaSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICBEb2N1bWVudFVyaS5pcyA9IGlzO1xufSkoRG9jdW1lbnRVcmkgfHwgKERvY3VtZW50VXJpID0ge30pKTtcbmV4cG9ydCB2YXIgVVJJO1xuKGZ1bmN0aW9uIChVUkkpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgVVJJLmlzID0gaXM7XG59KShVUkkgfHwgKFVSSSA9IHt9KSk7XG5leHBvcnQgdmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG5leHBvcnQgdmFyIHVpbnRlZ2VyO1xuKGZ1bmN0aW9uICh1aW50ZWdlcikge1xuICAgIHVpbnRlZ2VyLk1JTl9WQUxVRSA9IDA7XG4gICAgdWludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB1aW50ZWdlci5NSU5fVkFMVUUgPD0gdmFsdWUgJiYgdmFsdWUgPD0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgICB1aW50ZWdlci5pcyA9IGlzO1xufSkodWludGVnZXIgfHwgKHVpbnRlZ2VyID0ge30pKTtcbi8qKlxuICogVGhlIFBvc2l0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFBvc2l0aW9ufSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBvc2l0aW9uIGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gbGluZSBhbmQgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSBsaW5lIFRoZSBwb3NpdGlvbidzIGxpbmUuXG4gICAgICogQHBhcmFtIGNoYXJhY3RlciBUaGUgcG9zaXRpb24ncyBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxpbmUsIGNoYXJhY3Rlcikge1xuICAgICAgICBpZiAobGluZSA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgbGluZSA9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFBvc2l0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgUG9zaXRpb24uaXMgPSBpcztcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUmFuZ2U7XG4oZnVuY3Rpb24gKFJhbmdlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9uZSwgdHdvLCB0aHJlZSwgZm91cikge1xuICAgICAgICBpZiAoSXMudWludGVnZXIob25lKSAmJiBJcy51aW50ZWdlcih0d28pICYmIElzLnVpbnRlZ2VyKHRocmVlKSAmJiBJcy51aW50ZWdlcihmb3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvc2l0aW9uLmNyZWF0ZShvbmUsIHR3byksIGVuZDogUG9zaXRpb24uY3JlYXRlKHRocmVlLCBmb3VyKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFBvc2l0aW9uLmlzKG9uZSkgJiYgUG9zaXRpb24uaXModHdvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IG9uZSwgZW5kOiB0d28gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzWyR7b25lfSwgJHt0d299LCAke3RocmVlfSwgJHtmb3VyfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9ufSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBMb2NhdGlvbjtcbihmdW5jdGlvbiAoTG9jYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb24gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBsb2NhdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIGxvY2F0aW9uJ3MgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCByYW5nZSB9O1xuICAgIH1cbiAgICBMb2NhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS51cmkpKTtcbiAgICB9XG4gICAgTG9jYXRpb24uaXMgPSBpcztcbn0pKExvY2F0aW9uIHx8IChMb2NhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbkxpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTG9jYXRpb25MaW5rfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBMb2NhdGlvbkxpbms7XG4oZnVuY3Rpb24gKExvY2F0aW9uTGluaykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbkxpbmsgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0VXJpIFRoZSBkZWZpbml0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSB0YXJnZXRSYW5nZSBUaGUgZnVsbCByYW5nZSBvZiB0aGUgZGVmaW5pdGlvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0U2VsZWN0aW9uUmFuZ2UgVGhlIHNwYW4gb2YgdGhlIHN5bWJvbCBkZWZpbml0aW9uIGF0IHRoZSB0YXJnZXQuXG4gICAgICogQHBhcmFtIG9yaWdpblNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgYmVpbmcgZGVmaW5lZCBpbiB0aGUgb3JpZ2luYXRpbmcgc291cmNlIGZpbGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhcmdldFVyaSwgdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlLCBvcmlnaW5TZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICByZXR1cm4geyB0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9uTGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFNlbGVjdGlvblJhbmdlKVxuICAgICAgICAgICAgJiYgKFJhbmdlLmlzKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbkxpbmsuaXMgPSBpcztcbn0pKExvY2F0aW9uTGluayB8fCAoTG9jYXRpb25MaW5rID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9yfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQsXG4gICAgICAgICAgICBncmVlbixcbiAgICAgICAgICAgIGJsdWUsXG4gICAgICAgICAgICBhbHBoYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3IuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3J9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUucmVkLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmdyZWVuLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmJsdWUsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYWxwaGEsIDAsIDEpO1xuICAgIH1cbiAgICBDb2xvci5pcyA9IGlzO1xufSkoQ29sb3IgfHwgKENvbG9yID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9ySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29sb3JJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoQ29sb3JJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgQ29sb3IuaXMoY2FuZGlkYXRlLmNvbG9yKTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JJbmZvcm1hdGlvbiB8fCAoQ29sb3JJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvclByZXNlbnRhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29sb3JQcmVzZW50YXRpb247XG4oZnVuY3Rpb24gKENvbG9yUHJlc2VudGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICB0ZXh0RWRpdCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxUZXh0RWRpdHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yUHJlc2VudGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGV4dEVkaXQpIHx8IFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzLCBUZXh0RWRpdC5pcykpO1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JQcmVzZW50YXRpb24gfHwgKENvbG9yUHJlc2VudGF0aW9uID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCByYW5nZSBraW5kcy5cbiAqL1xuZXhwb3J0IHZhciBGb2xkaW5nUmFuZ2VLaW5kO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VLaW5kKSB7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBjb21tZW50XG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5Db21tZW50ID0gJ2NvbW1lbnQnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGFuIGltcG9ydCBvciBpbmNsdWRlXG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzID0gJ2ltcG9ydHMnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbiA9ICdyZWdpb24nO1xufSkoRm9sZGluZ1JhbmdlS2luZCB8fCAoRm9sZGluZ1JhbmdlS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBmb2xkaW5nIHJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIEZvbGRpbmdSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgRm9sZGluZ1JhbmdlO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvbGRpbmdSYW5nZSBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q2hhcmFjdGVyLCBlbmRDaGFyYWN0ZXIsIGtpbmQsIGNvbGxhcHNlZFRleHQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgc3RhcnRMaW5lLFxuICAgICAgICAgICAgZW5kTGluZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzdGFydENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGVuZENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmRDaGFyYWN0ZXIgPSBlbmRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChjb2xsYXBzZWRUZXh0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbGxhcHNlZFRleHQgPSBjb2xsYXBzZWRUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEZvbGRpbmdSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb2xkaW5nUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuc3RhcnRMaW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuc3RhcnRMaW5lKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc3RhcnRDaGFyYWN0ZXIpIHx8IElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5lbmRDaGFyYWN0ZXIpIHx8IElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5lbmRDaGFyYWN0ZXIpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUua2luZCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSk7XG4gICAgfVxuICAgIEZvbGRpbmdSYW5nZS5pcyA9IGlzO1xufSkoRm9sZGluZ1JhbmdlIHx8IChGb2xkaW5nUmFuZ2UgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxvY2F0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5pcyA9IGlzO1xufSkoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiB8fCAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljJ3Mgc2V2ZXJpdHkuXG4gKi9cbmV4cG9ydCB2YXIgRGlhZ25vc3RpY1NldmVyaXR5O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGVycm9yLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5FcnJvciA9IDE7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIHdhcm5pbmcuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uID0gMztcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgaGludC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSGludCA9IDQ7XG59KShEaWFnbm9zdGljU2V2ZXJpdHkgfHwgKERpYWdub3N0aWNTZXZlcml0eSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljIHRhZ3MuXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG5leHBvcnQgdmFyIERpYWdub3N0aWNUYWc7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNUYWcpIHtcbiAgICAvKipcbiAgICAgKiBVbnVzZWQgb3IgdW5uZWNlc3NhcnkgY29kZS5cbiAgICAgKlxuICAgICAqIENsaWVudHMgYXJlIGFsbG93ZWQgdG8gcmVuZGVyIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgZmFkZWQgb3V0IGluc3RlYWQgb2YgaGF2aW5nXG4gICAgICogYW4gZXJyb3Igc3F1aWdnbGUuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5Vbm5lY2Vzc2FyeSA9IDE7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCBvciBvYnNvbGV0ZSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXJlZCBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIHN0cmlrZSB0aHJvdWdoLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNUYWcuRGVwcmVjYXRlZCA9IDI7XG59KShEaWFnbm9zdGljVGFnIHx8IChEaWFnbm9zdGljVGFnID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVEZXNjcmlwdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBkZXNjcmlwdGlvbnMgZm9yIGRpYWdub3N0aWMgY29kZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG5leHBvcnQgdmFyIENvZGVEZXNjcmlwdGlvbjtcbihmdW5jdGlvbiAoQ29kZURlc2NyaXB0aW9uKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWN9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIERpYWdub3N0aWM7XG4oZnVuY3Rpb24gKERpYWdub3N0aWMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERpYWdub3N0aWMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCBzb3VyY2UsIHJlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyByYW5nZSwgbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb21tYW5kO1xuKGZ1bmN0aW9uIChDb21tYW5kKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb21tYW5kIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBjb21tYW5kLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHRpdGxlLCBjb21tYW5kIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29tbWFuZC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb21tYW5kfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuY29tbWFuZCk7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAqIGluc2VydCBhbmQgZGVsZXRlIGVkaXRzIG1vcmUgZWFzaWx5LlxuICovXG5leHBvcnQgdmFyIFRleHRFZGl0O1xuKGZ1bmN0aW9uIChUZXh0RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0OiAnJyB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VGV4dClcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSk7XG4gICAgfVxuICAgIFRleHRFZGl0LmlzID0gaXM7XG59KShUZXh0RWRpdCB8fCAoVGV4dEVkaXQgPSB7fSkpO1xuZXhwb3J0IHZhciBDaGFuZ2VBbm5vdGF0aW9uO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBuZWVkc0NvbmZpcm1hdGlvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpICYmXG4gICAgICAgICAgICAoSXMuYm9vbGVhbihjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24pIHx8IGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbiA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbiB8fCAoQ2hhbmdlQW5ub3RhdGlvbiA9IHt9KSk7XG5leHBvcnQgdmFyIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciB8fCAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgPSB7fSkpO1xuZXhwb3J0IHZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGluc2VydCB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgZGVsZXRlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dDogJycsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG5leHBvcnQgdmFyIFRleHREb2N1bWVudEVkaXQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUZXh0RG9jdW1lbnRFZGl0YFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0ZXh0RG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7IHRleHREb2N1bWVudCwgZWRpdHMgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoY2FuZGlkYXRlLnRleHREb2N1bWVudClcbiAgICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmVkaXRzKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50RWRpdCB8fCAoVGV4dERvY3VtZW50RWRpdCA9IHt9KSk7XG5leHBvcnQgdmFyIENyZWF0ZUZpbGU7XG4oZnVuY3Rpb24gKENyZWF0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnY3JlYXRlJyxcbiAgICAgICAgICAgIHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdjcmVhdGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmlzID0gaXM7XG59KShDcmVhdGVGaWxlIHx8IChDcmVhdGVGaWxlID0ge30pKTtcbmV4cG9ydCB2YXIgUmVuYW1lRmlsZTtcbihmdW5jdGlvbiAoUmVuYW1lRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ3JlbmFtZScsXG4gICAgICAgICAgICBvbGRVcmksXG4gICAgICAgICAgICBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xuZXhwb3J0IHZhciBEZWxldGVGaWxlO1xuKGZ1bmN0aW9uIChEZWxldGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2RlbGV0ZScsXG4gICAgICAgICAgICB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5yZWN1cnNpdmUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnZGVsZXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xufSkoRGVsZXRlRmlsZSB8fCAoRGVsZXRlRmlsZSA9IHt9KSk7XG5leHBvcnQgdmFyIFdvcmtzcGFjZUVkaXQ7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUVkaXQpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hhbmdlcyAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcy5ldmVyeSgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyhjaGFuZ2Uua2luZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUZpbGUuaXMoY2hhbmdlKSB8fCBSZW5hbWVGaWxlLmlzKGNoYW5nZSkgfHwgRGVsZXRlRmlsZS5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUVkaXQuaXMgPSBpcztcbn0pKFdvcmtzcGFjZUVkaXQgfHwgKFdvcmtzcGFjZUVkaXQgPSB7fSkpO1xuY2xhc3MgVGV4dEVkaXRDaGFuZ2VJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0cywgY2hhbmdlQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lZGl0cyA9IGVkaXRzO1xuICAgICAgICB0aGlzLmNoYW5nZUFubm90YXRpb25zID0gY2hhbmdlQW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKHJhbmdlLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBlZGl0O1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5kZWwocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LmRlbChyYW5nZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQoZWRpdCkge1xuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdHM7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmVkaXRzLnNwbGljZSgwLCB0aGlzLmVkaXRzLmxlbmd0aCk7XG4gICAgfVxuICAgIGFzc2VydENoYW5nZUFubm90YXRpb25zKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRleHQgZWRpdCBjaGFuZ2UgaXMgbm90IGNvbmZpZ3VyZWQgdG8gbWFuYWdlIGNoYW5nZSBhbm5vdGF0aW9ucy5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBoZWxwZXIgY2xhc3NcbiAqL1xuY2xhc3MgQ2hhbmdlQW5ub3RhdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKGFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICBtYW5hZ2UoaWRPckFubm90YXRpb24sIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoaWRPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGlkT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSB0aGlzLm5leHRJZCgpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IGlkT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbm5vdGF0aW9uc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJZCAke2lkfSBpcyBhbHJlYWR5IGluIHVzZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGFubm90YXRpb24gcHJvdmlkZWQgZm9yIGlkICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnNbaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIG5leHRJZCgpIHtcbiAgICAgICAgdGhpcy5fY291bnRlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5fY291bnRlci50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogQSB3b3Jrc3BhY2UgY2hhbmdlIGhlbHBzIGNvbnN0cnVjdGluZyBjaGFuZ2VzIHRvIGEgd29ya3NwYWNlLlxuICovXG5leHBvcnQgY2xhc3MgV29ya3NwYWNlQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih3b3Jrc3BhY2VFZGl0KSB7XG4gICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQgPSB3b3Jrc3BhY2VFZGl0O1xuICAgICAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgPSBuZXcgQ2hhbmdlQW5ub3RhdGlvbnMod29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNbY2hhbmdlLnRleHREb2N1bWVudC51cmldID0gdGV4dEVkaXRDaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdvcmtzcGFjZUVkaXQuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHdvcmtzcGFjZUVkaXQuY2hhbmdlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gdGV4dEVkaXRDaGFuZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgV29ya3NwYWNlRWRpdH0gbGl0ZXJhbFxuICAgICAqIHVzZSB0byBiZSByZXR1cm5lZCBmcm9tIGEgd29ya3NwYWNlIGVkaXQgb3BlcmF0aW9uIGxpa2UgcmVuYW1lLlxuICAgICAqL1xuICAgIGdldCBlZGl0KCkge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZUFubm90YXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya3NwYWNlRWRpdDtcbiAgICB9XG4gICAgZ2V0VGV4dEVkaXRDaGFuZ2Uoa2V5KSB7XG4gICAgICAgIGlmIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnQgPSB7IHVyaToga2V5LnVyaSwgdmVyc2lvbjoga2V5LnZlcnNpb24gfTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNbdGV4dERvY3VtZW50LnVyaV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50RWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBlZGl0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaCh0ZXh0RG9jdW1lbnRFZGl0KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzLCB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIG5vcm1hbCB0ZXh0IGVkaXQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0gPSBlZGl0cztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdERvY3VtZW50Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVGaWxlKHVyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVyYXRpb247XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmFtZUZpbGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gUmVuYW1lRmlsZS5jcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlRmlsZSh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhlIFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpIH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgdmVyc2lvbiB9O1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCB2ZXJzaW9uIH07XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUudmVyc2lvbiA9PT0gbnVsbCB8fCBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSk7XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50SXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCB0ZXh0IH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRJdGVtIHx8IChUZXh0RG9jdW1lbnRJdGVtID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIHRoZSBjb250ZW50IHR5cGUgdGhhdCBhIGNsaWVudCBzdXBwb3J0cyBpbiB2YXJpb3VzXG4gKiByZXN1bHQgbGl0ZXJhbHMgbGlrZSBgSG92ZXJgLCBgUGFyYW1ldGVySW5mb2Agb3IgYENvbXBsZXRpb25JdGVtYC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGBNYXJrdXBLaW5kc2AgbXVzdCBub3Qgc3RhcnQgd2l0aCBhIGAkYC4gVGhpcyBraW5kc1xuICogYXJlIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2FnZS5cbiAqL1xuZXhwb3J0IHZhciBNYXJrdXBLaW5kO1xuKGZ1bmN0aW9uIChNYXJrdXBLaW5kKSB7XG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dCBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuUGxhaW5UZXh0ID0gJ3BsYWludGV4dCc7XG4gICAgLyoqXG4gICAgICogTWFya2Rvd24gaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLk1hcmtkb3duID0gJ21hcmtkb3duJztcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWx1ZSBvZiB0aGUge0BsaW5rIE1hcmt1cEtpbmR9IHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgPT09IE1hcmt1cEtpbmQuUGxhaW5UZXh0IHx8IGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5NYXJrZG93bjtcbiAgICB9XG4gICAgTWFya3VwS2luZC5pcyA9IGlzO1xufSkoTWFya3VwS2luZCB8fCAoTWFya3VwS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIE1hcmt1cENvbnRlbnQ7XG4oZnVuY3Rpb24gKE1hcmt1cENvbnRlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrdXBDb250ZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKHZhbHVlKSAmJiBNYXJrdXBLaW5kLmlzKGNhbmRpZGF0ZS5raW5kKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKTtcbiAgICB9XG4gICAgTWFya3VwQ29udGVudC5pcyA9IGlzO1xufSkoTWFya3VwQ29udGVudCB8fCAoTWFya3VwQ29udGVudCA9IHt9KSk7XG4vKipcbiAqIFRoZSBraW5kIG9mIGEgY29tcGxldGlvbiBlbnRyeS5cbiAqL1xuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbUtpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UZXh0ID0gMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kID0gMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciA9IDQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkID0gNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyA9IDc7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSA9IDg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID0gMTA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgPSAxMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSA9IDEzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkID0gMTQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgPSAxNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSA9IDE3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyID0gMTk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgPSAyMDtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0ID0gMjI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkV2ZW50ID0gMjM7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNTtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyB3aGV0aGVyIHRoZSBpbnNlcnQgdGV4dCBpbiBhIGNvbXBsZXRpb24gaXRlbSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXNcbiAqIHBsYWluIHRleHQgb3IgYSBzbmlwcGV0LlxuICovXG5leHBvcnQgdmFyIEluc2VydFRleHRGb3JtYXQ7XG4oZnVuY3Rpb24gKEluc2VydFRleHRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHNuaXBwZXQuXG4gICAgICpcbiAgICAgKiBBIHNuaXBwZXQgY2FuIGRlZmluZSB0YWIgc3RvcHMgYW5kIHBsYWNlaG9sZGVycyB3aXRoIGAkMWAsIGAkMmBcbiAgICAgKiBhbmQgYCR7Mzpmb299YC4gYCQwYCBkZWZpbmVzIHRoZSBmaW5hbCB0YWIgc3RvcCwgaXQgZGVmYXVsdHMgdG9cbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBzbmlwcGV0LiBQbGFjZWhvbGRlcnMgd2l0aCBlcXVhbCBpZGVudGlmaWVycyBhcmUgbGlua2VkLFxuICAgICAqIHRoYXQgaXMgdHlwaW5nIGluIG9uZSB3aWxsIHVwZGF0ZSBvdGhlcnMgdG9vLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9sYW5ndWFnZS1zZXJ2ZXItcHJvdG9jb2wvc3BlY2lmaWNhdGlvbnMvc3BlY2lmaWNhdGlvbi1jdXJyZW50LyNzbmlwcGV0X3N5bnRheFxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XG59KShJbnNlcnRUZXh0Rm9ybWF0IHx8IChJbnNlcnRUZXh0Rm9ybWF0ID0ge30pKTtcbi8qKlxuICogQ29tcGxldGlvbiBpdGVtIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIGNvbXBsZXRpb25cbiAqIGl0ZW0uXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtVGFnO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbVRhZykge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIGNvbXBsZXRpb24gYXMgb2Jzb2xldGUsIHVzdWFsbHkgdXNpbmcgYSBzdHJpa2Utb3V0LlxuICAgICAqL1xuICAgIENvbXBsZXRpb25JdGVtVGFnLkRlcHJlY2F0ZWQgPSAxO1xufSkoQ29tcGxldGlvbkl0ZW1UYWcgfHwgKENvbXBsZXRpb25JdGVtVGFnID0ge30pKTtcbi8qKlxuICogVGhlIEluc2VydFJlcGxhY2VFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGluc2VydCAvIHJlcGxhY2UgZWRpdHMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG5leHBvcnQgdmFyIEluc2VydFJlcGxhY2VFZGl0O1xuKGZ1bmN0aW9uIChJbnNlcnRSZXBsYWNlRWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zZXJ0IC8gcmVwbGFjZSBlZGl0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbmV4cG9ydCB2YXIgSW5zZXJ0VGV4dE1vZGU7XG4oZnVuY3Rpb24gKEluc2VydFRleHRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluc2VydGlvbiBvciByZXBsYWNlIHN0cmluZ3MgaXMgdGFrZW4gYXMgaXQgaXMuIElmIHRoZVxuICAgICAqIHZhbHVlIGlzIG11bHRpIGxpbmUgdGhlIGxpbmVzIGJlbG93IHRoZSBjdXJzb3Igd2lsbCBiZVxuICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIG5vdCBhcHBseSBhbnkga2luZCBvZiBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYXNJcyA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAqIHRoZXkgbWF0Y2ggdGhlIGluZGVudGF0aW9uIHVwIHRvIHRoZSBjdXJzb3Igb2YgdGhlIGxpbmUgZm9yXG4gICAgICogd2hpY2ggdGhlIGl0ZW0gaXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhIGxpbmUgbGlrZSB0aGlzOiA8MnRhYnM+PGN1cnNvcj48M3RhYnM+Zm9vLiBBY2NlcHRpbmcgYVxuICAgICAqIG11bHRpIGxpbmUgY29tcGxldGlvbiBpdGVtIGlzIGluZGVudGVkIHVzaW5nIDIgdGFicyBhbmQgYWxsXG4gICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYWRqdXN0SW5kZW50YXRpb24gPSAyO1xufSkoSW5zZXJ0VGV4dE1vZGUgfHwgKEluc2VydFRleHRNb2RlID0ge30pKTtcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscy5pcyA9IGlzO1xufSkoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgfHwgKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBjb21wbGV0aW9uIGl0ZW0ncyBsYWJlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xuICAgICAgICByZXR1cm4geyBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29tcGxldGlvbkxpc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25MaXN0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb21wbGV0aW9uIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbXMgVGhlIGNvbXBsZXRpb24gaXRlbXMuXG4gICAgICogQHBhcmFtIGlzSW5jb21wbGV0ZSBUaGUgbGlzdCBpcyBub3QgY29tcGxldGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGl0ZW1zLCBpc0luY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHsgaXRlbXM6IGl0ZW1zID8gaXRlbXMgOiBbXSwgaXNJbmNvbXBsZXRlOiAhIWlzSW5jb21wbGV0ZSB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uTGlzdCB8fCAoQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuZXhwb3J0IHZhciBNYXJrZWRTdHJpbmc7XG4oZnVuY3Rpb24gKE1hcmtlZFN0cmluZykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXJrZWQgc3RyaW5nIGZyb20gcGxhaW4gdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbGFpblRleHQgVGhlIHBsYWluIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBsYWluVGV4dChwbGFpblRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBsYWluVGV4dC5yZXBsYWNlKC9bXFxcXGAqX3t9W1xcXSgpIytcXC0uIV0vZywgJ1xcXFwkJicpOyAvLyBlc2NhcGUgbWFya2Rvd24gc3ludGF4IHRva2VuczogaHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjYmFja3NsYXNoXG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5mcm9tUGxhaW5UZXh0ID0gZnJvbVBsYWluVGV4dDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrZWRTdHJpbmd9IHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlKSB8fCAoSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpKTtcbiAgICB9XG4gICAgTWFya2VkU3RyaW5nLmlzID0gaXM7XG59KShNYXJrZWRTdHJpbmcgfHwgKE1hcmtlZFN0cmluZyA9IHt9KSk7XG5leHBvcnQgdmFyIEhvdmVyO1xuKGZ1bmN0aW9uIChIb3Zlcikge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIEhvdmVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUgJiYgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS5jb250ZW50cykgfHxcbiAgICAgICAgICAgIE1hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcbiAgICB9XG4gICAgSG92ZXIuaXMgPSBpcztcbn0pKEhvdmVyIHx8IChIb3ZlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQYXJhbWV0ZXJJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIGxhYmVsIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbCwgZG9jdW1lbnRhdGlvbiB9IDogeyBsYWJlbCB9O1xuICAgIH1cbiAgICBQYXJhbWV0ZXJJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShQYXJhbWV0ZXJJbmZvcm1hdGlvbiB8fCAoUGFyYW1ldGVySW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgU2lnbmF0dXJlSW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgU2lnbmF0dXJlSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFNpZ25hdHVyZUluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTaWduYXR1cmVJbmZvcm1hdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbiwgLi4ucGFyYW1ldGVycykge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBsYWJlbCB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChkb2N1bWVudGF0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LmRvY3VtZW50YXRpb24gPSBkb2N1bWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFNpZ25hdHVyZUluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFNpZ25hdHVyZUluZm9ybWF0aW9uIHx8IChTaWduYXR1cmVJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXG4gKi9cbmV4cG9ydCB2YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5SZWFkID0gMjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZSA9IDM7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIERvY3VtZW50SGlnaGxpZ2h0IG5hbWVzcGFjZSB0byBwcm92aWRlIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIERvY3VtZW50SGlnaGxpZ2h0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERvY3VtZW50SGlnaGxpZ2h0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRoZSBoaWdobGlnaHQgYXBwbGllcyB0by5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUgaGlnaGxpZ2h0IGtpbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGtpbmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLm51bWJlcihraW5kKSkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50SGlnaGxpZ2h0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKERvY3VtZW50SGlnaGxpZ2h0IHx8IChEb2N1bWVudEhpZ2hsaWdodCA9IHt9KSk7XG4vKipcbiAqIEEgc3ltYm9sIGtpbmQuXG4gKi9cbmV4cG9ydCB2YXIgU3ltYm9sS2luZDtcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xuICAgIFN5bWJvbEtpbmQuRmlsZSA9IDE7XG4gICAgU3ltYm9sS2luZC5Nb2R1bGUgPSAyO1xuICAgIFN5bWJvbEtpbmQuTmFtZXNwYWNlID0gMztcbiAgICBTeW1ib2xLaW5kLlBhY2thZ2UgPSA0O1xuICAgIFN5bWJvbEtpbmQuQ2xhc3MgPSA1O1xuICAgIFN5bWJvbEtpbmQuTWV0aG9kID0gNjtcbiAgICBTeW1ib2xLaW5kLlByb3BlcnR5ID0gNztcbiAgICBTeW1ib2xLaW5kLkZpZWxkID0gODtcbiAgICBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yID0gOTtcbiAgICBTeW1ib2xLaW5kLkVudW0gPSAxMDtcbiAgICBTeW1ib2xLaW5kLkludGVyZmFjZSA9IDExO1xuICAgIFN5bWJvbEtpbmQuRnVuY3Rpb24gPSAxMjtcbiAgICBTeW1ib2xLaW5kLlZhcmlhYmxlID0gMTM7XG4gICAgU3ltYm9sS2luZC5Db25zdGFudCA9IDE0O1xuICAgIFN5bWJvbEtpbmQuU3RyaW5nID0gMTU7XG4gICAgU3ltYm9sS2luZC5OdW1iZXIgPSAxNjtcbiAgICBTeW1ib2xLaW5kLkJvb2xlYW4gPSAxNztcbiAgICBTeW1ib2xLaW5kLkFycmF5ID0gMTg7XG4gICAgU3ltYm9sS2luZC5PYmplY3QgPSAxOTtcbiAgICBTeW1ib2xLaW5kLktleSA9IDIwO1xuICAgIFN5bWJvbEtpbmQuTnVsbCA9IDIxO1xuICAgIFN5bWJvbEtpbmQuRW51bU1lbWJlciA9IDIyO1xuICAgIFN5bWJvbEtpbmQuU3RydWN0ID0gMjM7XG4gICAgU3ltYm9sS2luZC5FdmVudCA9IDI0O1xuICAgIFN5bWJvbEtpbmQuT3BlcmF0b3IgPSAyNTtcbiAgICBTeW1ib2xLaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNjtcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBTeW1ib2wgdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgc3ltYm9sLlxuICpcbiAqIEBzaW5jZSAzLjE2XG4gKi9cbmV4cG9ydCB2YXIgU3ltYm9sVGFnO1xuKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBzeW1ib2wgYXMgb2Jzb2xldGUsIHVzdWFsbHkgdXNpbmcgYSBzdHJpa2Utb3V0LlxuICAgICAqL1xuICAgIFN5bWJvbFRhZy5EZXByZWNhdGVkID0gMTtcbn0pKFN5bWJvbFRhZyB8fCAoU3ltYm9sVGFnID0ge30pKTtcbmV4cG9ydCB2YXIgU3ltYm9sSW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFN5bWJvbEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzeW1ib2wgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRoZSBsb2NhdGlvbiBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNvbnRhaW5lck5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbCBjb250YWluaW5nIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHJhbmdlLCB1cmksIGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgbG9jYXRpb246IHsgdXJpLCByYW5nZSB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb250YWluZXJOYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQuY29udGFpbmVyTmFtZSA9IGNvbnRhaW5lck5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU3ltYm9sSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU3ltYm9sSW5mb3JtYXRpb24gfHwgKFN5bWJvbEluZm9ybWF0aW9uID0ge30pKTtcbmV4cG9ydCB2YXIgV29ya3NwYWNlU3ltYm9sO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd29ya3NwYWNlIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgQW4gb3B0aW9ucyByYW5nZSBvZiB0aGUgbG9jYXRpb24uXG4gICAgICogQHJldHVybnMgQSBXb3Jrc3BhY2VTeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8geyBuYW1lLCBraW5kLCBsb2NhdGlvbjogeyB1cmksIHJhbmdlIH0gfVxuICAgICAgICAgICAgOiB7IG5hbWUsIGtpbmQsIGxvY2F0aW9uOiB7IHVyaSB9IH07XG4gICAgfVxuICAgIFdvcmtzcGFjZVN5bWJvbC5jcmVhdGUgPSBjcmVhdGU7XG59KShXb3Jrc3BhY2VTeW1ib2wgfHwgKFdvcmtzcGFjZVN5bWJvbCA9IHt9KSk7XG5leHBvcnQgdmFyIERvY3VtZW50U3ltYm9sO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25SYW5nZSBUaGUgc2VsZWN0aW9uUmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwgZGV0YWlsLCBraW5kLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50U3ltYm9sfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmXG4gICAgICAgICAgICBJcy5zdHJpbmcoY2FuZGlkYXRlLm5hbWUpICYmIElzLm51bWJlcihjYW5kaWRhdGUua2luZCkgJiZcbiAgICAgICAgICAgIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnNlbGVjdGlvblJhbmdlKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXRhaWwgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRlcHJlY2F0ZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5kZXByZWNhdGVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5jaGlsZHJlbikpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnRhZ3MgPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS50YWdzKSk7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmlzID0gaXM7XG59KShEb2N1bWVudFN5bWJvbCB8fCAoRG9jdW1lbnRTeW1ib2wgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIGNvZGUgYWN0aW9uIGtpbmRzXG4gKi9cbmV4cG9ydCB2YXIgQ29kZUFjdGlvbktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25LaW5kKSB7XG4gICAgLyoqXG4gICAgICogRW1wdHkga2luZC5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5FbXB0eSA9ICcnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcXVpY2tmaXggYWN0aW9uczogJ3F1aWNrZml4J1xuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlF1aWNrRml4ID0gJ3F1aWNrZml4JztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGFjdGlvbnM6ICdyZWZhY3RvcidcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvciA9ICdyZWZhY3Rvcic7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBleHRyYWN0aW9uIGFjdGlvbnM6ICdyZWZhY3Rvci5leHRyYWN0J1xuICAgICAqXG4gICAgICogRXhhbXBsZSBleHRyYWN0IGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIEV4dHJhY3QgbWV0aG9kXG4gICAgICogLSBFeHRyYWN0IGZ1bmN0aW9uXG4gICAgICogLSBFeHRyYWN0IHZhcmlhYmxlXG4gICAgICogLSBFeHRyYWN0IGludGVyZmFjZSBmcm9tIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvckV4dHJhY3QgPSAncmVmYWN0b3IuZXh0cmFjdCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBpbmxpbmUgYWN0aW9uczogJ3JlZmFjdG9yLmlubGluZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgaW5saW5lIGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIElubGluZSBmdW5jdGlvblxuICAgICAqIC0gSW5saW5lIHZhcmlhYmxlXG4gICAgICogLSBJbmxpbmUgY29uc3RhbnRcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9ySW5saW5lID0gJ3JlZmFjdG9yLmlubGluZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyByZXdyaXRlIGFjdGlvbnM6ICdyZWZhY3Rvci5yZXdyaXRlJ1xuICAgICAqXG4gICAgICogRXhhbXBsZSByZXdyaXRlIGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIENvbnZlcnQgSmF2YVNjcmlwdCBmdW5jdGlvbiB0byBjbGFzc1xuICAgICAqIC0gQWRkIG9yIHJlbW92ZSBwYXJhbWV0ZXJcbiAgICAgKiAtIEVuY2Fwc3VsYXRlIGZpZWxkXG4gICAgICogLSBNYWtlIG1ldGhvZCBzdGF0aWNcbiAgICAgKiAtIE1vdmUgbWV0aG9kIHRvIGJhc2UgY2xhc3NcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yUmV3cml0ZSA9ICdyZWZhY3Rvci5yZXdyaXRlJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHNvdXJjZSBhY3Rpb25zOiBgc291cmNlYFxuICAgICAqXG4gICAgICogU291cmNlIGNvZGUgYWN0aW9ucyBhcHBseSB0byB0aGUgZW50aXJlIGZpbGUuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlID0gJ3NvdXJjZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhbiBvcmdhbml6ZSBpbXBvcnRzIHNvdXJjZSBhY3Rpb246IGBzb3VyY2Uub3JnYW5pemVJbXBvcnRzYFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZU9yZ2FuaXplSW1wb3J0cyA9ICdzb3VyY2Uub3JnYW5pemVJbXBvcnRzJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIGF1dG8tZml4IHNvdXJjZSBhY3Rpb25zOiBgc291cmNlLmZpeEFsbGAuXG4gICAgICpcbiAgICAgKiBGaXggYWxsIGFjdGlvbnMgYXV0b21hdGljYWxseSBmaXggZXJyb3JzIHRoYXQgaGF2ZSBhIGNsZWFyIGZpeCB0aGF0IGRvIG5vdCByZXF1aXJlIHVzZXIgaW5wdXQuXG4gICAgICogVGhleSBzaG91bGQgbm90IHN1cHByZXNzIGVycm9ycyBvciBwZXJmb3JtIHVuc2FmZSBmaXhlcyBzdWNoIGFzIGdlbmVyYXRpbmcgbmV3IHR5cGVzIG9yIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNS4wXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlRml4QWxsID0gJ3NvdXJjZS5maXhBbGwnO1xufSkoQ29kZUFjdGlvbktpbmQgfHwgKENvZGVBY3Rpb25LaW5kID0ge30pKTtcbi8qKlxuICogVGhlIHJlYXNvbiB3aHkgY29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xuZXhwb3J0IHZhciBDb2RlQWN0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyIG9yIGJ5IGFuIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gY3VycmVudCBzZWxlY3Rpb24gaW4gYSBmaWxlIGNoYW5nZXMsIGJ1dCBjYW5cbiAgICAgKiBhbHNvIGJlIHRyaWdnZXJlZCB3aGVuIGZpbGUgY29udGVudCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMgPSAyO1xufSkoQ29kZUFjdGlvblRyaWdnZXJLaW5kIHx8IChDb2RlQWN0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUFjdGlvbkNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUFjdGlvbkNvbnRleHR9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIENvZGVBY3Rpb25Db250ZXh0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uQ29udGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUFjdGlvbkNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZGlhZ25vc3RpY3MsIG9ubHksIHRyaWdnZXJLaW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbmV4cG9ydCB2YXIgQ29kZUFjdGlvbjtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwga2luZE9yQ29tbWFuZE9yRWRpdCwga2luZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyB0aXRsZSB9O1xuICAgICAgICBsZXQgY2hlY2tLaW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBraW5kT3JDb21tYW5kT3JFZGl0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hlY2tLaW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZC5pcyhraW5kT3JDb21tYW5kT3JFZGl0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbW1hbmQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVkaXQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja0tpbmQgJiYga2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRpYWdub3N0aWNzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuZGlhZ25vc3RpY3MsIERpYWdub3N0aWMuaXMpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5jb21tYW5kICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuaXNQcmVmZXJyZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgPT09IHVuZGVmaW5lZCB8fCBXb3Jrc3BhY2VFZGl0LmlzKGNhbmRpZGF0ZS5lZGl0KSk7XG4gICAgfVxuICAgIENvZGVBY3Rpb24uaXMgPSBpcztcbn0pKENvZGVBY3Rpb24gfHwgKENvZGVBY3Rpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUxlbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUxlbnN9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIENvZGVMZW5zO1xuKGZ1bmN0aW9uIChDb2RlTGVucykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUxlbnMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlTGVucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlTGVuc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvbW1hbmQpIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcbiAgICB9XG4gICAgQ29kZUxlbnMuaXMgPSBpcztcbn0pKENvZGVMZW5zIHx8IChDb2RlTGVucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBGb3JtYXR0aW5nT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgRm9ybWF0dGluZ09wdGlvbnM7XG4oZnVuY3Rpb24gKEZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb3JtYXR0aW5nT3B0aW9ucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWJTaXplLCBpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZSwgaW5zZXJ0U3BhY2VzIH07XG4gICAgfVxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS50YWJTaXplKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pbnNlcnRTcGFjZXMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5pcyA9IGlzO1xufSkoRm9ybWF0dGluZ09wdGlvbnMgfHwgKEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIERvY3VtZW50TGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudExpbmt9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIERvY3VtZW50TGluaztcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEb2N1bWVudExpbmsgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRhcmdldCwgZGF0YSkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgdGFyZ2V0LCBkYXRhIH07XG4gICAgfVxuICAgIERvY3VtZW50TGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudExpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XG4gICAgfVxuICAgIERvY3VtZW50TGluay5pcyA9IGlzO1xufSkoRG9jdW1lbnRMaW5rIHx8IChEb2N1bWVudExpbmsgPSB7fSkpO1xuLyoqXG4gKiBUaGUgU2VsZWN0aW9uUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byB3b3JrIHdpdGhcbiAqIFNlbGVjdGlvblJhbmdlIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFNlbGVjdGlvblJhbmdlO1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2VsZWN0aW9uUmFuZ2VcbiAgICAgKiBAcGFyYW0gcmFuZ2UgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgYW4gb3B0aW9uYWwgcGFyZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBwYXJlbnQgfTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChjYW5kaWRhdGUucGFyZW50ID09PSB1bmRlZmluZWQgfHwgU2VsZWN0aW9uUmFuZ2UuaXMoY2FuZGlkYXRlLnBhcmVudCkpO1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5pcyA9IGlzO1xufSkoU2VsZWN0aW9uUmFuZ2UgfHwgKFNlbGVjdGlvblJhbmdlID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCB0b2tlbiB0eXBlcy4gVGhpcyBzZXQgaXMgbm90IGZpeGVkXG4gKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBTZW1hbnRpY1Rva2VuVHlwZXM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5UeXBlcykge1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm5hbWVzcGFjZVwiXSA9IFwibmFtZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGdlbmVyaWMgdHlwZS4gQWN0cyBhcyBhIGZhbGxiYWNrIGZvciB0eXBlcyB3aGljaCBjYW4ndCBiZSBtYXBwZWQgdG9cbiAgICAgKiBhIHNwZWNpZmljIHR5cGUgbGlrZSBjbGFzcyBvciBlbnVtLlxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVcIl0gPSBcInR5cGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjbGFzc1wiXSA9IFwiY2xhc3NcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiaW50ZXJmYWNlXCJdID0gXCJpbnRlcmZhY2VcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJzdHJ1Y3RcIl0gPSBcInN0cnVjdFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVQYXJhbWV0ZXJcIl0gPSBcInR5cGVQYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwYXJhbWV0ZXJcIl0gPSBcInBhcmFtZXRlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInZhcmlhYmxlXCJdID0gXCJ2YXJpYWJsZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInByb3BlcnR5XCJdID0gXCJwcm9wZXJ0eVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImVudW1NZW1iZXJcIl0gPSBcImVudW1NZW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtZXRob2RcIl0gPSBcIm1ldGhvZFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1hY3JvXCJdID0gXCJtYWNyb1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtb2RpZmllclwiXSA9IFwibW9kaWZpZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjb21tZW50XCJdID0gXCJjb21tZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInJlZ2V4cFwiXSA9IFwicmVnZXhwXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wib3BlcmF0b3JcIl0gPSBcIm9wZXJhdG9yXCI7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImRlY29yYXRvclwiXSA9IFwiZGVjb3JhdG9yXCI7XG59KShTZW1hbnRpY1Rva2VuVHlwZXMgfHwgKFNlbWFudGljVG9rZW5UeXBlcyA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gbW9kaWZpZXJzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG5leHBvcnQgdmFyIFNlbWFudGljVG9rZW5Nb2RpZmllcnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5Nb2RpZmllcnMpIHtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVjbGFyYXRpb25cIl0gPSBcImRlY2xhcmF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmluaXRpb25cIl0gPSBcImRlZmluaXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wicmVhZG9ubHlcIl0gPSBcInJlYWRvbmx5XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcInN0YXRpY1wiXSA9IFwic3RhdGljXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlcHJlY2F0ZWRcIl0gPSBcImRlcHJlY2F0ZWRcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYWJzdHJhY3RcIl0gPSBcImFic3RyYWN0XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImFzeW5jXCJdID0gXCJhc3luY1wiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJtb2RpZmljYXRpb25cIl0gPSBcIm1vZGlmaWNhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkb2N1bWVudGF0aW9uXCJdID0gXCJkb2N1bWVudGF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmF1bHRMaWJyYXJ5XCJdID0gXCJkZWZhdWx0TGlicmFyeVwiO1xufSkoU2VtYW50aWNUb2tlbk1vZGlmaWVycyB8fCAoU2VtYW50aWNUb2tlbk1vZGlmaWVycyA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBTZW1hbnRpY1Rva2VucztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLnJlc3VsdElkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5kYXRhKSAmJiAoY2FuZGlkYXRlLmRhdGEubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBjYW5kaWRhdGUuZGF0YVswXSA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBTZW1hbnRpY1Rva2Vucy5pcyA9IGlzO1xufSkoU2VtYW50aWNUb2tlbnMgfHwgKFNlbWFudGljVG9rZW5zID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZVRleHRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xuZXhwb3J0IHZhciBJbmxpbmVWYWx1ZVRleHQ7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVGV4dCB8fCAoSW5saW5lVmFsdWVUZXh0ID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG5leHBvcnQgdmFyIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVmFyaWFibGVMb29rdXApIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXAgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5jYXNlU2Vuc2l0aXZlTG9va3VwKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudmFyaWFibGVOYW1lKSB8fCBjYW5kaWRhdGUudmFyaWFibGVOYW1lID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIHx8IChJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xuZXhwb3J0IHZhciBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBleHByZXNzaW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5leHByZXNzaW9uKSB8fCBjYW5kaWRhdGUuZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24uaXMgPSBpcztcbn0pKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIHx8IChJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgSW5saW5lVmFsdWVDb250ZXh0fSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbmV4cG9ydCB2YXIgSW5saW5lVmFsdWVDb250ZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyh2YWx1ZS5zdG9wcGVkTG9jYXRpb24pO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUNvbnRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlQ29udGV4dCB8fCAoSW5saW5lVmFsdWVDb250ZXh0ID0ge30pKTtcbi8qKlxuICogSW5sYXkgaGludCBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbmV4cG9ydCB2YXIgSW5sYXlIaW50S2luZDtcbihmdW5jdGlvbiAoSW5sYXlIaW50S2luZCkge1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBmb3IgYSB0eXBlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5UeXBlID0gMTtcbiAgICAvKipcbiAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgaXMgZm9yIGEgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIElubGF5SGludEtpbmQuUGFyYW1ldGVyID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIElubGF5SGludEtpbmQuaXMgPSBpcztcbn0pKElubGF5SGludEtpbmQgfHwgKElubGF5SGludEtpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxheUhpbnRMYWJlbFBhcnQ7XG4oZnVuY3Rpb24gKElubGF5SGludExhYmVsUGFydCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRvb2x0aXAgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRvb2x0aXApIHx8IE1hcmt1cENvbnRlbnQuaXMoY2FuZGlkYXRlLnRvb2x0aXApKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sb2NhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIElubGF5SGludExhYmVsUGFydC5pcyA9IGlzO1xufSkoSW5sYXlIaW50TGFiZWxQYXJ0IHx8IChJbmxheUhpbnRMYWJlbFBhcnQgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBwb3NpdGlvbiwgbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmxhYmVsLCBJbmxheUhpbnRMYWJlbFBhcnQuaXMpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRleHRFZGl0cyA9PT0gdW5kZWZpbmVkKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS50ZXh0RWRpdHMsIFRleHRFZGl0LmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnQuaXMgPSBpcztcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcbmV4cG9ydCB2YXIgU3RyaW5nVmFsdWU7XG4oZnVuY3Rpb24gKFN0cmluZ1ZhbHVlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlU25pcHBldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBraW5kOiAnc25pcHBldCcsIHZhbHVlIH07XG4gICAgfVxuICAgIFN0cmluZ1ZhbHVlLmNyZWF0ZVNuaXBwZXQgPSBjcmVhdGVTbmlwcGV0O1xufSkoU3RyaW5nVmFsdWUgfHwgKFN0cmluZ1ZhbHVlID0ge30pKTtcbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvbkl0ZW07XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25JdGVtKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGluc2VydFRleHQsIGZpbHRlclRleHQsIHJhbmdlLCBjb21tYW5kKSB7XG4gICAgICAgIHJldHVybiB7IGluc2VydFRleHQsIGZpbHRlclRleHQsIHJhbmdlLCBjb21tYW5kIH07XG4gICAgfVxuICAgIElubGluZUNvbXBsZXRpb25JdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKElubGluZUNvbXBsZXRpb25JdGVtIHx8IChJbmxpbmVDb21wbGV0aW9uSXRlbSA9IHt9KSk7XG5leHBvcnQgdmFyIElubGluZUNvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uTGlzdCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcykge1xuICAgICAgICByZXR1cm4geyBpdGVtcyB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uTGlzdCB8fCAoSW5saW5lQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IGFuIHtAbGluayBJbmxpbmVDb21wbGV0aW9uSXRlbVByb3ZpZGVyIGlubGluZSBjb21wbGV0aW9uIHByb3ZpZGVyfSB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG5leHBvcnQgdmFyIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGV4cGxpY2l0bHkgYnkgYSB1c2VyIGdlc3R1cmUuXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kLkludm9rZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5IHdoaWxlIGVkaXRpbmcuXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyA9IDE7XG59KShJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIFNlbGVjdGVkQ29tcGxldGlvbkluZm87XG4oZnVuY3Rpb24gKFNlbGVjdGVkQ29tcGxldGlvbkluZm8pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHRleHQgfTtcbiAgICB9XG4gICAgU2VsZWN0ZWRDb21wbGV0aW9uSW5mby5jcmVhdGUgPSBjcmVhdGU7XG59KShTZWxlY3RlZENvbXBsZXRpb25JbmZvIHx8IChTZWxlY3RlZENvbXBsZXRpb25JbmZvID0ge30pKTtcbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25Db250ZXh0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiB7IHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvIH07XG4gICAgfVxuICAgIElubGluZUNvbXBsZXRpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKElubGluZUNvbXBsZXRpb25Db250ZXh0IHx8IChJbmxpbmVDb21wbGV0aW9uQ29udGV4dCA9IHt9KSk7XG5leHBvcnQgdmFyIFdvcmtzcGFjZUZvbGRlcjtcbihmdW5jdGlvbiAoV29ya3NwYWNlRm9sZGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgVVJJLmlzKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUZvbGRlci5pcyA9IGlzO1xufSkoV29ya3NwYWNlRm9sZGVyIHx8IChXb3Jrc3BhY2VGb2xkZXIgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IEVPTCA9IFsnXFxuJywgJ1xcclxcbicsICdcXHInXTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElUZXh0RG9jdW1lbnQgbGl0ZXJhbCBmcm9tIHRoZSBnaXZlbiB1cmkgYW5kIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgZG9jdW1lbnQncyBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJVGV4dERvY3VtZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZUNvdW50KVxuICAgICAgICAgICAgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZ2V0VGV4dCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUucG9zaXRpb25BdCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub2Zmc2V0QXQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgbGV0IHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBzb3J0ZWRFZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRPZmZzZXQgPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGUubmV3VGV4dCArIHRleHQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAvLyBzb3J0ZWRcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgICAgICBjb25zdCByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgICAgIG1lcmdlU29ydChsZWZ0LCBjb21wYXJlKTtcbiAgICAgICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgbGV0IGxlZnRJZHggPSAwO1xuICAgICAgICBsZXQgcmlnaHRJZHggPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgICAgICBpZiAocmV0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgdXBkYXRlKGV2ZW50LCB2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBldmVudC50ZXh0O1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgbGV0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICB9XG4gICAgb2Zmc2V0QXQocG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgbGV0IG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgfVxufVxudmFyIElzO1xuKGZ1bmN0aW9uIChJcykge1xuICAgIGNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG4iXSwibmFtZXMiOlsiRG9jdW1lbnRVcmkiLCJpcyIsInZhbHVlIiwiVVJJIiwiaW50ZWdlciIsIk1JTl9WQUxVRSIsIk1BWF9WQUxVRSIsInVpbnRlZ2VyIiwiUG9zaXRpb24iLCJjcmVhdGUiLCJsaW5lIiwiY2hhcmFjdGVyIiwiTnVtYmVyIiwiY2FuZGlkYXRlIiwiSXMiLCJvYmplY3RMaXRlcmFsIiwiUmFuZ2UiLCJvbmUiLCJ0d28iLCJ0aHJlZSIsImZvdXIiLCJzdGFydCIsImVuZCIsIkVycm9yIiwiTG9jYXRpb24iLCJ1cmkiLCJyYW5nZSIsInN0cmluZyIsInVuZGVmaW5lZCIsIkxvY2F0aW9uTGluayIsInRhcmdldFVyaSIsInRhcmdldFJhbmdlIiwidGFyZ2V0U2VsZWN0aW9uUmFuZ2UiLCJvcmlnaW5TZWxlY3Rpb25SYW5nZSIsIkNvbG9yIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwiYWxwaGEiLCJudW1iZXJSYW5nZSIsIkNvbG9ySW5mb3JtYXRpb24iLCJjb2xvciIsIkNvbG9yUHJlc2VudGF0aW9uIiwibGFiZWwiLCJ0ZXh0RWRpdCIsImFkZGl0aW9uYWxUZXh0RWRpdHMiLCJUZXh0RWRpdCIsInR5cGVkQXJyYXkiLCJGb2xkaW5nUmFuZ2VLaW5kIiwiQ29tbWVudCIsIkltcG9ydHMiLCJSZWdpb24iLCJGb2xkaW5nUmFuZ2UiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwic3RhcnRDaGFyYWN0ZXIiLCJlbmRDaGFyYWN0ZXIiLCJraW5kIiwiY29sbGFwc2VkVGV4dCIsInJlc3VsdCIsImRlZmluZWQiLCJEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIiwibG9jYXRpb24iLCJtZXNzYWdlIiwiRGlhZ25vc3RpY1NldmVyaXR5IiwiV2FybmluZyIsIkluZm9ybWF0aW9uIiwiSGludCIsIkRpYWdub3N0aWNUYWciLCJVbm5lY2Vzc2FyeSIsIkRlcHJlY2F0ZWQiLCJDb2RlRGVzY3JpcHRpb24iLCJocmVmIiwiRGlhZ25vc3RpYyIsInNldmVyaXR5IiwiY29kZSIsInNvdXJjZSIsInJlbGF0ZWRJbmZvcm1hdGlvbiIsIl9hIiwibnVtYmVyIiwiY29kZURlc2NyaXB0aW9uIiwiQ29tbWFuZCIsInRpdGxlIiwiY29tbWFuZCIsImFyZ3MiLCJsZW5ndGgiLCJhcmd1bWVudHMiLCJyZXBsYWNlIiwibmV3VGV4dCIsImluc2VydCIsInBvc2l0aW9uIiwiZGVsIiwiQ2hhbmdlQW5ub3RhdGlvbiIsIm5lZWRzQ29uZmlybWF0aW9uIiwiZGVzY3JpcHRpb24iLCJib29sZWFuIiwiQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIiLCJBbm5vdGF0ZWRUZXh0RWRpdCIsImFubm90YXRpb24iLCJhbm5vdGF0aW9uSWQiLCJUZXh0RG9jdW1lbnRFZGl0IiwidGV4dERvY3VtZW50IiwiZWRpdHMiLCJPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJBcnJheSIsImlzQXJyYXkiLCJDcmVhdGVGaWxlIiwib3B0aW9ucyIsIm92ZXJ3cml0ZSIsImlnbm9yZUlmRXhpc3RzIiwiUmVuYW1lRmlsZSIsIm9sZFVyaSIsIm5ld1VyaSIsIkRlbGV0ZUZpbGUiLCJyZWN1cnNpdmUiLCJpZ25vcmVJZk5vdEV4aXN0cyIsIldvcmtzcGFjZUVkaXQiLCJjaGFuZ2VzIiwiZG9jdW1lbnRDaGFuZ2VzIiwiZXZlcnkiLCJjaGFuZ2UiLCJUZXh0RWRpdENoYW5nZUltcGwiLCJjb25zdHJ1Y3RvciIsImNoYW5nZUFubm90YXRpb25zIiwiZWRpdCIsImlkIiwiYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnMiLCJtYW5hZ2UiLCJwdXNoIiwiZGVsZXRlIiwiYWRkIiwiYWxsIiwiY2xlYXIiLCJzcGxpY2UiLCJDaGFuZ2VBbm5vdGF0aW9ucyIsImFubm90YXRpb25zIiwiX2Fubm90YXRpb25zIiwiT2JqZWN0IiwiX2NvdW50ZXIiLCJfc2l6ZSIsInNpemUiLCJpZE9yQW5ub3RhdGlvbiIsIm5leHRJZCIsInRvU3RyaW5nIiwiV29ya3NwYWNlQ2hhbmdlIiwid29ya3NwYWNlRWRpdCIsIl90ZXh0RWRpdENoYW5nZXMiLCJfd29ya3NwYWNlRWRpdCIsIl9jaGFuZ2VBbm5vdGF0aW9ucyIsImZvckVhY2giLCJ0ZXh0RWRpdENoYW5nZSIsImtleXMiLCJrZXkiLCJpbml0RG9jdW1lbnRDaGFuZ2VzIiwiZ2V0VGV4dEVkaXRDaGFuZ2UiLCJ2ZXJzaW9uIiwidGV4dERvY3VtZW50RWRpdCIsImluaXRDaGFuZ2VzIiwiY3JlYXRlRmlsZSIsIm9wdGlvbnNPckFubm90YXRpb24iLCJvcGVyYXRpb24iLCJyZW5hbWVGaWxlIiwiZGVsZXRlRmlsZSIsIlRleHREb2N1bWVudElkZW50aWZpZXIiLCJWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiVGV4dERvY3VtZW50SXRlbSIsImxhbmd1YWdlSWQiLCJ0ZXh0IiwiTWFya3VwS2luZCIsIlBsYWluVGV4dCIsIk1hcmtkb3duIiwiTWFya3VwQ29udGVudCIsIkNvbXBsZXRpb25JdGVtS2luZCIsIlRleHQiLCJNZXRob2QiLCJGdW5jdGlvbiIsIkNvbnN0cnVjdG9yIiwiRmllbGQiLCJWYXJpYWJsZSIsIkNsYXNzIiwiSW50ZXJmYWNlIiwiTW9kdWxlIiwiUHJvcGVydHkiLCJVbml0IiwiVmFsdWUiLCJFbnVtIiwiS2V5d29yZCIsIlNuaXBwZXQiLCJGaWxlIiwiUmVmZXJlbmNlIiwiRm9sZGVyIiwiRW51bU1lbWJlciIsIkNvbnN0YW50IiwiU3RydWN0IiwiRXZlbnQiLCJPcGVyYXRvciIsIlR5cGVQYXJhbWV0ZXIiLCJJbnNlcnRUZXh0Rm9ybWF0IiwiQ29tcGxldGlvbkl0ZW1UYWciLCJJbnNlcnRSZXBsYWNlRWRpdCIsIkluc2VydFRleHRNb2RlIiwiYXNJcyIsImFkanVzdEluZGVudGF0aW9uIiwiQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMiLCJkZXRhaWwiLCJDb21wbGV0aW9uSXRlbSIsIkNvbXBsZXRpb25MaXN0IiwiaXRlbXMiLCJpc0luY29tcGxldGUiLCJNYXJrZWRTdHJpbmciLCJmcm9tUGxhaW5UZXh0IiwicGxhaW5UZXh0IiwibGFuZ3VhZ2UiLCJIb3ZlciIsImNvbnRlbnRzIiwiUGFyYW1ldGVySW5mb3JtYXRpb24iLCJkb2N1bWVudGF0aW9uIiwiU2lnbmF0dXJlSW5mb3JtYXRpb24iLCJwYXJhbWV0ZXJzIiwiRG9jdW1lbnRIaWdobGlnaHRLaW5kIiwiUmVhZCIsIldyaXRlIiwiRG9jdW1lbnRIaWdobGlnaHQiLCJTeW1ib2xLaW5kIiwiTmFtZXNwYWNlIiwiUGFja2FnZSIsIlN0cmluZyIsIkJvb2xlYW4iLCJLZXkiLCJOdWxsIiwiU3ltYm9sVGFnIiwiU3ltYm9sSW5mb3JtYXRpb24iLCJuYW1lIiwiY29udGFpbmVyTmFtZSIsIldvcmtzcGFjZVN5bWJvbCIsIkRvY3VtZW50U3ltYm9sIiwic2VsZWN0aW9uUmFuZ2UiLCJjaGlsZHJlbiIsImRlcHJlY2F0ZWQiLCJ0YWdzIiwiQ29kZUFjdGlvbktpbmQiLCJFbXB0eSIsIlF1aWNrRml4IiwiUmVmYWN0b3IiLCJSZWZhY3RvckV4dHJhY3QiLCJSZWZhY3RvcklubGluZSIsIlJlZmFjdG9yUmV3cml0ZSIsIlNvdXJjZSIsIlNvdXJjZU9yZ2FuaXplSW1wb3J0cyIsIlNvdXJjZUZpeEFsbCIsIkNvZGVBY3Rpb25UcmlnZ2VyS2luZCIsIkludm9rZWQiLCJBdXRvbWF0aWMiLCJDb2RlQWN0aW9uQ29udGV4dCIsImRpYWdub3N0aWNzIiwib25seSIsInRyaWdnZXJLaW5kIiwiQ29kZUFjdGlvbiIsImtpbmRPckNvbW1hbmRPckVkaXQiLCJjaGVja0tpbmQiLCJpc1ByZWZlcnJlZCIsIkNvZGVMZW5zIiwiZGF0YSIsIkZvcm1hdHRpbmdPcHRpb25zIiwidGFiU2l6ZSIsImluc2VydFNwYWNlcyIsIkRvY3VtZW50TGluayIsInRhcmdldCIsIlNlbGVjdGlvblJhbmdlIiwicGFyZW50IiwiU2VtYW50aWNUb2tlblR5cGVzIiwiU2VtYW50aWNUb2tlbk1vZGlmaWVycyIsIlNlbWFudGljVG9rZW5zIiwicmVzdWx0SWQiLCJJbmxpbmVWYWx1ZVRleHQiLCJJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIiwidmFyaWFibGVOYW1lIiwiY2FzZVNlbnNpdGl2ZUxvb2t1cCIsIklubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIiwiZXhwcmVzc2lvbiIsIklubGluZVZhbHVlQ29udGV4dCIsImZyYW1lSWQiLCJzdG9wcGVkTG9jYXRpb24iLCJJbmxheUhpbnRLaW5kIiwiVHlwZSIsIlBhcmFtZXRlciIsIklubGF5SGludExhYmVsUGFydCIsInRvb2x0aXAiLCJJbmxheUhpbnQiLCJ0ZXh0RWRpdHMiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsIlN0cmluZ1ZhbHVlIiwiY3JlYXRlU25pcHBldCIsIklubGluZUNvbXBsZXRpb25JdGVtIiwiaW5zZXJ0VGV4dCIsImZpbHRlclRleHQiLCJJbmxpbmVDb21wbGV0aW9uTGlzdCIsIklubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCIsIlNlbGVjdGVkQ29tcGxldGlvbkluZm8iLCJJbmxpbmVDb21wbGV0aW9uQ29udGV4dCIsInNlbGVjdGVkQ29tcGxldGlvbkluZm8iLCJXb3Jrc3BhY2VGb2xkZXIiLCJFT0wiLCJUZXh0RG9jdW1lbnQiLCJjb250ZW50IiwiRnVsbFRleHREb2N1bWVudCIsImxpbmVDb3VudCIsImZ1bmMiLCJnZXRUZXh0IiwicG9zaXRpb25BdCIsIm9mZnNldEF0IiwiYXBwbHlFZGl0cyIsImRvY3VtZW50Iiwic29ydGVkRWRpdHMiLCJtZXJnZVNvcnQiLCJhIiwiYiIsImRpZmYiLCJsYXN0TW9kaWZpZWRPZmZzZXQiLCJpIiwiZSIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0Iiwic3Vic3RyaW5nIiwiY29tcGFyZSIsInAiLCJsZWZ0Iiwic2xpY2UiLCJyaWdodCIsImxlZnRJZHgiLCJyaWdodElkeCIsInJldCIsIl91cmkiLCJfbGFuZ3VhZ2VJZCIsIl92ZXJzaW9uIiwiX2NvbnRlbnQiLCJfbGluZU9mZnNldHMiLCJ1cGRhdGUiLCJldmVudCIsImdldExpbmVPZmZzZXRzIiwibGluZU9mZnNldHMiLCJpc0xpbmVTdGFydCIsImNoIiwiY2hhckF0Iiwib2Zmc2V0IiwiTWF0aCIsIm1heCIsIm1pbiIsImxvdyIsImhpZ2giLCJtaWQiLCJmbG9vciIsImxpbmVPZmZzZXQiLCJuZXh0TGluZU9mZnNldCIsInByb3RvdHlwZSIsImNhbGwiLCJjaGVjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/vscode-languageserver-types/lib/esm/main.js\n");

/***/ })

};
;