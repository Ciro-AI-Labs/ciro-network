/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/layout-base";
exports.ids = ["vendor-chunks/layout-base"];
exports.modules = {

/***/ "(ssr)/./node_modules/layout-base/layout-base.js":
/*!*************************************************!*\
  !*** ./node_modules/layout-base/layout-base.js ***!
  \*************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(this, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_561__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_561__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_561__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_561__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_561__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_561__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_561__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_561__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_561__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_561__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_561__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_561__(__nested_webpack_require_561__.s = 26);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function LayoutConstants() {}\n            /**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */ LayoutConstants.QUALITY = 1;\n            /**\r\n * Default parameters\r\n */ LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\n            LayoutConstants.DEFAULT_INCREMENTAL = false;\n            LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\n            LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\n            LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\n            LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n            // -----------------------------------------------------------------------------\n            // Section: General other constants\n            // -----------------------------------------------------------------------------\n            /*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */ LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n            /*\r\n * Whether to consider labels in node dimensions or not\r\n */ LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n            /*\r\n * Default dimension of a non-compound node.\r\n */ LayoutConstants.SIMPLE_NODE_SIZE = 40;\n            /*\r\n * Default dimension of a non-compound node.\r\n */ LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n            /*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */ LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n            /*\r\n * Minimum length that an edge should take during layout\r\n */ LayoutConstants.MIN_EDGE_LENGTH = 1;\n            /*\r\n * World boundaries that layout operates on\r\n */ LayoutConstants.WORLD_BOUNDARY = 1000000;\n            /*\r\n * World boundaries that random positioning can be performed with\r\n */ LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n            /*\r\n * Coordinates of the world center\r\n */ LayoutConstants.WORLD_CENTER_X = 1200;\n            LayoutConstants.WORLD_CENTER_Y = 900;\n            module1.exports = LayoutConstants;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_5686__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_5686__(2);\n            var IGeometry = __nested_webpack_require_5686__(8);\n            var IMath = __nested_webpack_require_5686__(9);\n            function LEdge(source, target, vEdge) {\n                LGraphObject.call(this, vEdge);\n                this.isOverlapingSourceAndTarget = false;\n                this.vGraphObject = vEdge;\n                this.bendpoints = [];\n                this.source = source;\n                this.target = target;\n            }\n            LEdge.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LEdge[prop] = LGraphObject[prop];\n            }\n            LEdge.prototype.getSource = function() {\n                return this.source;\n            };\n            LEdge.prototype.getTarget = function() {\n                return this.target;\n            };\n            LEdge.prototype.isInterGraph = function() {\n                return this.isInterGraph;\n            };\n            LEdge.prototype.getLength = function() {\n                return this.length;\n            };\n            LEdge.prototype.isOverlapingSourceAndTarget = function() {\n                return this.isOverlapingSourceAndTarget;\n            };\n            LEdge.prototype.getBendpoints = function() {\n                return this.bendpoints;\n            };\n            LEdge.prototype.getLca = function() {\n                return this.lca;\n            };\n            LEdge.prototype.getSourceInLca = function() {\n                return this.sourceInLca;\n            };\n            LEdge.prototype.getTargetInLca = function() {\n                return this.targetInLca;\n            };\n            LEdge.prototype.getOtherEnd = function(node) {\n                if (this.source === node) {\n                    return this.target;\n                } else if (this.target === node) {\n                    return this.source;\n                } else {\n                    throw \"Node is not incident with this edge\";\n                }\n            };\n            LEdge.prototype.getOtherEndInGraph = function(node, graph) {\n                var otherEnd = this.getOtherEnd(node);\n                var root = graph.getGraphManager().getRoot();\n                while(true){\n                    if (otherEnd.getOwner() == graph) {\n                        return otherEnd;\n                    }\n                    if (otherEnd.getOwner() == root) {\n                        break;\n                    }\n                    otherEnd = otherEnd.getOwner().getParent();\n                }\n                return null;\n            };\n            LEdge.prototype.updateLength = function() {\n                var clipPointCoordinates = new Array(4);\n                this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n                if (!this.isOverlapingSourceAndTarget) {\n                    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n                    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n                    if (Math.abs(this.lengthX) < 1.0) {\n                        this.lengthX = IMath.sign(this.lengthX);\n                    }\n                    if (Math.abs(this.lengthY) < 1.0) {\n                        this.lengthY = IMath.sign(this.lengthY);\n                    }\n                    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n                }\n            };\n            LEdge.prototype.updateLengthSimple = function() {\n                this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n                this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n                if (Math.abs(this.lengthX) < 1.0) {\n                    this.lengthX = IMath.sign(this.lengthX);\n                }\n                if (Math.abs(this.lengthY) < 1.0) {\n                    this.lengthY = IMath.sign(this.lengthY);\n                }\n                this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n            };\n            module1.exports = LEdge;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function LGraphObject(vGraphObject) {\n                this.vGraphObject = vGraphObject;\n            }\n            module1.exports = LGraphObject;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_10226__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_10226__(2);\n            var Integer = __nested_webpack_require_10226__(10);\n            var RectangleD = __nested_webpack_require_10226__(13);\n            var LayoutConstants = __nested_webpack_require_10226__(0);\n            var RandomSeed = __nested_webpack_require_10226__(16);\n            var PointD = __nested_webpack_require_10226__(4);\n            function LNode(gm, loc, size, vNode) {\n                //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n                if (size == null && vNode == null) {\n                    vNode = loc;\n                }\n                LGraphObject.call(this, vNode);\n                //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n                if (gm.graphManager != null) gm = gm.graphManager;\n                this.estimatedSize = Integer.MIN_VALUE;\n                this.inclusionTreeDepth = Integer.MAX_VALUE;\n                this.vGraphObject = vNode;\n                this.edges = [];\n                this.graphManager = gm;\n                if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);\n                else this.rect = new RectangleD();\n            }\n            LNode.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LNode[prop] = LGraphObject[prop];\n            }\n            LNode.prototype.getEdges = function() {\n                return this.edges;\n            };\n            LNode.prototype.getChild = function() {\n                return this.child;\n            };\n            LNode.prototype.getOwner = function() {\n                //  if (this.owner != null) {\n                //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n                //      throw \"assert failed\";\n                //    }\n                //  }\n                return this.owner;\n            };\n            LNode.prototype.getWidth = function() {\n                return this.rect.width;\n            };\n            LNode.prototype.setWidth = function(width) {\n                this.rect.width = width;\n            };\n            LNode.prototype.getHeight = function() {\n                return this.rect.height;\n            };\n            LNode.prototype.setHeight = function(height) {\n                this.rect.height = height;\n            };\n            LNode.prototype.getCenterX = function() {\n                return this.rect.x + this.rect.width / 2;\n            };\n            LNode.prototype.getCenterY = function() {\n                return this.rect.y + this.rect.height / 2;\n            };\n            LNode.prototype.getCenter = function() {\n                return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n            };\n            LNode.prototype.getLocation = function() {\n                return new PointD(this.rect.x, this.rect.y);\n            };\n            LNode.prototype.getRect = function() {\n                return this.rect;\n            };\n            LNode.prototype.getDiagonal = function() {\n                return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n            };\n            /**\n * This method returns half the diagonal length of this node.\n */ LNode.prototype.getHalfTheDiagonal = function() {\n                return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n            };\n            LNode.prototype.setRect = function(upperLeft, dimension) {\n                this.rect.x = upperLeft.x;\n                this.rect.y = upperLeft.y;\n                this.rect.width = dimension.width;\n                this.rect.height = dimension.height;\n            };\n            LNode.prototype.setCenter = function(cx, cy) {\n                this.rect.x = cx - this.rect.width / 2;\n                this.rect.y = cy - this.rect.height / 2;\n            };\n            LNode.prototype.setLocation = function(x, y) {\n                this.rect.x = x;\n                this.rect.y = y;\n            };\n            LNode.prototype.moveBy = function(dx, dy) {\n                this.rect.x += dx;\n                this.rect.y += dy;\n            };\n            LNode.prototype.getEdgeListToNode = function(to) {\n                var edgeList = [];\n                var edge;\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (edge.target == to) {\n                        if (edge.source != self) throw \"Incorrect edge source!\";\n                        edgeList.push(edge);\n                    }\n                });\n                return edgeList;\n            };\n            LNode.prototype.getEdgesBetween = function(other) {\n                var edgeList = [];\n                var edge;\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n                    if (edge.target == other || edge.source == other) {\n                        edgeList.push(edge);\n                    }\n                });\n                return edgeList;\n            };\n            LNode.prototype.getNeighborsList = function() {\n                var neighbors = new Set();\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (edge.source == self) {\n                        neighbors.add(edge.target);\n                    } else {\n                        if (edge.target != self) {\n                            throw \"Incorrect incidency!\";\n                        }\n                        neighbors.add(edge.source);\n                    }\n                });\n                return neighbors;\n            };\n            LNode.prototype.withChildren = function() {\n                var withNeighborsList = new Set();\n                var childNode;\n                var children;\n                withNeighborsList.add(this);\n                if (this.child != null) {\n                    var nodes = this.child.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        childNode = nodes[i];\n                        children = childNode.withChildren();\n                        children.forEach(function(node) {\n                            withNeighborsList.add(node);\n                        });\n                    }\n                }\n                return withNeighborsList;\n            };\n            LNode.prototype.getNoOfChildren = function() {\n                var noOfChildren = 0;\n                var childNode;\n                if (this.child == null) {\n                    noOfChildren = 1;\n                } else {\n                    var nodes = this.child.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        childNode = nodes[i];\n                        noOfChildren += childNode.getNoOfChildren();\n                    }\n                }\n                if (noOfChildren == 0) {\n                    noOfChildren = 1;\n                }\n                return noOfChildren;\n            };\n            LNode.prototype.getEstimatedSize = function() {\n                if (this.estimatedSize == Integer.MIN_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.estimatedSize;\n            };\n            LNode.prototype.calcEstimatedSize = function() {\n                if (this.child == null) {\n                    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n                } else {\n                    this.estimatedSize = this.child.calcEstimatedSize();\n                    this.rect.width = this.estimatedSize;\n                    this.rect.height = this.estimatedSize;\n                    return this.estimatedSize;\n                }\n            };\n            LNode.prototype.scatter = function() {\n                var randomCenterX;\n                var randomCenterY;\n                var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n                var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n                this.rect.x = randomCenterX;\n                this.rect.y = randomCenterY;\n            };\n            LNode.prototype.updateBounds = function() {\n                if (this.getChild() == null) {\n                    throw \"assert failed\";\n                }\n                if (this.getChild().getNodes().length != 0) {\n                    // wrap the children nodes by re-arranging the boundaries\n                    var childGraph = this.getChild();\n                    childGraph.updateBounds(true);\n                    this.rect.x = childGraph.getLeft();\n                    this.rect.y = childGraph.getTop();\n                    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n                    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n                    // Update compound bounds considering its label properties    \n                    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                        var width = childGraph.getRight() - childGraph.getLeft();\n                        var height = childGraph.getBottom() - childGraph.getTop();\n                        if (this.labelWidth > width) {\n                            this.rect.x -= (this.labelWidth - width) / 2;\n                            this.setWidth(this.labelWidth);\n                        }\n                        if (this.labelHeight > height) {\n                            if (this.labelPos == \"center\") {\n                                this.rect.y -= (this.labelHeight - height) / 2;\n                            } else if (this.labelPos == \"top\") {\n                                this.rect.y -= this.labelHeight - height;\n                            }\n                            this.setHeight(this.labelHeight);\n                        }\n                    }\n                }\n            };\n            LNode.prototype.getInclusionTreeDepth = function() {\n                if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.inclusionTreeDepth;\n            };\n            LNode.prototype.transform = function(trans) {\n                var left = this.rect.x;\n                if (left > LayoutConstants.WORLD_BOUNDARY) {\n                    left = LayoutConstants.WORLD_BOUNDARY;\n                } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n                    left = -LayoutConstants.WORLD_BOUNDARY;\n                }\n                var top = this.rect.y;\n                if (top > LayoutConstants.WORLD_BOUNDARY) {\n                    top = LayoutConstants.WORLD_BOUNDARY;\n                } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n                    top = -LayoutConstants.WORLD_BOUNDARY;\n                }\n                var leftTop = new PointD(left, top);\n                var vLeftTop = trans.inverseTransformPoint(leftTop);\n                this.setLocation(vLeftTop.x, vLeftTop.y);\n            };\n            LNode.prototype.getLeft = function() {\n                return this.rect.x;\n            };\n            LNode.prototype.getRight = function() {\n                return this.rect.x + this.rect.width;\n            };\n            LNode.prototype.getTop = function() {\n                return this.rect.y;\n            };\n            LNode.prototype.getBottom = function() {\n                return this.rect.y + this.rect.height;\n            };\n            LNode.prototype.getParent = function() {\n                if (this.owner == null) {\n                    return null;\n                }\n                return this.owner.getParent();\n            };\n            module1.exports = LNode;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function PointD(x, y) {\n                if (x == null && y == null) {\n                    this.x = 0;\n                    this.y = 0;\n                } else {\n                    this.x = x;\n                    this.y = y;\n                }\n            }\n            PointD.prototype.getX = function() {\n                return this.x;\n            };\n            PointD.prototype.getY = function() {\n                return this.y;\n            };\n            PointD.prototype.setX = function(x) {\n                this.x = x;\n            };\n            PointD.prototype.setY = function(y) {\n                this.y = y;\n            };\n            PointD.prototype.getDifference = function(pt) {\n                return new DimensionD(this.x - pt.x, this.y - pt.y);\n            };\n            PointD.prototype.getCopy = function() {\n                return new PointD(this.x, this.y);\n            };\n            PointD.prototype.translate = function(dim) {\n                this.x += dim.width;\n                this.y += dim.height;\n                return this;\n            };\n            module1.exports = PointD;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_23732__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_23732__(2);\n            var Integer = __nested_webpack_require_23732__(10);\n            var LayoutConstants = __nested_webpack_require_23732__(0);\n            var LGraphManager = __nested_webpack_require_23732__(6);\n            var LNode = __nested_webpack_require_23732__(3);\n            var LEdge = __nested_webpack_require_23732__(1);\n            var RectangleD = __nested_webpack_require_23732__(13);\n            var Point1 = __nested_webpack_require_23732__(12);\n            var LinkedList = __nested_webpack_require_23732__(11);\n            function LGraph(parent, obj2, vGraph) {\n                LGraphObject.call(this, vGraph);\n                this.estimatedSize = Integer.MIN_VALUE;\n                this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n                this.edges = [];\n                this.nodes = [];\n                this.isConnected = false;\n                this.parent = parent;\n                if (obj2 != null && obj2 instanceof LGraphManager) {\n                    this.graphManager = obj2;\n                } else if (obj2 != null && obj2 instanceof Layout) {\n                    this.graphManager = obj2.graphManager;\n                }\n            }\n            LGraph.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LGraph[prop] = LGraphObject[prop];\n            }\n            LGraph.prototype.getNodes = function() {\n                return this.nodes;\n            };\n            LGraph.prototype.getEdges = function() {\n                return this.edges;\n            };\n            LGraph.prototype.getGraphManager = function() {\n                return this.graphManager;\n            };\n            LGraph.prototype.getParent = function() {\n                return this.parent;\n            };\n            LGraph.prototype.getLeft = function() {\n                return this.left;\n            };\n            LGraph.prototype.getRight = function() {\n                return this.right;\n            };\n            LGraph.prototype.getTop = function() {\n                return this.top;\n            };\n            LGraph.prototype.getBottom = function() {\n                return this.bottom;\n            };\n            LGraph.prototype.isConnected = function() {\n                return this.isConnected;\n            };\n            LGraph.prototype.add = function(obj1, sourceNode, targetNode) {\n                if (sourceNode == null && targetNode == null) {\n                    var newNode = obj1;\n                    if (this.graphManager == null) {\n                        throw \"Graph has no graph mgr!\";\n                    }\n                    if (this.getNodes().indexOf(newNode) > -1) {\n                        throw \"Node already in graph!\";\n                    }\n                    newNode.owner = this;\n                    this.getNodes().push(newNode);\n                    return newNode;\n                } else {\n                    var newEdge = obj1;\n                    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n                        throw \"Source or target not in graph!\";\n                    }\n                    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n                        throw \"Both owners must be this graph!\";\n                    }\n                    if (sourceNode.owner != targetNode.owner) {\n                        return null;\n                    }\n                    // set source and target\n                    newEdge.source = sourceNode;\n                    newEdge.target = targetNode;\n                    // set as intra-graph edge\n                    newEdge.isInterGraph = false;\n                    // add to graph edge list\n                    this.getEdges().push(newEdge);\n                    // add to incidency lists\n                    sourceNode.edges.push(newEdge);\n                    if (targetNode != sourceNode) {\n                        targetNode.edges.push(newEdge);\n                    }\n                    return newEdge;\n                }\n            };\n            LGraph.prototype.remove = function(obj) {\n                var node = obj;\n                if (obj instanceof LNode) {\n                    if (node == null) {\n                        throw \"Node is null!\";\n                    }\n                    if (!(node.owner != null && node.owner == this)) {\n                        throw \"Owner graph is invalid!\";\n                    }\n                    if (this.graphManager == null) {\n                        throw \"Owner graph manager is invalid!\";\n                    }\n                    // remove incident edges first (make a copy to do it safely)\n                    var edgesToBeRemoved = node.edges.slice();\n                    var edge;\n                    var s = edgesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        edge = edgesToBeRemoved[i];\n                        if (edge.isInterGraph) {\n                            this.graphManager.remove(edge);\n                        } else {\n                            edge.source.owner.remove(edge);\n                        }\n                    }\n                    // now the node itself\n                    var index = this.nodes.indexOf(node);\n                    if (index == -1) {\n                        throw \"Node not in owner node list!\";\n                    }\n                    this.nodes.splice(index, 1);\n                } else if (obj instanceof LEdge) {\n                    var edge = obj;\n                    if (edge == null) {\n                        throw \"Edge is null!\";\n                    }\n                    if (!(edge.source != null && edge.target != null)) {\n                        throw \"Source and/or target is null!\";\n                    }\n                    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n                        throw \"Source and/or target owner is invalid!\";\n                    }\n                    var sourceIndex = edge.source.edges.indexOf(edge);\n                    var targetIndex = edge.target.edges.indexOf(edge);\n                    if (!(sourceIndex > -1 && targetIndex > -1)) {\n                        throw \"Source and/or target doesn't know this edge!\";\n                    }\n                    edge.source.edges.splice(sourceIndex, 1);\n                    if (edge.target != edge.source) {\n                        edge.target.edges.splice(targetIndex, 1);\n                    }\n                    var index = edge.source.owner.getEdges().indexOf(edge);\n                    if (index == -1) {\n                        throw \"Not in owner's edge list!\";\n                    }\n                    edge.source.owner.getEdges().splice(index, 1);\n                }\n            };\n            LGraph.prototype.updateLeftTop = function() {\n                var top = Integer.MAX_VALUE;\n                var left = Integer.MAX_VALUE;\n                var nodeTop;\n                var nodeLeft;\n                var margin;\n                var nodes = this.getNodes();\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    nodeTop = lNode.getTop();\n                    nodeLeft = lNode.getLeft();\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                }\n                // Do we have any nodes in this graph?\n                if (top == Integer.MAX_VALUE) {\n                    return null;\n                }\n                if (nodes[0].getParent().paddingLeft != undefined) {\n                    margin = nodes[0].getParent().paddingLeft;\n                } else {\n                    margin = this.margin;\n                }\n                this.left = left - margin;\n                this.top = top - margin;\n                // Apply the margins and return the result\n                return new Point1(this.left, this.top);\n            };\n            LGraph.prototype.updateBounds = function(recursive) {\n                // calculate bounds\n                var left = Integer.MAX_VALUE;\n                var right = -Integer.MAX_VALUE;\n                var top = Integer.MAX_VALUE;\n                var bottom = -Integer.MAX_VALUE;\n                var nodeLeft;\n                var nodeRight;\n                var nodeTop;\n                var nodeBottom;\n                var margin;\n                var nodes = this.nodes;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    if (recursive && lNode.child != null) {\n                        lNode.updateBounds();\n                    }\n                    nodeLeft = lNode.getLeft();\n                    nodeRight = lNode.getRight();\n                    nodeTop = lNode.getTop();\n                    nodeBottom = lNode.getBottom();\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                        right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                        bottom = nodeBottom;\n                    }\n                }\n                var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n                if (left == Integer.MAX_VALUE) {\n                    this.left = this.parent.getLeft();\n                    this.right = this.parent.getRight();\n                    this.top = this.parent.getTop();\n                    this.bottom = this.parent.getBottom();\n                }\n                if (nodes[0].getParent().paddingLeft != undefined) {\n                    margin = nodes[0].getParent().paddingLeft;\n                } else {\n                    margin = this.margin;\n                }\n                this.left = boundingRect.x - margin;\n                this.right = boundingRect.x + boundingRect.width + margin;\n                this.top = boundingRect.y - margin;\n                this.bottom = boundingRect.y + boundingRect.height + margin;\n            };\n            LGraph.calculateBounds = function(nodes) {\n                var left = Integer.MAX_VALUE;\n                var right = -Integer.MAX_VALUE;\n                var top = Integer.MAX_VALUE;\n                var bottom = -Integer.MAX_VALUE;\n                var nodeLeft;\n                var nodeRight;\n                var nodeTop;\n                var nodeBottom;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    nodeLeft = lNode.getLeft();\n                    nodeRight = lNode.getRight();\n                    nodeTop = lNode.getTop();\n                    nodeBottom = lNode.getBottom();\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                        right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                        bottom = nodeBottom;\n                    }\n                }\n                var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n                return boundingRect;\n            };\n            LGraph.prototype.getInclusionTreeDepth = function() {\n                if (this == this.graphManager.getRoot()) {\n                    return 1;\n                } else {\n                    return this.parent.getInclusionTreeDepth();\n                }\n            };\n            LGraph.prototype.getEstimatedSize = function() {\n                if (this.estimatedSize == Integer.MIN_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.estimatedSize;\n            };\n            LGraph.prototype.calcEstimatedSize = function() {\n                var size = 0;\n                var nodes = this.nodes;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    size += lNode.calcEstimatedSize();\n                }\n                if (size == 0) {\n                    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n                } else {\n                    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n                }\n                return this.estimatedSize;\n            };\n            LGraph.prototype.updateConnected = function() {\n                var self = this;\n                if (this.nodes.length == 0) {\n                    this.isConnected = true;\n                    return;\n                }\n                var queue = new LinkedList();\n                var visited = new Set();\n                var currentNode = this.nodes[0];\n                var neighborEdges;\n                var currentNeighbor;\n                var childrenOfNode = currentNode.withChildren();\n                childrenOfNode.forEach(function(node) {\n                    queue.push(node);\n                    visited.add(node);\n                });\n                while(queue.length !== 0){\n                    currentNode = queue.shift();\n                    // Traverse all neighbors of this node\n                    neighborEdges = currentNode.getEdges();\n                    var size = neighborEdges.length;\n                    for(var i = 0; i < size; i++){\n                        var neighborEdge = neighborEdges[i];\n                        currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n                        // Add unvisited neighbors to the list to visit\n                        if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n                            var childrenOfNeighbor = currentNeighbor.withChildren();\n                            childrenOfNeighbor.forEach(function(node) {\n                                queue.push(node);\n                                visited.add(node);\n                            });\n                        }\n                    }\n                }\n                this.isConnected = false;\n                if (visited.size >= this.nodes.length) {\n                    var noOfVisitedInThisGraph = 0;\n                    visited.forEach(function(visitedNode) {\n                        if (visitedNode.owner == self) {\n                            noOfVisitedInThisGraph++;\n                        }\n                    });\n                    if (noOfVisitedInThisGraph == this.nodes.length) {\n                        this.isConnected = true;\n                    }\n                }\n            };\n            module1.exports = LGraph;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_38868__) {\n            \"use strict\";\n            var LGraph;\n            var LEdge = __nested_webpack_require_38868__(1);\n            function LGraphManager(layout) {\n                LGraph = __nested_webpack_require_38868__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n                this.layout = layout;\n                this.graphs = [];\n                this.edges = [];\n            }\n            LGraphManager.prototype.addRoot = function() {\n                var ngraph = this.layout.newGraph();\n                var nnode = this.layout.newNode(null);\n                var root = this.add(ngraph, nnode);\n                this.setRootGraph(root);\n                return this.rootGraph;\n            };\n            LGraphManager.prototype.add = function(newGraph, parentNode, newEdge, sourceNode, targetNode) {\n                //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n                if (newEdge == null && sourceNode == null && targetNode == null) {\n                    if (newGraph == null) {\n                        throw \"Graph is null!\";\n                    }\n                    if (parentNode == null) {\n                        throw \"Parent node is null!\";\n                    }\n                    if (this.graphs.indexOf(newGraph) > -1) {\n                        throw \"Graph already in this graph mgr!\";\n                    }\n                    this.graphs.push(newGraph);\n                    if (newGraph.parent != null) {\n                        throw \"Already has a parent!\";\n                    }\n                    if (parentNode.child != null) {\n                        throw \"Already has a child!\";\n                    }\n                    newGraph.parent = parentNode;\n                    parentNode.child = newGraph;\n                    return newGraph;\n                } else {\n                    //change the order of the parameters\n                    targetNode = newEdge;\n                    sourceNode = parentNode;\n                    newEdge = newGraph;\n                    var sourceGraph = sourceNode.getOwner();\n                    var targetGraph = targetNode.getOwner();\n                    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n                        throw \"Source not in this graph mgr!\";\n                    }\n                    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n                        throw \"Target not in this graph mgr!\";\n                    }\n                    if (sourceGraph == targetGraph) {\n                        newEdge.isInterGraph = false;\n                        return sourceGraph.add(newEdge, sourceNode, targetNode);\n                    } else {\n                        newEdge.isInterGraph = true;\n                        // set source and target\n                        newEdge.source = sourceNode;\n                        newEdge.target = targetNode;\n                        // add edge to inter-graph edge list\n                        if (this.edges.indexOf(newEdge) > -1) {\n                            throw \"Edge already in inter-graph edge list!\";\n                        }\n                        this.edges.push(newEdge);\n                        // add edge to source and target incidency lists\n                        if (!(newEdge.source != null && newEdge.target != null)) {\n                            throw \"Edge source and/or target is null!\";\n                        }\n                        if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n                            throw \"Edge already in source and/or target incidency list!\";\n                        }\n                        newEdge.source.edges.push(newEdge);\n                        newEdge.target.edges.push(newEdge);\n                        return newEdge;\n                    }\n                }\n            };\n            LGraphManager.prototype.remove = function(lObj) {\n                if (lObj instanceof LGraph) {\n                    var graph = lObj;\n                    if (graph.getGraphManager() != this) {\n                        throw \"Graph not in this graph mgr\";\n                    }\n                    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n                        throw \"Invalid parent node!\";\n                    }\n                    // first the edges (make a copy to do it safely)\n                    var edgesToBeRemoved = [];\n                    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n                    var edge;\n                    var s = edgesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        edge = edgesToBeRemoved[i];\n                        graph.remove(edge);\n                    }\n                    // then the nodes (make a copy to do it safely)\n                    var nodesToBeRemoved = [];\n                    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n                    var node;\n                    s = nodesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        node = nodesToBeRemoved[i];\n                        graph.remove(node);\n                    }\n                    // check if graph is the root\n                    if (graph == this.rootGraph) {\n                        this.setRootGraph(null);\n                    }\n                    // now remove the graph itself\n                    var index = this.graphs.indexOf(graph);\n                    this.graphs.splice(index, 1);\n                    // also reset the parent of the graph\n                    graph.parent = null;\n                } else if (lObj instanceof LEdge) {\n                    edge = lObj;\n                    if (edge == null) {\n                        throw \"Edge is null!\";\n                    }\n                    if (!edge.isInterGraph) {\n                        throw \"Not an inter-graph edge!\";\n                    }\n                    if (!(edge.source != null && edge.target != null)) {\n                        throw \"Source and/or target is null!\";\n                    }\n                    // remove edge from source and target nodes' incidency lists\n                    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n                        throw \"Source and/or target doesn't know this edge!\";\n                    }\n                    var index = edge.source.edges.indexOf(edge);\n                    edge.source.edges.splice(index, 1);\n                    index = edge.target.edges.indexOf(edge);\n                    edge.target.edges.splice(index, 1);\n                    // remove edge from owner graph manager's inter-graph edge list\n                    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n                        throw \"Edge owner graph or owner graph manager is null!\";\n                    }\n                    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n                        throw \"Not in owner graph manager's edge list!\";\n                    }\n                    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n                    edge.source.owner.getGraphManager().edges.splice(index, 1);\n                }\n            };\n            LGraphManager.prototype.updateBounds = function() {\n                this.rootGraph.updateBounds(true);\n            };\n            LGraphManager.prototype.getGraphs = function() {\n                return this.graphs;\n            };\n            LGraphManager.prototype.getAllNodes = function() {\n                if (this.allNodes == null) {\n                    var nodeList = [];\n                    var graphs = this.getGraphs();\n                    var s = graphs.length;\n                    for(var i = 0; i < s; i++){\n                        nodeList = nodeList.concat(graphs[i].getNodes());\n                    }\n                    this.allNodes = nodeList;\n                }\n                return this.allNodes;\n            };\n            LGraphManager.prototype.resetAllNodes = function() {\n                this.allNodes = null;\n            };\n            LGraphManager.prototype.resetAllEdges = function() {\n                this.allEdges = null;\n            };\n            LGraphManager.prototype.resetAllNodesToApplyGravitation = function() {\n                this.allNodesToApplyGravitation = null;\n            };\n            LGraphManager.prototype.getAllEdges = function() {\n                if (this.allEdges == null) {\n                    var edgeList = [];\n                    var graphs = this.getGraphs();\n                    var s = graphs.length;\n                    for(var i = 0; i < graphs.length; i++){\n                        edgeList = edgeList.concat(graphs[i].getEdges());\n                    }\n                    edgeList = edgeList.concat(this.edges);\n                    this.allEdges = edgeList;\n                }\n                return this.allEdges;\n            };\n            LGraphManager.prototype.getAllNodesToApplyGravitation = function() {\n                return this.allNodesToApplyGravitation;\n            };\n            LGraphManager.prototype.setAllNodesToApplyGravitation = function(nodeList) {\n                if (this.allNodesToApplyGravitation != null) {\n                    throw \"assert failed\";\n                }\n                this.allNodesToApplyGravitation = nodeList;\n            };\n            LGraphManager.prototype.getRoot = function() {\n                return this.rootGraph;\n            };\n            LGraphManager.prototype.setRootGraph = function(graph) {\n                if (graph.getGraphManager() != this) {\n                    throw \"Root not in this graph mgr!\";\n                }\n                this.rootGraph = graph;\n                // root graph must have a root node associated with it for convenience\n                if (graph.parent == null) {\n                    graph.parent = this.layout.newNode(\"Root node\");\n                }\n            };\n            LGraphManager.prototype.getLayout = function() {\n                return this.layout;\n            };\n            LGraphManager.prototype.isOneAncestorOfOther = function(firstNode, secondNode) {\n                if (!(firstNode != null && secondNode != null)) {\n                    throw \"assert failed\";\n                }\n                if (firstNode == secondNode) {\n                    return true;\n                }\n                // Is second node an ancestor of the first one?\n                var ownerGraph = firstNode.getOwner();\n                var parentNode;\n                do {\n                    parentNode = ownerGraph.getParent();\n                    if (parentNode == null) {\n                        break;\n                    }\n                    if (parentNode == secondNode) {\n                        return true;\n                    }\n                    ownerGraph = parentNode.getOwner();\n                    if (ownerGraph == null) {\n                        break;\n                    }\n                }while (true);\n                // Is first node an ancestor of the second one?\n                ownerGraph = secondNode.getOwner();\n                do {\n                    parentNode = ownerGraph.getParent();\n                    if (parentNode == null) {\n                        break;\n                    }\n                    if (parentNode == firstNode) {\n                        return true;\n                    }\n                    ownerGraph = parentNode.getOwner();\n                    if (ownerGraph == null) {\n                        break;\n                    }\n                }while (true);\n                return false;\n            };\n            LGraphManager.prototype.calcLowestCommonAncestors = function() {\n                var edge;\n                var sourceNode;\n                var targetNode;\n                var sourceAncestorGraph;\n                var targetAncestorGraph;\n                var edges = this.getAllEdges();\n                var s = edges.length;\n                for(var i = 0; i < s; i++){\n                    edge = edges[i];\n                    sourceNode = edge.source;\n                    targetNode = edge.target;\n                    edge.lca = null;\n                    edge.sourceInLca = sourceNode;\n                    edge.targetInLca = targetNode;\n                    if (sourceNode == targetNode) {\n                        edge.lca = sourceNode.getOwner();\n                        continue;\n                    }\n                    sourceAncestorGraph = sourceNode.getOwner();\n                    while(edge.lca == null){\n                        edge.targetInLca = targetNode;\n                        targetAncestorGraph = targetNode.getOwner();\n                        while(edge.lca == null){\n                            if (targetAncestorGraph == sourceAncestorGraph) {\n                                edge.lca = targetAncestorGraph;\n                                break;\n                            }\n                            if (targetAncestorGraph == this.rootGraph) {\n                                break;\n                            }\n                            if (edge.lca != null) {\n                                throw \"assert failed\";\n                            }\n                            edge.targetInLca = targetAncestorGraph.getParent();\n                            targetAncestorGraph = edge.targetInLca.getOwner();\n                        }\n                        if (sourceAncestorGraph == this.rootGraph) {\n                            break;\n                        }\n                        if (edge.lca == null) {\n                            edge.sourceInLca = sourceAncestorGraph.getParent();\n                            sourceAncestorGraph = edge.sourceInLca.getOwner();\n                        }\n                    }\n                    if (edge.lca == null) {\n                        throw \"assert failed\";\n                    }\n                }\n            };\n            LGraphManager.prototype.calcLowestCommonAncestor = function(firstNode, secondNode) {\n                if (firstNode == secondNode) {\n                    return firstNode.getOwner();\n                }\n                var firstOwnerGraph = firstNode.getOwner();\n                do {\n                    if (firstOwnerGraph == null) {\n                        break;\n                    }\n                    var secondOwnerGraph = secondNode.getOwner();\n                    do {\n                        if (secondOwnerGraph == null) {\n                            break;\n                        }\n                        if (secondOwnerGraph == firstOwnerGraph) {\n                            return secondOwnerGraph;\n                        }\n                        secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n                    }while (true);\n                    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n                }while (true);\n                return firstOwnerGraph;\n            };\n            LGraphManager.prototype.calcInclusionTreeDepths = function(graph, depth) {\n                if (graph == null && depth == null) {\n                    graph = this.rootGraph;\n                    depth = 1;\n                }\n                var node;\n                var nodes = graph.getNodes();\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    node = nodes[i];\n                    node.inclusionTreeDepth = depth;\n                    if (node.child != null) {\n                        this.calcInclusionTreeDepths(node.child, depth + 1);\n                    }\n                }\n            };\n            LGraphManager.prototype.includesInvalidEdge = function() {\n                var edge;\n                var s = this.edges.length;\n                for(var i = 0; i < s; i++){\n                    edge = this.edges[i];\n                    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n            module1.exports = LGraphManager;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_55302__) {\n            \"use strict\";\n            var LayoutConstants = __nested_webpack_require_55302__(0);\n            function FDLayoutConstants() {}\n            //FDLayoutConstants inherits static props in LayoutConstants\n            for(var prop in LayoutConstants){\n                FDLayoutConstants[prop] = LayoutConstants[prop];\n            }\n            FDLayoutConstants.MAX_ITERATIONS = 2500;\n            FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n            FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\n            FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\n            FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\n            FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\n            FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\n            FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\n            FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\n            FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\n            FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n            FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\n            FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\n            FDLayoutConstants.MIN_EDGE_LENGTH = 1;\n            FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n            module1.exports = FDLayoutConstants;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_57249__) {\n            \"use strict\";\n            /**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */ var Point1 = __nested_webpack_require_57249__(12);\n            function IGeometry() {}\n            /**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */ IGeometry.calcSeparationAmount = function(rectA, rectB, overlapAmount, separationBuffer) {\n                if (!rectA.intersects(rectB)) {\n                    throw \"assert failed\";\n                }\n                var directions = new Array(2);\n                this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n                overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n                overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n                // update the overlapping amounts for the following cases:\n                if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n                    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */ overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n                } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n                    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */ overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n                }\n                if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n                    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */ overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n                } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n                    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */ overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n                }\n                // find slope of the line passes two centers\n                var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n                // if centers are overlapped\n                if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n                    // assume the slope is 1 (45 degree)\n                    slope = 1.0;\n                }\n                var moveByY = slope * overlapAmount[0];\n                var moveByX = overlapAmount[1] / slope;\n                if (overlapAmount[0] < moveByX) {\n                    moveByX = overlapAmount[0];\n                } else {\n                    moveByY = overlapAmount[1];\n                }\n                // return half the amount so that if each rectangle is moved by these\n                // amounts in opposite directions, overlap will be resolved\n                overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n                overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n            };\n            /**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */ IGeometry.decideDirectionsForOverlappingNodes = function(rectA, rectB, directions) {\n                if (rectA.getCenterX() < rectB.getCenterX()) {\n                    directions[0] = -1;\n                } else {\n                    directions[0] = 1;\n                }\n                if (rectA.getCenterY() < rectB.getCenterY()) {\n                    directions[1] = -1;\n                } else {\n                    directions[1] = 1;\n                }\n            };\n            /**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */ IGeometry.getIntersection2 = function(rectA, rectB, result) {\n                //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n                var p1x = rectA.getCenterX();\n                var p1y = rectA.getCenterY();\n                var p2x = rectB.getCenterX();\n                var p2y = rectB.getCenterY();\n                //if two rectangles intersect, then clipping points are centers\n                if (rectA.intersects(rectB)) {\n                    result[0] = p1x;\n                    result[1] = p1y;\n                    result[2] = p2x;\n                    result[3] = p2y;\n                    return true;\n                }\n                //variables for rectA\n                var topLeftAx = rectA.getX();\n                var topLeftAy = rectA.getY();\n                var topRightAx = rectA.getRight();\n                var bottomLeftAx = rectA.getX();\n                var bottomLeftAy = rectA.getBottom();\n                var bottomRightAx = rectA.getRight();\n                var halfWidthA = rectA.getWidthHalf();\n                var halfHeightA = rectA.getHeightHalf();\n                //variables for rectB\n                var topLeftBx = rectB.getX();\n                var topLeftBy = rectB.getY();\n                var topRightBx = rectB.getRight();\n                var bottomLeftBx = rectB.getX();\n                var bottomLeftBy = rectB.getBottom();\n                var bottomRightBx = rectB.getRight();\n                var halfWidthB = rectB.getWidthHalf();\n                var halfHeightB = rectB.getHeightHalf();\n                //flag whether clipping points are found\n                var clipPointAFound = false;\n                var clipPointBFound = false;\n                // line is vertical\n                if (p1x === p2x) {\n                    if (p1y > p2y) {\n                        result[0] = p1x;\n                        result[1] = topLeftAy;\n                        result[2] = p2x;\n                        result[3] = bottomLeftBy;\n                        return false;\n                    } else if (p1y < p2y) {\n                        result[0] = p1x;\n                        result[1] = bottomLeftAy;\n                        result[2] = p2x;\n                        result[3] = topLeftBy;\n                        return false;\n                    } else {\n                    //not line, return null;\n                    }\n                } else if (p1y === p2y) {\n                    if (p1x > p2x) {\n                        result[0] = topLeftAx;\n                        result[1] = p1y;\n                        result[2] = topRightBx;\n                        result[3] = p2y;\n                        return false;\n                    } else if (p1x < p2x) {\n                        result[0] = topRightAx;\n                        result[1] = p1y;\n                        result[2] = topLeftBx;\n                        result[3] = p2y;\n                        return false;\n                    } else {\n                    //not valid line, return null;\n                    }\n                } else {\n                    //slopes of rectA's and rectB's diagonals\n                    var slopeA = rectA.height / rectA.width;\n                    var slopeB = rectB.height / rectB.width;\n                    //slope of line between center of rectA and center of rectB\n                    var slopePrime = (p2y - p1y) / (p2x - p1x);\n                    var cardinalDirectionA = void 0;\n                    var cardinalDirectionB = void 0;\n                    var tempPointAx = void 0;\n                    var tempPointAy = void 0;\n                    var tempPointBx = void 0;\n                    var tempPointBy = void 0;\n                    //determine whether clipping point is the corner of nodeA\n                    if (-slopeA === slopePrime) {\n                        if (p1x > p2x) {\n                            result[0] = bottomLeftAx;\n                            result[1] = bottomLeftAy;\n                            clipPointAFound = true;\n                        } else {\n                            result[0] = topRightAx;\n                            result[1] = topLeftAy;\n                            clipPointAFound = true;\n                        }\n                    } else if (slopeA === slopePrime) {\n                        if (p1x > p2x) {\n                            result[0] = topLeftAx;\n                            result[1] = topLeftAy;\n                            clipPointAFound = true;\n                        } else {\n                            result[0] = bottomRightAx;\n                            result[1] = bottomLeftAy;\n                            clipPointAFound = true;\n                        }\n                    }\n                    //determine whether clipping point is the corner of nodeB\n                    if (-slopeB === slopePrime) {\n                        if (p2x > p1x) {\n                            result[2] = bottomLeftBx;\n                            result[3] = bottomLeftBy;\n                            clipPointBFound = true;\n                        } else {\n                            result[2] = topRightBx;\n                            result[3] = topLeftBy;\n                            clipPointBFound = true;\n                        }\n                    } else if (slopeB === slopePrime) {\n                        if (p2x > p1x) {\n                            result[2] = topLeftBx;\n                            result[3] = topLeftBy;\n                            clipPointBFound = true;\n                        } else {\n                            result[2] = bottomRightBx;\n                            result[3] = bottomLeftBy;\n                            clipPointBFound = true;\n                        }\n                    }\n                    //if both clipping points are corners\n                    if (clipPointAFound && clipPointBFound) {\n                        return false;\n                    }\n                    //determine Cardinal Direction of rectangles\n                    if (p1x > p2x) {\n                        if (p1y > p2y) {\n                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n                        } else {\n                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n                        }\n                    } else {\n                        if (p1y > p2y) {\n                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n                        } else {\n                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n                        }\n                    }\n                    //calculate clipping Point if it is not found before\n                    if (!clipPointAFound) {\n                        switch(cardinalDirectionA){\n                            case 1:\n                                tempPointAy = topLeftAy;\n                                tempPointAx = p1x + -halfHeightA / slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 2:\n                                tempPointAx = bottomRightAx;\n                                tempPointAy = p1y + halfWidthA * slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 3:\n                                tempPointAy = bottomLeftAy;\n                                tempPointAx = p1x + halfHeightA / slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 4:\n                                tempPointAx = bottomLeftAx;\n                                tempPointAy = p1y + -halfWidthA * slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                        }\n                    }\n                    if (!clipPointBFound) {\n                        switch(cardinalDirectionB){\n                            case 1:\n                                tempPointBy = topLeftBy;\n                                tempPointBx = p2x + -halfHeightB / slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 2:\n                                tempPointBx = bottomRightBx;\n                                tempPointBy = p2y + halfWidthB * slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 3:\n                                tempPointBy = bottomLeftBy;\n                                tempPointBx = p2x + halfHeightB / slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 4:\n                                tempPointBx = bottomLeftBx;\n                                tempPointBy = p2y + -halfWidthB * slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                        }\n                    }\n                }\n                return false;\n            };\n            /**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */ IGeometry.getCardinalDirection = function(slope, slopePrime, line) {\n                if (slope > slopePrime) {\n                    return line;\n                } else {\n                    return 1 + line % 4;\n                }\n            };\n            /**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */ IGeometry.getIntersection = function(s1, s2, f1, f2) {\n                if (f2 == null) {\n                    return this.getIntersection2(s1, s2, f1);\n                }\n                var x1 = s1.x;\n                var y1 = s1.y;\n                var x2 = s2.x;\n                var y2 = s2.y;\n                var x3 = f1.x;\n                var y3 = f1.y;\n                var x4 = f2.x;\n                var y4 = f2.y;\n                var x = void 0, y = void 0; // intersection point\n                var a1 = void 0, a2 = void 0, b1 = void 0, b2 = void 0, c1 = void 0, c2 = void 0; // coefficients of line eqns.\n                var denom = void 0;\n                a1 = y2 - y1;\n                b1 = x1 - x2;\n                c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n                a2 = y4 - y3;\n                b2 = x3 - x4;\n                c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n                denom = a1 * b2 - a2 * b1;\n                if (denom === 0) {\n                    return null;\n                }\n                x = (b1 * c2 - b2 * c1) / denom;\n                y = (a2 * c1 - a1 * c2) / denom;\n                return new Point1(x, y);\n            };\n            /**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */ IGeometry.angleOfVector = function(Cx, Cy, Nx, Ny) {\n                var C_angle = void 0;\n                if (Cx !== Nx) {\n                    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n                    if (Nx < Cx) {\n                        C_angle += Math.PI;\n                    } else if (Ny < Cy) {\n                        C_angle += this.TWO_PI;\n                    }\n                } else if (Ny < Cy) {\n                    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n                } else {\n                    C_angle = this.HALF_PI; // 90 degrees\n                }\n                return C_angle;\n            };\n            /**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */ IGeometry.doIntersect = function(p1, p2, p3, p4) {\n                var a = p1.x;\n                var b = p1.y;\n                var c = p2.x;\n                var d = p2.y;\n                var p = p3.x;\n                var q = p3.y;\n                var r = p4.x;\n                var s = p4.y;\n                var det = (c - a) * (s - q) - (r - p) * (d - b);\n                if (det === 0) {\n                    return false;\n                } else {\n                    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n                    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n                    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n                }\n            };\n            // -----------------------------------------------------------------------------\n            // Section: Class Constants\n            // -----------------------------------------------------------------------------\n            /**\n * Some useful pre-calculated constants\n */ IGeometry.HALF_PI = 0.5 * Math.PI;\n            IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\n            IGeometry.TWO_PI = 2.0 * Math.PI;\n            IGeometry.THREE_PI = 3.0 * Math.PI;\n            module1.exports = IGeometry;\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function IMath() {}\n            /**\n * This method returns the sign of the input value.\n */ IMath.sign = function(value) {\n                if (value > 0) {\n                    return 1;\n                } else if (value < 0) {\n                    return -1;\n                } else {\n                    return 0;\n                }\n            };\n            IMath.floor = function(value) {\n                return value < 0 ? Math.ceil(value) : Math.floor(value);\n            };\n            IMath.ceil = function(value) {\n                return value < 0 ? Math.floor(value) : Math.ceil(value);\n            };\n            module1.exports = IMath;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function Integer() {}\n            Integer.MAX_VALUE = 2147483647;\n            Integer.MIN_VALUE = -2147483648;\n            module1.exports = Integer;\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var nodeFrom = function nodeFrom(value) {\n                return {\n                    value: value,\n                    next: null,\n                    prev: null\n                };\n            };\n            var add = function add(prev, node, next, list) {\n                if (prev !== null) {\n                    prev.next = node;\n                } else {\n                    list.head = node;\n                }\n                if (next !== null) {\n                    next.prev = node;\n                } else {\n                    list.tail = node;\n                }\n                node.prev = prev;\n                node.next = next;\n                list.length++;\n                return node;\n            };\n            var _remove = function _remove(node, list) {\n                var prev = node.prev, next = node.next;\n                if (prev !== null) {\n                    prev.next = next;\n                } else {\n                    list.head = next;\n                }\n                if (next !== null) {\n                    next.prev = prev;\n                } else {\n                    list.tail = prev;\n                }\n                node.prev = node.next = null;\n                list.length--;\n                return node;\n            };\n            var LinkedList = function() {\n                function LinkedList(vals) {\n                    var _this = this;\n                    _classCallCheck(this, LinkedList);\n                    this.length = 0;\n                    this.head = null;\n                    this.tail = null;\n                    if (vals != null) {\n                        vals.forEach(function(v) {\n                            return _this.push(v);\n                        });\n                    }\n                }\n                _createClass(LinkedList, [\n                    {\n                        key: \"size\",\n                        value: function size() {\n                            return this.length;\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(val, otherNode) {\n                            return add(otherNode.prev, nodeFrom(val), otherNode, this);\n                        }\n                    },\n                    {\n                        key: \"insertAfter\",\n                        value: function insertAfter(val, otherNode) {\n                            return add(otherNode, nodeFrom(val), otherNode.next, this);\n                        }\n                    },\n                    {\n                        key: \"insertNodeBefore\",\n                        value: function insertNodeBefore(newNode, otherNode) {\n                            return add(otherNode.prev, newNode, otherNode, this);\n                        }\n                    },\n                    {\n                        key: \"insertNodeAfter\",\n                        value: function insertNodeAfter(newNode, otherNode) {\n                            return add(otherNode, newNode, otherNode.next, this);\n                        }\n                    },\n                    {\n                        key: \"push\",\n                        value: function push(val) {\n                            return add(this.tail, nodeFrom(val), null, this);\n                        }\n                    },\n                    {\n                        key: \"unshift\",\n                        value: function unshift(val) {\n                            return add(null, nodeFrom(val), this.head, this);\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove(node) {\n                            return _remove(node, this);\n                        }\n                    },\n                    {\n                        key: \"pop\",\n                        value: function pop() {\n                            return _remove(this.tail, this).value;\n                        }\n                    },\n                    {\n                        key: \"popNode\",\n                        value: function popNode() {\n                            return _remove(this.tail, this);\n                        }\n                    },\n                    {\n                        key: \"shift\",\n                        value: function shift() {\n                            return _remove(this.head, this).value;\n                        }\n                    },\n                    {\n                        key: \"shiftNode\",\n                        value: function shiftNode() {\n                            return _remove(this.head, this);\n                        }\n                    },\n                    {\n                        key: \"get_object_at\",\n                        value: function get_object_at(index) {\n                            if (index <= this.length()) {\n                                var i = 1;\n                                var current = this.head;\n                                while(i < index){\n                                    current = current.next;\n                                    i++;\n                                }\n                                return current.value;\n                            }\n                        }\n                    },\n                    {\n                        key: \"set_object_at\",\n                        value: function set_object_at(index, value) {\n                            if (index <= this.length()) {\n                                var i = 1;\n                                var current = this.head;\n                                while(i < index){\n                                    current = current.next;\n                                    i++;\n                                }\n                                current.value = value;\n                            }\n                        }\n                    }\n                ]);\n                return LinkedList;\n            }();\n            module1.exports = LinkedList;\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */ function Point1(x, y, p) {\n                this.x = null;\n                this.y = null;\n                if (x == null && y == null && p == null) {\n                    this.x = 0;\n                    this.y = 0;\n                } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                    this.x = x;\n                    this.y = y;\n                } else if (x.constructor.name == \"Point\" && y == null && p == null) {\n                    p = x;\n                    this.x = p.x;\n                    this.y = p.y;\n                }\n            }\n            Point1.prototype.getX = function() {\n                return this.x;\n            };\n            Point1.prototype.getY = function() {\n                return this.y;\n            };\n            Point1.prototype.getLocation = function() {\n                return new Point1(this.x, this.y);\n            };\n            Point1.prototype.setLocation = function(x, y, p) {\n                if (x.constructor.name == \"Point\" && y == null && p == null) {\n                    p = x;\n                    this.setLocation(p.x, p.y);\n                } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                    //if both parameters are integer just move (x,y) location\n                    if (parseInt(x) == x && parseInt(y) == y) {\n                        this.move(x, y);\n                    } else {\n                        this.x = Math.floor(x + 0.5);\n                        this.y = Math.floor(y + 0.5);\n                    }\n                }\n            };\n            Point1.prototype.move = function(x, y) {\n                this.x = x;\n                this.y = y;\n            };\n            Point1.prototype.translate = function(dx, dy) {\n                this.x += dx;\n                this.y += dy;\n            };\n            Point1.prototype.equals = function(obj) {\n                if (obj.constructor.name == \"Point\") {\n                    var pt = obj;\n                    return this.x == pt.x && this.y == pt.y;\n                }\n                return this == obj;\n            };\n            Point1.prototype.toString = function() {\n                return new Point1().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n            };\n            module1.exports = Point1;\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function RectangleD(x, y, width, height) {\n                this.x = 0;\n                this.y = 0;\n                this.width = 0;\n                this.height = 0;\n                if (x != null && y != null && width != null && height != null) {\n                    this.x = x;\n                    this.y = y;\n                    this.width = width;\n                    this.height = height;\n                }\n            }\n            RectangleD.prototype.getX = function() {\n                return this.x;\n            };\n            RectangleD.prototype.setX = function(x) {\n                this.x = x;\n            };\n            RectangleD.prototype.getY = function() {\n                return this.y;\n            };\n            RectangleD.prototype.setY = function(y) {\n                this.y = y;\n            };\n            RectangleD.prototype.getWidth = function() {\n                return this.width;\n            };\n            RectangleD.prototype.setWidth = function(width) {\n                this.width = width;\n            };\n            RectangleD.prototype.getHeight = function() {\n                return this.height;\n            };\n            RectangleD.prototype.setHeight = function(height) {\n                this.height = height;\n            };\n            RectangleD.prototype.getRight = function() {\n                return this.x + this.width;\n            };\n            RectangleD.prototype.getBottom = function() {\n                return this.y + this.height;\n            };\n            RectangleD.prototype.intersects = function(a) {\n                if (this.getRight() < a.x) {\n                    return false;\n                }\n                if (this.getBottom() < a.y) {\n                    return false;\n                }\n                if (a.getRight() < this.x) {\n                    return false;\n                }\n                if (a.getBottom() < this.y) {\n                    return false;\n                }\n                return true;\n            };\n            RectangleD.prototype.getCenterX = function() {\n                return this.x + this.width / 2;\n            };\n            RectangleD.prototype.getMinX = function() {\n                return this.getX();\n            };\n            RectangleD.prototype.getMaxX = function() {\n                return this.getX() + this.width;\n            };\n            RectangleD.prototype.getCenterY = function() {\n                return this.y + this.height / 2;\n            };\n            RectangleD.prototype.getMinY = function() {\n                return this.getY();\n            };\n            RectangleD.prototype.getMaxY = function() {\n                return this.getY() + this.height;\n            };\n            RectangleD.prototype.getWidthHalf = function() {\n                return this.width / 2;\n            };\n            RectangleD.prototype.getHeightHalf = function() {\n                return this.height / 2;\n            };\n            module1.exports = RectangleD;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            function UniqueIDGeneretor() {}\n            UniqueIDGeneretor.lastID = 0;\n            UniqueIDGeneretor.createID = function(obj) {\n                if (UniqueIDGeneretor.isPrimitive(obj)) {\n                    return obj;\n                }\n                if (obj.uniqueID != null) {\n                    return obj.uniqueID;\n                }\n                obj.uniqueID = UniqueIDGeneretor.getString();\n                UniqueIDGeneretor.lastID++;\n                return obj.uniqueID;\n            };\n            UniqueIDGeneretor.getString = function(id) {\n                if (id == null) id = UniqueIDGeneretor.lastID;\n                return \"Object#\" + id + \"\";\n            };\n            UniqueIDGeneretor.isPrimitive = function(arg) {\n                var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n                return arg == null || type != \"object\" && type != \"function\";\n            };\n            module1.exports = UniqueIDGeneretor;\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_92026__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            var LayoutConstants = __nested_webpack_require_92026__(0);\n            var LGraphManager = __nested_webpack_require_92026__(6);\n            var LNode = __nested_webpack_require_92026__(3);\n            var LEdge = __nested_webpack_require_92026__(1);\n            var LGraph = __nested_webpack_require_92026__(5);\n            var PointD = __nested_webpack_require_92026__(4);\n            var Transform = __nested_webpack_require_92026__(17);\n            var Emitter = __nested_webpack_require_92026__(27);\n            function Layout1(isRemoteUse) {\n                Emitter.call(this);\n                //Layout Quality: 0:draft, 1:default, 2:proof\n                this.layoutQuality = LayoutConstants.QUALITY;\n                //Whether layout should create bendpoints as needed or not\n                this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                //Whether layout should be incremental or not\n                this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                //Whether we animate from before to after layout node positions\n                this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                //Whether we animate the layout process or not\n                this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                //Number iterations that should be done between two successive animations\n                this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */ this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n                /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */ this.edgeToDummyNodes = new Map();\n                this.graphManager = new LGraphManager(this);\n                this.isLayoutFinished = false;\n                this.isSubLayout = false;\n                this.isRemoteUse = false;\n                if (isRemoteUse != null) {\n                    this.isRemoteUse = isRemoteUse;\n                }\n            }\n            Layout1.RANDOM_SEED = 1;\n            Layout1.prototype = Object.create(Emitter.prototype);\n            Layout1.prototype.getGraphManager = function() {\n                return this.graphManager;\n            };\n            Layout1.prototype.getAllNodes = function() {\n                return this.graphManager.getAllNodes();\n            };\n            Layout1.prototype.getAllEdges = function() {\n                return this.graphManager.getAllEdges();\n            };\n            Layout1.prototype.getAllNodesToApplyGravitation = function() {\n                return this.graphManager.getAllNodesToApplyGravitation();\n            };\n            Layout1.prototype.newGraphManager = function() {\n                var gm = new LGraphManager(this);\n                this.graphManager = gm;\n                return gm;\n            };\n            Layout1.prototype.newGraph = function(vGraph) {\n                return new LGraph(null, this.graphManager, vGraph);\n            };\n            Layout1.prototype.newNode = function(vNode) {\n                return new LNode(this.graphManager, vNode);\n            };\n            Layout1.prototype.newEdge = function(vEdge) {\n                return new LEdge(null, null, vEdge);\n            };\n            Layout1.prototype.checkLayoutSuccess = function() {\n                return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n            };\n            Layout1.prototype.runLayout = function() {\n                this.isLayoutFinished = false;\n                if (this.tilingPreLayout) {\n                    this.tilingPreLayout();\n                }\n                this.initParameters();\n                var isLayoutSuccessfull;\n                if (this.checkLayoutSuccess()) {\n                    isLayoutSuccessfull = false;\n                } else {\n                    isLayoutSuccessfull = this.layout();\n                }\n                if (LayoutConstants.ANIMATE === \"during\") {\n                    // If this is a 'during' layout animation. Layout is not finished yet. \n                    // We need to perform these in index.js when layout is really finished.\n                    return false;\n                }\n                if (isLayoutSuccessfull) {\n                    if (!this.isSubLayout) {\n                        this.doPostLayout();\n                    }\n                }\n                if (this.tilingPostLayout) {\n                    this.tilingPostLayout();\n                }\n                this.isLayoutFinished = true;\n                return isLayoutSuccessfull;\n            };\n            /**\r\n * This method performs the operations required after layout.\r\n */ Layout1.prototype.doPostLayout = function() {\n                //assert !isSubLayout : \"Should not be called on sub-layout!\";\n                // Propagate geometric changes to v-level objects\n                if (!this.incremental) {\n                    this.transform();\n                }\n                this.update();\n            };\n            /**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */ Layout1.prototype.update2 = function() {\n                // update bend points\n                if (this.createBendsAsNeeded) {\n                    this.createBendpointsFromDummyNodes();\n                    // reset all edges, since the topology has changed\n                    this.graphManager.resetAllEdges();\n                }\n                // perform edge, node and root updates if layout is not called\n                // remotely\n                if (!this.isRemoteUse) {\n                    // update all edges\n                    var edge;\n                    var allEdges = this.graphManager.getAllEdges();\n                    for(var i = 0; i < allEdges.length; i++){\n                        edge = allEdges[i];\n                    //      this.update(edge);\n                    }\n                    // recursively update nodes\n                    var node;\n                    var nodes = this.graphManager.getRoot().getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        node = nodes[i];\n                    //      this.update(node);\n                    }\n                    // update root graph\n                    this.update(this.graphManager.getRoot());\n                }\n            };\n            Layout1.prototype.update = function(obj) {\n                if (obj == null) {\n                    this.update2();\n                } else if (obj instanceof LNode) {\n                    var node = obj;\n                    if (node.getChild() != null) {\n                        // since node is compound, recursively update child nodes\n                        var nodes = node.getChild().getNodes();\n                        for(var i = 0; i < nodes.length; i++){\n                            update(nodes[i]);\n                        }\n                    }\n                    // if the l-level node is associated with a v-level graph object,\n                    // then it is assumed that the v-level node implements the\n                    // interface Updatable.\n                    if (node.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vNode = node.vGraphObject;\n                        // call the update method of the interface\n                        vNode.update(node);\n                    }\n                } else if (obj instanceof LEdge) {\n                    var edge = obj;\n                    // if the l-level edge is associated with a v-level graph object,\n                    // then it is assumed that the v-level edge implements the\n                    // interface Updatable.\n                    if (edge.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vEdge = edge.vGraphObject;\n                        // call the update method of the interface\n                        vEdge.update(edge);\n                    }\n                } else if (obj instanceof LGraph) {\n                    var graph = obj;\n                    // if the l-level graph is associated with a v-level graph object,\n                    // then it is assumed that the v-level object implements the\n                    // interface Updatable.\n                    if (graph.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vGraph = graph.vGraphObject;\n                        // call the update method of the interface\n                        vGraph.update(graph);\n                    }\n                }\n            };\n            /**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */ Layout1.prototype.initParameters = function() {\n                if (!this.isSubLayout) {\n                    this.layoutQuality = LayoutConstants.QUALITY;\n                    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n                }\n                if (this.animationDuringLayout) {\n                    this.animationOnLayout = false;\n                }\n            };\n            Layout1.prototype.transform = function(newLeftTop) {\n                if (newLeftTop == undefined) {\n                    this.transform(new PointD(0, 0));\n                } else {\n                    // create a transformation object (from Eclipse to layout). When an\n                    // inverse transform is applied, we get upper-left coordinate of the\n                    // drawing or the root graph at given input coordinate (some margins\n                    // already included in calculation of left-top).\n                    var trans = new Transform();\n                    var leftTop = this.graphManager.getRoot().updateLeftTop();\n                    if (leftTop != null) {\n                        trans.setWorldOrgX(newLeftTop.x);\n                        trans.setWorldOrgY(newLeftTop.y);\n                        trans.setDeviceOrgX(leftTop.x);\n                        trans.setDeviceOrgY(leftTop.y);\n                        var nodes = this.getAllNodes();\n                        var node;\n                        for(var i = 0; i < nodes.length; i++){\n                            node = nodes[i];\n                            node.transform(trans);\n                        }\n                    }\n                }\n            };\n            Layout1.prototype.positionNodesRandomly = function(graph) {\n                if (graph == undefined) {\n                    //assert !this.incremental;\n                    this.positionNodesRandomly(this.getGraphManager().getRoot());\n                    this.getGraphManager().getRoot().updateBounds(true);\n                } else {\n                    var lNode;\n                    var childGraph;\n                    var nodes = graph.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        lNode = nodes[i];\n                        childGraph = lNode.getChild();\n                        if (childGraph == null) {\n                            lNode.scatter();\n                        } else if (childGraph.getNodes().length == 0) {\n                            lNode.scatter();\n                        } else {\n                            this.positionNodesRandomly(childGraph);\n                            lNode.updateBounds();\n                        }\n                    }\n                }\n            };\n            /**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */ Layout1.prototype.getFlatForest = function() {\n                var flatForest = [];\n                var isForest = true;\n                // Quick reference for all nodes in the graph manager associated with\n                // this layout. The list should not be changed.\n                var allNodes = this.graphManager.getRoot().getNodes();\n                // First be sure that the graph is flat\n                var isFlat = true;\n                for(var i = 0; i < allNodes.length; i++){\n                    if (allNodes[i].getChild() != null) {\n                        isFlat = false;\n                    }\n                }\n                // Return empty forest if the graph is not flat.\n                if (!isFlat) {\n                    return flatForest;\n                }\n                // Run BFS for each component of the graph.\n                var visited = new Set();\n                var toBeVisited = [];\n                var parents = new Map();\n                var unProcessedNodes = [];\n                unProcessedNodes = unProcessedNodes.concat(allNodes);\n                // Each iteration of this loop finds a component of the graph and\n                // decides whether it is a tree or not. If it is a tree, adds it to the\n                // forest and continued with the next component.\n                while(unProcessedNodes.length > 0 && isForest){\n                    toBeVisited.push(unProcessedNodes[0]);\n                    // Start the BFS. Each iteration of this loop visits a node in a\n                    // BFS manner.\n                    while(toBeVisited.length > 0 && isForest){\n                        //pool operation\n                        var currentNode = toBeVisited[0];\n                        toBeVisited.splice(0, 1);\n                        visited.add(currentNode);\n                        // Traverse all neighbors of this node\n                        var neighborEdges = currentNode.getEdges();\n                        for(var i = 0; i < neighborEdges.length; i++){\n                            var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n                            // If BFS is not growing from this neighbor.\n                            if (parents.get(currentNode) != currentNeighbor) {\n                                // We haven't previously visited this neighbor.\n                                if (!visited.has(currentNeighbor)) {\n                                    toBeVisited.push(currentNeighbor);\n                                    parents.set(currentNeighbor, currentNode);\n                                } else {\n                                    isForest = false;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // The graph contains a component that is not a tree. Empty\n                    // previously found trees. The method will end.\n                    if (!isForest) {\n                        flatForest = [];\n                    } else {\n                        var temp = [].concat(_toConsumableArray(visited));\n                        flatForest.push(temp);\n                        //flatForest = flatForest.concat(temp);\n                        //unProcessedNodes.removeAll(visited);\n                        for(var i = 0; i < temp.length; i++){\n                            var value = temp[i];\n                            var index = unProcessedNodes.indexOf(value);\n                            if (index > -1) {\n                                unProcessedNodes.splice(index, 1);\n                            }\n                        }\n                        visited = new Set();\n                        parents = new Map();\n                    }\n                }\n                return flatForest;\n            };\n            /**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */ Layout1.prototype.createDummyNodesForBendpoints = function(edge) {\n                var dummyNodes = [];\n                var prev = edge.source;\n                var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n                for(var i = 0; i < edge.bendpoints.length; i++){\n                    // create new dummy node\n                    var dummyNode = this.newNode(null);\n                    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n                    graph.add(dummyNode);\n                    // create new dummy edge between prev and dummy node\n                    var dummyEdge = this.newEdge(null);\n                    this.graphManager.add(dummyEdge, prev, dummyNode);\n                    dummyNodes.add(dummyNode);\n                    prev = dummyNode;\n                }\n                var dummyEdge = this.newEdge(null);\n                this.graphManager.add(dummyEdge, prev, edge.target);\n                this.edgeToDummyNodes.set(edge, dummyNodes);\n                // remove real edge from graph manager if it is inter-graph\n                if (edge.isInterGraph()) {\n                    this.graphManager.remove(edge);\n                } else {\n                    graph.remove(edge);\n                }\n                return dummyNodes;\n            };\n            /**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */ Layout1.prototype.createBendpointsFromDummyNodes = function() {\n                var edges = [];\n                edges = edges.concat(this.graphManager.getAllEdges());\n                edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n                for(var k = 0; k < edges.length; k++){\n                    var lEdge = edges[k];\n                    if (lEdge.bendpoints.length > 0) {\n                        var path = this.edgeToDummyNodes.get(lEdge);\n                        for(var i = 0; i < path.length; i++){\n                            var dummyNode = path[i];\n                            var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n                            // update bendpoint's location according to dummy node\n                            var ebp = lEdge.bendpoints.get(i);\n                            ebp.x = p.x;\n                            ebp.y = p.y;\n                            // remove the dummy node, dummy edges incident with this\n                            // dummy node is also removed (within the remove method)\n                            dummyNode.getOwner().remove(dummyNode);\n                        }\n                        // add the real edge to graph\n                        this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n                    }\n                }\n            };\n            Layout1.transform = function(sliderValue, defaultValue, minDiv, maxMul) {\n                if (minDiv != undefined && maxMul != undefined) {\n                    var value = defaultValue;\n                    if (sliderValue <= 50) {\n                        var minValue = defaultValue / minDiv;\n                        value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n                    } else {\n                        var maxValue = defaultValue * maxMul;\n                        value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n                    }\n                    return value;\n                } else {\n                    var a, b;\n                    if (sliderValue <= 50) {\n                        a = 9.0 * defaultValue / 500.0;\n                        b = defaultValue / 10.0;\n                    } else {\n                        a = 9.0 * defaultValue / 50.0;\n                        b = -8 * defaultValue;\n                    }\n                    return a * sliderValue + b;\n                }\n            };\n            /**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */ Layout1.findCenterOfTree = function(nodes) {\n                var list = [];\n                list = list.concat(nodes);\n                var removedNodes = [];\n                var remainingDegrees = new Map();\n                var foundCenter = false;\n                var centerNode = null;\n                if (list.length == 1 || list.length == 2) {\n                    foundCenter = true;\n                    centerNode = list[0];\n                }\n                for(var i = 0; i < list.length; i++){\n                    var node = list[i];\n                    var degree = node.getNeighborsList().size;\n                    remainingDegrees.set(node, node.getNeighborsList().size);\n                    if (degree == 1) {\n                        removedNodes.push(node);\n                    }\n                }\n                var tempList = [];\n                tempList = tempList.concat(removedNodes);\n                while(!foundCenter){\n                    var tempList2 = [];\n                    tempList2 = tempList2.concat(tempList);\n                    tempList = [];\n                    for(var i = 0; i < list.length; i++){\n                        var node = list[i];\n                        var index = list.indexOf(node);\n                        if (index >= 0) {\n                            list.splice(index, 1);\n                        }\n                        var neighbours = node.getNeighborsList();\n                        neighbours.forEach(function(neighbour) {\n                            if (removedNodes.indexOf(neighbour) < 0) {\n                                var otherDegree = remainingDegrees.get(neighbour);\n                                var newDegree = otherDegree - 1;\n                                if (newDegree == 1) {\n                                    tempList.push(neighbour);\n                                }\n                                remainingDegrees.set(neighbour, newDegree);\n                            }\n                        });\n                    }\n                    removedNodes = removedNodes.concat(tempList);\n                    if (list.length == 1 || list.length == 2) {\n                        foundCenter = true;\n                        centerNode = list[0];\n                    }\n                }\n                return centerNode;\n            };\n            /**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */ Layout1.prototype.setGraphManager = function(gm) {\n                this.graphManager = gm;\n            };\n            module1.exports = Layout1;\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function RandomSeed() {}\n            // adapted from: https://stackoverflow.com/a/19303725\n            RandomSeed.seed = 1;\n            RandomSeed.x = 0;\n            RandomSeed.nextDouble = function() {\n                RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n                return RandomSeed.x - Math.floor(RandomSeed.x);\n            };\n            module1.exports = RandomSeed;\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_116330__) {\n            \"use strict\";\n            var PointD = __nested_webpack_require_116330__(4);\n            function Transform(x, y) {\n                this.lworldOrgX = 0.0;\n                this.lworldOrgY = 0.0;\n                this.ldeviceOrgX = 0.0;\n                this.ldeviceOrgY = 0.0;\n                this.lworldExtX = 1.0;\n                this.lworldExtY = 1.0;\n                this.ldeviceExtX = 1.0;\n                this.ldeviceExtY = 1.0;\n            }\n            Transform.prototype.getWorldOrgX = function() {\n                return this.lworldOrgX;\n            };\n            Transform.prototype.setWorldOrgX = function(wox) {\n                this.lworldOrgX = wox;\n            };\n            Transform.prototype.getWorldOrgY = function() {\n                return this.lworldOrgY;\n            };\n            Transform.prototype.setWorldOrgY = function(woy) {\n                this.lworldOrgY = woy;\n            };\n            Transform.prototype.getWorldExtX = function() {\n                return this.lworldExtX;\n            };\n            Transform.prototype.setWorldExtX = function(wex) {\n                this.lworldExtX = wex;\n            };\n            Transform.prototype.getWorldExtY = function() {\n                return this.lworldExtY;\n            };\n            Transform.prototype.setWorldExtY = function(wey) {\n                this.lworldExtY = wey;\n            };\n            /* Device related */ Transform.prototype.getDeviceOrgX = function() {\n                return this.ldeviceOrgX;\n            };\n            Transform.prototype.setDeviceOrgX = function(dox) {\n                this.ldeviceOrgX = dox;\n            };\n            Transform.prototype.getDeviceOrgY = function() {\n                return this.ldeviceOrgY;\n            };\n            Transform.prototype.setDeviceOrgY = function(doy) {\n                this.ldeviceOrgY = doy;\n            };\n            Transform.prototype.getDeviceExtX = function() {\n                return this.ldeviceExtX;\n            };\n            Transform.prototype.setDeviceExtX = function(dex) {\n                this.ldeviceExtX = dex;\n            };\n            Transform.prototype.getDeviceExtY = function() {\n                return this.ldeviceExtY;\n            };\n            Transform.prototype.setDeviceExtY = function(dey) {\n                this.ldeviceExtY = dey;\n            };\n            Transform.prototype.transformX = function(x) {\n                var xDevice = 0.0;\n                var worldExtX = this.lworldExtX;\n                if (worldExtX != 0.0) {\n                    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n                }\n                return xDevice;\n            };\n            Transform.prototype.transformY = function(y) {\n                var yDevice = 0.0;\n                var worldExtY = this.lworldExtY;\n                if (worldExtY != 0.0) {\n                    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n                }\n                return yDevice;\n            };\n            Transform.prototype.inverseTransformX = function(x) {\n                var xWorld = 0.0;\n                var deviceExtX = this.ldeviceExtX;\n                if (deviceExtX != 0.0) {\n                    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n                }\n                return xWorld;\n            };\n            Transform.prototype.inverseTransformY = function(y) {\n                var yWorld = 0.0;\n                var deviceExtY = this.ldeviceExtY;\n                if (deviceExtY != 0.0) {\n                    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n                }\n                return yWorld;\n            };\n            Transform.prototype.inverseTransformPoint = function(inPoint) {\n                var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n                return outPoint;\n            };\n            module1.exports = Transform;\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_120454__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            var Layout1 = __nested_webpack_require_120454__(15);\n            var FDLayoutConstants = __nested_webpack_require_120454__(7);\n            var LayoutConstants = __nested_webpack_require_120454__(0);\n            var IGeometry = __nested_webpack_require_120454__(8);\n            var IMath = __nested_webpack_require_120454__(9);\n            function FDLayout() {\n                Layout1.call(this);\n                this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n                this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n                this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n                this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                this.totalDisplacement = 0.0;\n                this.oldTotalDisplacement = 0.0;\n                this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n            }\n            FDLayout.prototype = Object.create(Layout1.prototype);\n            for(var prop in Layout1){\n                FDLayout[prop] = Layout1[prop];\n            }\n            FDLayout.prototype.initParameters = function() {\n                Layout1.prototype.initParameters.call(this, arguments);\n                this.totalIterations = 0;\n                this.notAnimatedIterations = 0;\n                this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n                this.grid = [];\n            };\n            FDLayout.prototype.calcIdealEdgeLengths = function() {\n                var edge;\n                var lcaDepth;\n                var source;\n                var target;\n                var sizeOfSourceInLca;\n                var sizeOfTargetInLca;\n                var allEdges = this.getGraphManager().getAllEdges();\n                for(var i = 0; i < allEdges.length; i++){\n                    edge = allEdges[i];\n                    edge.idealLength = this.idealEdgeLength;\n                    if (edge.isInterGraph) {\n                        source = edge.getSource();\n                        target = edge.getTarget();\n                        sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n                        sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n                        if (this.useSmartIdealEdgeLengthCalculation) {\n                            edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n                        }\n                        lcaDepth = edge.getLca().getInclusionTreeDepth();\n                        edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n                    }\n                }\n            };\n            FDLayout.prototype.initSpringEmbedder = function() {\n                var s = this.getAllNodes().length;\n                if (this.incremental) {\n                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                        this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                    }\n                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n                } else {\n                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                        this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                    } else {\n                        this.coolingFactor = 1.0;\n                    }\n                    this.initialCoolingFactor = this.coolingFactor;\n                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n                }\n                this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n                this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n                this.repulsionRange = this.calcRepulsionRange();\n            };\n            FDLayout.prototype.calcSpringForces = function() {\n                var lEdges = this.getAllEdges();\n                var edge;\n                for(var i = 0; i < lEdges.length; i++){\n                    edge = lEdges[i];\n                    this.calcSpringForce(edge, edge.idealLength);\n                }\n            };\n            FDLayout.prototype.calcRepulsionForces = function() {\n                var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var i, j;\n                var nodeA, nodeB;\n                var lNodes = this.getAllNodes();\n                var processedNodeSet;\n                if (this.useFRGridVariant) {\n                    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n                        this.updateGrid();\n                    }\n                    processedNodeSet = new Set();\n                    // calculate repulsion forces between each nodes and its surrounding\n                    for(i = 0; i < lNodes.length; i++){\n                        nodeA = lNodes[i];\n                        this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                        processedNodeSet.add(nodeA);\n                    }\n                } else {\n                    for(i = 0; i < lNodes.length; i++){\n                        nodeA = lNodes[i];\n                        for(j = i + 1; j < lNodes.length; j++){\n                            nodeB = lNodes[j];\n                            // If both nodes are not members of the same graph, skip.\n                            if (nodeA.getOwner() != nodeB.getOwner()) {\n                                continue;\n                            }\n                            this.calcRepulsionForce(nodeA, nodeB);\n                        }\n                    }\n                }\n            };\n            FDLayout.prototype.calcGravitationalForces = function() {\n                var node;\n                var lNodes = this.getAllNodesToApplyGravitation();\n                for(var i = 0; i < lNodes.length; i++){\n                    node = lNodes[i];\n                    this.calcGravitationalForce(node);\n                }\n            };\n            FDLayout.prototype.moveNodes = function() {\n                var lNodes = this.getAllNodes();\n                var node;\n                for(var i = 0; i < lNodes.length; i++){\n                    node = lNodes[i];\n                    node.move();\n                }\n            };\n            FDLayout.prototype.calcSpringForce = function(edge, idealLength) {\n                var sourceNode = edge.getSource();\n                var targetNode = edge.getTarget();\n                var length;\n                var springForce;\n                var springForceX;\n                var springForceY;\n                // Update edge length\n                if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n                    edge.updateLengthSimple();\n                } else {\n                    edge.updateLength();\n                    if (edge.isOverlapingSourceAndTarget) {\n                        return;\n                    }\n                }\n                length = edge.getLength();\n                if (length == 0) return;\n                // Calculate spring forces\n                springForce = this.springConstant * (length - idealLength);\n                // Project force onto x and y axes\n                springForceX = springForce * (edge.lengthX / length);\n                springForceY = springForce * (edge.lengthY / length);\n                // Apply forces on the end nodes\n                sourceNode.springForceX += springForceX;\n                sourceNode.springForceY += springForceY;\n                targetNode.springForceX -= springForceX;\n                targetNode.springForceY -= springForceY;\n            };\n            FDLayout.prototype.calcRepulsionForce = function(nodeA, nodeB) {\n                var rectA = nodeA.getRect();\n                var rectB = nodeB.getRect();\n                var overlapAmount = new Array(2);\n                var clipPoints = new Array(4);\n                var distanceX;\n                var distanceY;\n                var distanceSquared;\n                var distance;\n                var repulsionForce;\n                var repulsionForceX;\n                var repulsionForceY;\n                if (rectA.intersects(rectB)) {\n                    // calculate separation amount in x and y directions\n                    IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n                    repulsionForceX = 2 * overlapAmount[0];\n                    repulsionForceY = 2 * overlapAmount[1];\n                    var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n                    // Apply forces on the two nodes\n                    nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n                    nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n                    nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n                    nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n                } else {\n                    // calculate distance\n                    if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) {\n                        distanceX = rectB.getCenterX() - rectA.getCenterX();\n                        distanceY = rectB.getCenterY() - rectA.getCenterY();\n                    } else {\n                        IGeometry.getIntersection(rectA, rectB, clipPoints);\n                        distanceX = clipPoints[2] - clipPoints[0];\n                        distanceY = clipPoints[3] - clipPoints[1];\n                    }\n                    // No repulsion range. FR grid variant should take care of this.\n                    if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n                    }\n                    if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n                    }\n                    distanceSquared = distanceX * distanceX + distanceY * distanceY;\n                    distance = Math.sqrt(distanceSquared);\n                    repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n                    // Project force onto x and y axes\n                    repulsionForceX = repulsionForce * distanceX / distance;\n                    repulsionForceY = repulsionForce * distanceY / distance;\n                    // Apply forces on the two nodes    \n                    nodeA.repulsionForceX -= repulsionForceX;\n                    nodeA.repulsionForceY -= repulsionForceY;\n                    nodeB.repulsionForceX += repulsionForceX;\n                    nodeB.repulsionForceY += repulsionForceY;\n                }\n            };\n            FDLayout.prototype.calcGravitationalForce = function(node) {\n                var ownerGraph;\n                var ownerCenterX;\n                var ownerCenterY;\n                var distanceX;\n                var distanceY;\n                var absDistanceX;\n                var absDistanceY;\n                var estimatedSize;\n                ownerGraph = node.getOwner();\n                ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n                ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n                distanceX = node.getCenterX() - ownerCenterX;\n                distanceY = node.getCenterY() - ownerCenterY;\n                absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n                absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n                if (node.getOwner() == this.graphManager.getRoot()) {\n                    estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                        node.gravitationForceX = -this.gravityConstant * distanceX;\n                        node.gravitationForceY = -this.gravityConstant * distanceY;\n                    }\n                } else {\n                    estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n                        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n                    }\n                }\n            };\n            FDLayout.prototype.isConverged = function() {\n                var converged;\n                var oscilating = false;\n                if (this.totalIterations > this.maxIterations / 3) {\n                    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n                }\n                converged = this.totalDisplacement < this.totalDisplacementThreshold;\n                this.oldTotalDisplacement = this.totalDisplacement;\n                return converged || oscilating;\n            };\n            FDLayout.prototype.animate = function() {\n                if (this.animationDuringLayout && !this.isSubLayout) {\n                    if (this.notAnimatedIterations == this.animationPeriod) {\n                        this.update();\n                        this.notAnimatedIterations = 0;\n                    } else {\n                        this.notAnimatedIterations++;\n                    }\n                }\n            };\n            //This method calculates the number of children (weight) for all nodes\n            FDLayout.prototype.calcNoOfChildrenForAllNodes = function() {\n                var node;\n                var allNodes = this.graphManager.getAllNodes();\n                for(var i = 0; i < allNodes.length; i++){\n                    node = allNodes[i];\n                    node.noOfChildren = node.getNoOfChildren();\n                }\n            };\n            // -----------------------------------------------------------------------------\n            // Section: FR-Grid Variant Repulsion Force Calculation\n            // -----------------------------------------------------------------------------\n            FDLayout.prototype.calcGrid = function(graph) {\n                var sizeX = 0;\n                var sizeY = 0;\n                sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n                sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n                var grid = new Array(sizeX);\n                for(var i = 0; i < sizeX; i++){\n                    grid[i] = new Array(sizeY);\n                }\n                for(var i = 0; i < sizeX; i++){\n                    for(var j = 0; j < sizeY; j++){\n                        grid[i][j] = new Array();\n                    }\n                }\n                return grid;\n            };\n            FDLayout.prototype.addNodeToGrid = function(v, left, top) {\n                var startX = 0;\n                var finishX = 0;\n                var startY = 0;\n                var finishY = 0;\n                startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n                finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n                startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n                finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n                for(var i = startX; i <= finishX; i++){\n                    for(var j = startY; j <= finishY; j++){\n                        this.grid[i][j].push(v);\n                        v.setGridCoordinates(startX, finishX, startY, finishY);\n                    }\n                }\n            };\n            FDLayout.prototype.updateGrid = function() {\n                var i;\n                var nodeA;\n                var lNodes = this.getAllNodes();\n                this.grid = this.calcGrid(this.graphManager.getRoot());\n                // put all nodes to proper grid cells\n                for(i = 0; i < lNodes.length; i++){\n                    nodeA = lNodes[i];\n                    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n                }\n            };\n            FDLayout.prototype.calculateRepulsionForceOfANode = function(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n                if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n                    var surrounding = new Set();\n                    nodeA.surrounding = new Array();\n                    var nodeB;\n                    var grid = this.grid;\n                    for(var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++){\n                        for(var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++){\n                            if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n                                for(var k = 0; k < grid[i][j].length; k++){\n                                    nodeB = grid[i][j][k];\n                                    // If both nodes are not members of the same graph, \n                                    // or both nodes are the same, skip.\n                                    if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n                                        continue;\n                                    }\n                                    // check if the repulsion force between\n                                    // nodeA and nodeB has already been calculated\n                                    if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n                                        var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n                                        var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n                                        // if the distance between nodeA and nodeB \n                                        // is less then calculation range\n                                        if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                                            //then add nodeB to surrounding of nodeA\n                                            surrounding.add(nodeB);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n                }\n                for(i = 0; i < nodeA.surrounding.length; i++){\n                    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n                }\n            };\n            FDLayout.prototype.calcRepulsionRange = function() {\n                return 0.0;\n            };\n            module1.exports = FDLayout;\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_141927__) {\n            \"use strict\";\n            var LEdge = __nested_webpack_require_141927__(1);\n            var FDLayoutConstants = __nested_webpack_require_141927__(7);\n            function FDLayoutEdge(source, target, vEdge) {\n                LEdge.call(this, source, target, vEdge);\n                this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n            }\n            FDLayoutEdge.prototype = Object.create(LEdge.prototype);\n            for(var prop in LEdge){\n                FDLayoutEdge[prop] = LEdge[prop];\n            }\n            module1.exports = FDLayoutEdge;\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_142569__) {\n            \"use strict\";\n            var LNode = __nested_webpack_require_142569__(3);\n            function FDLayoutNode(gm, loc, size, vNode) {\n                // alternative constructor is handled inside LNode\n                LNode.call(this, gm, loc, size, vNode);\n                //Spring, repulsion and gravitational forces acting on this node\n                this.springForceX = 0;\n                this.springForceY = 0;\n                this.repulsionForceX = 0;\n                this.repulsionForceY = 0;\n                this.gravitationForceX = 0;\n                this.gravitationForceY = 0;\n                //Amount by which this node is to be moved in this iteration\n                this.displacementX = 0;\n                this.displacementY = 0;\n                //Start and finish grid coordinates that this node is fallen into\n                this.startX = 0;\n                this.finishX = 0;\n                this.startY = 0;\n                this.finishY = 0;\n                //Geometric neighbors of this node\n                this.surrounding = [];\n            }\n            FDLayoutNode.prototype = Object.create(LNode.prototype);\n            for(var prop in LNode){\n                FDLayoutNode[prop] = LNode[prop];\n            }\n            FDLayoutNode.prototype.setGridCoordinates = function(_startX, _finishX, _startY, _finishY) {\n                this.startX = _startX;\n                this.finishX = _finishX;\n                this.startY = _startY;\n                this.finishY = _finishY;\n            };\n            module1.exports = FDLayoutNode;\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function DimensionD1(width, height) {\n                this.width = 0;\n                this.height = 0;\n                if (width !== null && height !== null) {\n                    this.height = height;\n                    this.width = width;\n                }\n            }\n            DimensionD1.prototype.getWidth = function() {\n                return this.width;\n            };\n            DimensionD1.prototype.setWidth = function(width) {\n                this.width = width;\n            };\n            DimensionD1.prototype.getHeight = function() {\n                return this.height;\n            };\n            DimensionD1.prototype.setHeight = function(height) {\n                this.height = height;\n            };\n            module1.exports = DimensionD1;\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_145112__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __nested_webpack_require_145112__(14);\n            function HashMap() {\n                this.map = {};\n                this.keys = [];\n            }\n            HashMap.prototype.put = function(key, value) {\n                var theId = UniqueIDGeneretor.createID(key);\n                if (!this.contains(theId)) {\n                    this.map[theId] = value;\n                    this.keys.push(key);\n                }\n            };\n            HashMap.prototype.contains = function(key) {\n                var theId = UniqueIDGeneretor.createID(key);\n                return this.map[key] != null;\n            };\n            HashMap.prototype.get = function(key) {\n                var theId = UniqueIDGeneretor.createID(key);\n                return this.map[theId];\n            };\n            HashMap.prototype.keySet = function() {\n                return this.keys;\n            };\n            module1.exports = HashMap;\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_146171__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __nested_webpack_require_146171__(14);\n            function HashSet() {\n                this.set = {};\n            }\n            ;\n            HashSet.prototype.add = function(obj) {\n                var theId = UniqueIDGeneretor.createID(obj);\n                if (!this.contains(theId)) this.set[theId] = obj;\n            };\n            HashSet.prototype.remove = function(obj) {\n                delete this.set[UniqueIDGeneretor.createID(obj)];\n            };\n            HashSet.prototype.clear = function() {\n                this.set = {};\n            };\n            HashSet.prototype.contains = function(obj) {\n                return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n            };\n            HashSet.prototype.isEmpty = function() {\n                return this.size() === 0;\n            };\n            HashSet.prototype.size = function() {\n                return Object.keys(this.set).length;\n            };\n            //concats this.set to the given list\n            HashSet.prototype.addAllTo = function(list) {\n                var keys = Object.keys(this.set);\n                var length = keys.length;\n                for(var i = 0; i < length; i++){\n                    list.push(this.set[keys[i]]);\n                }\n            };\n            HashSet.prototype.size = function() {\n                return Object.keys(this.set).length;\n            };\n            HashSet.prototype.addAll = function(list) {\n                var s = list.length;\n                for(var i = 0; i < s; i++){\n                    var v = list[i];\n                    this.add(v);\n                }\n            };\n            module1.exports = HashSet;\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __nested_webpack_require_147969__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            /**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */ var LinkedList = __nested_webpack_require_147969__(11);\n            var Quicksort = function() {\n                function Quicksort(A, compareFunction) {\n                    _classCallCheck(this, Quicksort);\n                    if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n                    var length = void 0;\n                    if (A instanceof LinkedList) length = A.size();\n                    else length = A.length;\n                    this._quicksort(A, 0, length - 1);\n                }\n                _createClass(Quicksort, [\n                    {\n                        key: \"_quicksort\",\n                        value: function _quicksort(A, p, r) {\n                            if (p < r) {\n                                var q = this._partition(A, p, r);\n                                this._quicksort(A, p, q);\n                                this._quicksort(A, q + 1, r);\n                            }\n                        }\n                    },\n                    {\n                        key: \"_partition\",\n                        value: function _partition(A, p, r) {\n                            var x = this._get(A, p);\n                            var i = p;\n                            var j = r;\n                            while(true){\n                                while(this.compareFunction(x, this._get(A, j))){\n                                    j--;\n                                }\n                                while(this.compareFunction(this._get(A, i), x)){\n                                    i++;\n                                }\n                                if (i < j) {\n                                    this._swap(A, i, j);\n                                    i++;\n                                    j--;\n                                } else return j;\n                            }\n                        }\n                    },\n                    {\n                        key: \"_get\",\n                        value: function _get(object, index) {\n                            if (object instanceof LinkedList) return object.get_object_at(index);\n                            else return object[index];\n                        }\n                    },\n                    {\n                        key: \"_set\",\n                        value: function _set(object, index, value) {\n                            if (object instanceof LinkedList) object.set_object_at(index, value);\n                            else object[index] = value;\n                        }\n                    },\n                    {\n                        key: \"_swap\",\n                        value: function _swap(A, i, j) {\n                            var temp = this._get(A, i);\n                            this._set(A, i, this._get(A, j));\n                            this._set(A, j, temp);\n                        }\n                    },\n                    {\n                        key: \"_defaultCompareFunction\",\n                        value: function _defaultCompareFunction(a, b) {\n                            return b > a;\n                        }\n                    }\n                ]);\n                return Quicksort;\n            }();\n            module1.exports = Quicksort;\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            /**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */ var NeedlemanWunsch = function() {\n                function NeedlemanWunsch(sequence1, sequence2) {\n                    var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n                    var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n                    var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n                    _classCallCheck(this, NeedlemanWunsch);\n                    this.sequence1 = sequence1;\n                    this.sequence2 = sequence2;\n                    this.match_score = match_score;\n                    this.mismatch_penalty = mismatch_penalty;\n                    this.gap_penalty = gap_penalty;\n                    // Just the remove redundancy\n                    this.iMax = sequence1.length + 1;\n                    this.jMax = sequence2.length + 1;\n                    // Grid matrix of scores\n                    this.grid = new Array(this.iMax);\n                    for(var i = 0; i < this.iMax; i++){\n                        this.grid[i] = new Array(this.jMax);\n                        for(var j = 0; j < this.jMax; j++){\n                            this.grid[i][j] = 0;\n                        }\n                    }\n                    // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n                    this.tracebackGrid = new Array(this.iMax);\n                    for(var _i = 0; _i < this.iMax; _i++){\n                        this.tracebackGrid[_i] = new Array(this.jMax);\n                        for(var _j = 0; _j < this.jMax; _j++){\n                            this.tracebackGrid[_i][_j] = [\n                                null,\n                                null,\n                                null\n                            ];\n                        }\n                    }\n                    // The aligned sequences (return multiple possibilities)\n                    this.alignments = [];\n                    // Final alignment score\n                    this.score = -1;\n                    // Calculate scores and tracebacks\n                    this.computeGrids();\n                }\n                _createClass(NeedlemanWunsch, [\n                    {\n                        key: \"getScore\",\n                        value: function getScore() {\n                            return this.score;\n                        }\n                    },\n                    {\n                        key: \"getAlignments\",\n                        value: function getAlignments() {\n                            return this.alignments;\n                        }\n                    },\n                    {\n                        key: \"computeGrids\",\n                        value: function computeGrids() {\n                            // Fill in the first row\n                            for(var j = 1; j < this.jMax; j++){\n                                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                                this.tracebackGrid[0][j] = [\n                                    false,\n                                    false,\n                                    true\n                                ];\n                            }\n                            // Fill in the first column\n                            for(var i = 1; i < this.iMax; i++){\n                                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                                this.tracebackGrid[i][0] = [\n                                    false,\n                                    true,\n                                    false\n                                ];\n                            }\n                            // Fill the rest of the grid\n                            for(var _i2 = 1; _i2 < this.iMax; _i2++){\n                                for(var _j2 = 1; _j2 < this.jMax; _j2++){\n                                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                                    var diag = void 0;\n                                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;\n                                    else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n                                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n                                    // If there exists multiple max values, capture them for multiple paths\n                                    var maxOf = [\n                                        diag,\n                                        up,\n                                        left\n                                    ];\n                                    var indices = this.arrayAllMaxIndexes(maxOf);\n                                    // Update Grids\n                                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                                    this.tracebackGrid[_i2][_j2] = [\n                                        indices.includes(0),\n                                        indices.includes(1),\n                                        indices.includes(2)\n                                    ];\n                                }\n                            }\n                            // Update alignment score\n                            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n                        }\n                    },\n                    {\n                        key: \"alignmentTraceback\",\n                        value: function alignmentTraceback() {\n                            var inProcessAlignments = [];\n                            inProcessAlignments.push({\n                                pos: [\n                                    this.sequence1.length,\n                                    this.sequence2.length\n                                ],\n                                seq1: \"\",\n                                seq2: \"\"\n                            });\n                            while(inProcessAlignments[0]){\n                                var current = inProcessAlignments[0];\n                                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n                                if (directions[0]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0] - 1,\n                                            current.pos[1] - 1\n                                        ],\n                                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                                    });\n                                }\n                                if (directions[1]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0] - 1,\n                                            current.pos[1]\n                                        ],\n                                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                                        seq2: \"-\" + current.seq2\n                                    });\n                                }\n                                if (directions[2]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0],\n                                            current.pos[1] - 1\n                                        ],\n                                        seq1: \"-\" + current.seq1,\n                                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                                    });\n                                }\n                                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({\n                                    sequence1: current.seq1,\n                                    sequence2: current.seq2\n                                });\n                                inProcessAlignments.shift();\n                            }\n                            return this.alignments;\n                        }\n                    },\n                    {\n                        key: \"getAllIndexes\",\n                        value: function getAllIndexes(arr, val) {\n                            var indexes = [], i = -1;\n                            while((i = arr.indexOf(val, i + 1)) !== -1){\n                                indexes.push(i);\n                            }\n                            return indexes;\n                        }\n                    },\n                    {\n                        key: \"arrayAllMaxIndexes\",\n                        value: function arrayAllMaxIndexes(array) {\n                            return this.getAllIndexes(array, Math.max.apply(null, array));\n                        }\n                    }\n                ]);\n                return NeedlemanWunsch;\n            }();\n            module1.exports = NeedlemanWunsch;\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __nested_webpack_require_163805__) {\n            \"use strict\";\n            var layoutBase = function layoutBase() {\n                return;\n            };\n            layoutBase.FDLayout = __nested_webpack_require_163805__(18);\n            layoutBase.FDLayoutConstants = __nested_webpack_require_163805__(7);\n            layoutBase.FDLayoutEdge = __nested_webpack_require_163805__(19);\n            layoutBase.FDLayoutNode = __nested_webpack_require_163805__(20);\n            layoutBase.DimensionD = __nested_webpack_require_163805__(21);\n            layoutBase.HashMap = __nested_webpack_require_163805__(22);\n            layoutBase.HashSet = __nested_webpack_require_163805__(23);\n            layoutBase.IGeometry = __nested_webpack_require_163805__(8);\n            layoutBase.IMath = __nested_webpack_require_163805__(9);\n            layoutBase.Integer = __nested_webpack_require_163805__(10);\n            layoutBase.Point = __nested_webpack_require_163805__(12);\n            layoutBase.PointD = __nested_webpack_require_163805__(4);\n            layoutBase.RandomSeed = __nested_webpack_require_163805__(16);\n            layoutBase.RectangleD = __nested_webpack_require_163805__(13);\n            layoutBase.Transform = __nested_webpack_require_163805__(17);\n            layoutBase.UniqueIDGeneretor = __nested_webpack_require_163805__(14);\n            layoutBase.Quicksort = __nested_webpack_require_163805__(24);\n            layoutBase.LinkedList = __nested_webpack_require_163805__(11);\n            layoutBase.LGraphObject = __nested_webpack_require_163805__(2);\n            layoutBase.LGraph = __nested_webpack_require_163805__(5);\n            layoutBase.LEdge = __nested_webpack_require_163805__(1);\n            layoutBase.LGraphManager = __nested_webpack_require_163805__(6);\n            layoutBase.LNode = __nested_webpack_require_163805__(3);\n            layoutBase.Layout = __nested_webpack_require_163805__(15);\n            layoutBase.LayoutConstants = __nested_webpack_require_163805__(0);\n            layoutBase.NeedlemanWunsch = __nested_webpack_require_163805__(25);\n            module1.exports = layoutBase;\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function Emitter() {\n                this.listeners = [];\n            }\n            var p = Emitter.prototype;\n            p.addListener = function(event, callback) {\n                this.listeners.push({\n                    event: event,\n                    callback: callback\n                });\n            };\n            p.removeListener = function(event, callback) {\n                for(var i = this.listeners.length; i >= 0; i--){\n                    var l = this.listeners[i];\n                    if (l.event === event && l.callback === callback) {\n                        this.listeners.splice(i, 1);\n                    }\n                }\n            };\n            p.emit = function(event, data) {\n                for(var i = 0; i < this.listeners.length; i++){\n                    var l = this.listeners[i];\n                    if (event === l.event) {\n                        l.callback(data);\n                    }\n                }\n            };\n            module1.exports = Emitter;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGF5b3V0LWJhc2UvbGF5b3V0LWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQUMsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRDtTQUNiLEVBSzJCQTtBQUNqQyxHQUFHLElBQUksRUFBRTtJQUNULE9BQWdCLE1BQUgsR0FBSSxTQUFTSyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDUCxPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNJLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVQsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtJLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNULFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFTSw4QkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS0wsUUFBT1EsQ0FBQyxHQUFHO1lBQ3RCLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1lBQzlDLE1BQU0sR0FBSyxPQUFP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RztvQkFDYjtnQkFDRjtZQUNGO1lBRUF2dEIsUUFBT0QsT0FBTyxHQUFHa2Q7UUFFakIsR0FBRyxHQUFHO0tBQ0k7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL2Npcm8tbmV0d29yay13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2xheW91dC1iYXNlL2xheW91dC1iYXNlLmpzP2E1YzQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibGF5b3V0QmFzZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJsYXlvdXRCYXNlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjYpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBMYXlvdXRDb25zdGFudHMoKSB7fVxuXG4vKipcclxuICogTGF5b3V0IFF1YWxpdHk6IDA6ZHJhZnQsIDE6ZGVmYXVsdCwgMjpwcm9vZlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5RVUFMSVRZID0gMTtcblxuLyoqXHJcbiAqIERlZmF1bHQgcGFyYW1ldGVyc1xyXG4gKi9cbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUID0gdHJ1ZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EID0gNTA7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUyA9IGZhbHNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogR2VuZXJhbCBvdGhlciBjb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKlxyXG4gKiBNYXJnaW5zIG9mIGEgZ3JhcGggdG8gYmUgYXBwbGllZCBvbiBib3VkaW5nIHJlY3RhbmdsZSBvZiBpdHMgY29udGVudHMuIFdlXHJcbiAqIGFzc3VtZSBtYXJnaW5zIG9uIGFsbCBmb3VyIHNpZGVzIHRvIGJlIHVuaWZvcm0uXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfTUFSR0lOID0gMTU7XG5cbi8qXHJcbiAqIFdoZXRoZXIgdG8gY29uc2lkZXIgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9ucyBvciBub3RcclxuICovXG5MYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gZmFsc2U7XG5cbi8qXHJcbiAqIERlZmF1bHQgZGltZW5zaW9uIG9mIGEgbm9uLWNvbXBvdW5kIG5vZGUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkUgPSA0MDtcblxuLypcclxuICogRGVmYXVsdCBkaW1lbnNpb24gb2YgYSBub24tY29tcG91bmQgbm9kZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfSEFMRl9TSVpFID0gTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkUgLyAyO1xuXG4vKlxyXG4gKiBFbXB0eSBjb21wb3VuZCBub2RlIHNpemUuIFdoZW4gYSBjb21wb3VuZCBub2RlIGlzIGVtcHR5LCBpdHMgYm90aFxyXG4gKiBkaW1lbnNpb25zIHNob3VsZCBiZSBvZiB0aGlzIHZhbHVlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5FTVBUWV9DT01QT1VORF9OT0RFX1NJWkUgPSA0MDtcblxuLypcclxuICogTWluaW11bSBsZW5ndGggdGhhdCBhbiBlZGdlIHNob3VsZCB0YWtlIGR1cmluZyBsYXlvdXRcclxuICovXG5MYXlvdXRDb25zdGFudHMuTUlOX0VER0VfTEVOR1RIID0gMTtcblxuLypcclxuICogV29ybGQgYm91bmRhcmllcyB0aGF0IGxheW91dCBvcGVyYXRlcyBvblxyXG4gKi9cbkxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSA9IDEwMDAwMDA7XG5cbi8qXHJcbiAqIFdvcmxkIGJvdW5kYXJpZXMgdGhhdCByYW5kb20gcG9zaXRpb25pbmcgY2FuIGJlIHBlcmZvcm1lZCB3aXRoXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlkgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkgLyAxMDAwO1xuXG4vKlxyXG4gKiBDb29yZGluYXRlcyBvZiB0aGUgd29ybGQgY2VudGVyXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YID0gMTIwMDtcbkxheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSA9IDkwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXRDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIElNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuZnVuY3Rpb24gTEVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZFZGdlKTtcblxuICB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IGZhbHNlO1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZFZGdlO1xuICB0aGlzLmJlbmRwb2ludHMgPSBbXTtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5MRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMRWRnZVtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTEVkZ2UucHJvdG90eXBlLmdldFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudGFyZ2V0O1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmlzSW50ZXJHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNJbnRlckdyYXBoO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0O1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldEJlbmRwb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmJlbmRwb2ludHM7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0TGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0U291cmNlSW5MY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZUluTGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFRhcmdldEluTGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50YXJnZXRJbkxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRPdGhlckVuZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLnNvdXJjZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIk5vZGUgaXMgbm90IGluY2lkZW50IHdpdGggdGhpcyBlZGdlXCI7XG4gIH1cbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRPdGhlckVuZEluR3JhcGggPSBmdW5jdGlvbiAobm9kZSwgZ3JhcGgpIHtcbiAgdmFyIG90aGVyRW5kID0gdGhpcy5nZXRPdGhlckVuZChub2RlKTtcbiAgdmFyIHJvb3QgPSBncmFwaC5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAob3RoZXJFbmQuZ2V0T3duZXIoKSA9PSBncmFwaCkge1xuICAgICAgcmV0dXJuIG90aGVyRW5kO1xuICAgIH1cblxuICAgIGlmIChvdGhlckVuZC5nZXRPd25lcigpID09IHJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG90aGVyRW5kID0gb3RoZXJFbmQuZ2V0T3duZXIoKS5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLnVwZGF0ZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNsaXBQb2ludENvb3JkaW5hdGVzID0gbmV3IEFycmF5KDQpO1xuXG4gIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbih0aGlzLnRhcmdldC5nZXRSZWN0KCksIHRoaXMuc291cmNlLmdldFJlY3QoKSwgY2xpcFBvaW50Q29vcmRpbmF0ZXMpO1xuXG4gIGlmICghdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQpIHtcbiAgICB0aGlzLmxlbmd0aFggPSBjbGlwUG9pbnRDb29yZGluYXRlc1swXSAtIGNsaXBQb2ludENvb3JkaW5hdGVzWzJdO1xuICAgIHRoaXMubGVuZ3RoWSA9IGNsaXBQb2ludENvb3JkaW5hdGVzWzFdIC0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbM107XG5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhYKSA8IDEuMCkge1xuICAgICAgdGhpcy5sZW5ndGhYID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFgpO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFkpIDwgMS4wKSB7XG4gICAgICB0aGlzLmxlbmd0aFkgPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWSk7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhYICogdGhpcy5sZW5ndGhYICsgdGhpcy5sZW5ndGhZICogdGhpcy5sZW5ndGhZKTtcbiAgfVxufTtcblxuTEVkZ2UucHJvdG90eXBlLnVwZGF0ZUxlbmd0aFNpbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sZW5ndGhYID0gdGhpcy50YXJnZXQuZ2V0Q2VudGVyWCgpIC0gdGhpcy5zb3VyY2UuZ2V0Q2VudGVyWCgpO1xuICB0aGlzLmxlbmd0aFkgPSB0aGlzLnRhcmdldC5nZXRDZW50ZXJZKCkgLSB0aGlzLnNvdXJjZS5nZXRDZW50ZXJZKCk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWCkgPCAxLjApIHtcbiAgICB0aGlzLmxlbmd0aFggPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhZKSA8IDEuMCkge1xuICAgIHRoaXMubGVuZ3RoWSA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhZKTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoWCAqIHRoaXMubGVuZ3RoWCArIHRoaXMubGVuZ3RoWSAqIHRoaXMubGVuZ3RoWSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gTEdyYXBoT2JqZWN0KHZHcmFwaE9iamVjdCkge1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZHcmFwaE9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMR3JhcGhPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUmFuZG9tU2VlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIExOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIC8vQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgMSA6IExOb2RlKExHcmFwaE1hbmFnZXIgZ20sIFBvaW50IGxvYywgRGltZW5zaW9uIHNpemUsIE9iamVjdCB2Tm9kZSlcbiAgaWYgKHNpemUgPT0gbnVsbCAmJiB2Tm9kZSA9PSBudWxsKSB7XG4gICAgdk5vZGUgPSBsb2M7XG4gIH1cblxuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2Tm9kZSk7XG5cbiAgLy9BbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciAyIDogTE5vZGUoTGF5b3V0IGxheW91dCwgT2JqZWN0IHZOb2RlKVxuICBpZiAoZ20uZ3JhcGhNYW5hZ2VyICE9IG51bGwpIGdtID0gZ20uZ3JhcGhNYW5hZ2VyO1xuXG4gIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IEludGVnZXIuTUlOX1ZBTFVFO1xuICB0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZOb2RlO1xuICB0aGlzLmVkZ2VzID0gW107XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG5cbiAgaWYgKHNpemUgIT0gbnVsbCAmJiBsb2MgIT0gbnVsbCkgdGhpcy5yZWN0ID0gbmV3IFJlY3RhbmdsZUQobG9jLngsIGxvYy55LCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7ZWxzZSB0aGlzLnJlY3QgPSBuZXcgUmVjdGFuZ2xlRCgpO1xufVxuXG5MTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTE5vZGVbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWRnZXM7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE93bmVyID0gZnVuY3Rpb24gKCkge1xuICAvLyAgaWYgKHRoaXMub3duZXIgIT0gbnVsbCkge1xuICAvLyAgICBpZiAoISh0aGlzLm93bmVyID09IG51bGwgfHwgdGhpcy5vd25lci5nZXROb2RlcygpLmluZGV4T2YodGhpcykgPiAtMSkpIHtcbiAgLy8gICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgLy8gICAgfVxuICAvLyAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMucmVjdC53aWR0aCA9IHdpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLnJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aCAvIDIsIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodCAvIDIpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLnJlY3QueCwgdGhpcy5yZWN0LnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RGlhZ29uYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5yZWN0LndpZHRoICogdGhpcy5yZWN0LndpZHRoICsgdGhpcy5yZWN0LmhlaWdodCAqIHRoaXMucmVjdC5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGhhbGYgdGhlIGRpYWdvbmFsIGxlbmd0aCBvZiB0aGlzIG5vZGUuXG4gKi9cbkxOb2RlLnByb3RvdHlwZS5nZXRIYWxmVGhlRGlhZ29uYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5yZWN0LmhlaWdodCAqIHRoaXMucmVjdC5oZWlnaHQgKyB0aGlzLnJlY3Qud2lkdGggKiB0aGlzLnJlY3Qud2lkdGgpIC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRSZWN0ID0gZnVuY3Rpb24gKHVwcGVyTGVmdCwgZGltZW5zaW9uKSB7XG4gIHRoaXMucmVjdC54ID0gdXBwZXJMZWZ0Lng7XG4gIHRoaXMucmVjdC55ID0gdXBwZXJMZWZ0Lnk7XG4gIHRoaXMucmVjdC53aWR0aCA9IGRpbWVuc2lvbi53aWR0aDtcbiAgdGhpcy5yZWN0LmhlaWdodCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGN4LCBjeSkge1xuICB0aGlzLnJlY3QueCA9IGN4IC0gdGhpcy5yZWN0LndpZHRoIC8gMjtcbiAgdGhpcy5yZWN0LnkgPSBjeSAtIHRoaXMucmVjdC5oZWlnaHQgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdGhpcy5yZWN0LnggPSB4O1xuICB0aGlzLnJlY3QueSA9IHk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUubW92ZUJ5ID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnJlY3QueCArPSBkeDtcbiAgdGhpcy5yZWN0LnkgKz0gZHk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZUxpc3RUb05vZGUgPSBmdW5jdGlvbiAodG8pIHtcbiAgdmFyIGVkZ2VMaXN0ID0gW107XG4gIHZhciBlZGdlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgPT0gdG8pIHtcbiAgICAgIGlmIChlZGdlLnNvdXJjZSAhPSBzZWxmKSB0aHJvdyBcIkluY29ycmVjdCBlZGdlIHNvdXJjZSFcIjtcblxuICAgICAgZWRnZUxpc3QucHVzaChlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlc0JldHdlZW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgdmFyIGVkZ2VMaXN0ID0gW107XG4gIHZhciBlZGdlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZSA9PSBzZWxmIHx8IGVkZ2UudGFyZ2V0ID09IHNlbGYpKSB0aHJvdyBcIkluY29ycmVjdCBlZGdlIHNvdXJjZSBhbmQvb3IgdGFyZ2V0XCI7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgPT0gb3RoZXIgfHwgZWRnZS5zb3VyY2UgPT0gb3RoZXIpIHtcbiAgICAgIGVkZ2VMaXN0LnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWRnZUxpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5laWdoYm9ycyA9IG5ldyBTZXQoKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKGVkZ2Uuc291cmNlID09IHNlbGYpIHtcbiAgICAgIG5laWdoYm9ycy5hZGQoZWRnZS50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWRnZS50YXJnZXQgIT0gc2VsZikge1xuICAgICAgICB0aHJvdyBcIkluY29ycmVjdCBpbmNpZGVuY3khXCI7XG4gICAgICB9XG5cbiAgICAgIG5laWdoYm9ycy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn07XG5cbkxOb2RlLnByb3RvdHlwZS53aXRoQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3aXRoTmVpZ2hib3JzTGlzdCA9IG5ldyBTZXQoKTtcbiAgdmFyIGNoaWxkTm9kZTtcbiAgdmFyIGNoaWxkcmVuO1xuXG4gIHdpdGhOZWlnaGJvcnNMaXN0LmFkZCh0aGlzKTtcblxuICBpZiAodGhpcy5jaGlsZCAhPSBudWxsKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkTm9kZSA9IG5vZGVzW2ldO1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZE5vZGUud2l0aENoaWxkcmVuKCk7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHdpdGhOZWlnaGJvcnNMaXN0LmFkZChub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aXRoTmVpZ2hib3JzTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXROb09mQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub09mQ2hpbGRyZW4gPSAwO1xuICB2YXIgY2hpbGROb2RlO1xuXG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICBub09mQ2hpbGRyZW4gPSAxO1xuICB9IGVsc2Uge1xuICAgIHZhciBub2RlcyA9IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgbm9PZkNoaWxkcmVuICs9IGNoaWxkTm9kZS5nZXROb09mQ2hpbGRyZW4oKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9PZkNoaWxkcmVuID09IDApIHtcbiAgICBub09mQ2hpbGRyZW4gPSAxO1xuICB9XG4gIHJldHVybiBub09mQ2hpbGRyZW47XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZXN0aW1hdGVkU2l6ZSA9PSBJbnRlZ2VyLk1JTl9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplID0gKHRoaXMucmVjdC53aWR0aCArIHRoaXMucmVjdC5oZWlnaHQpIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSB0aGlzLmNoaWxkLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gICAgdGhpcy5yZWN0LndpZHRoID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICAgIHRoaXMucmVjdC5oZWlnaHQgPSB0aGlzLmVzdGltYXRlZFNpemU7XG5cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICB9XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2NhdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhbmRvbUNlbnRlclg7XG4gIHZhciByYW5kb21DZW50ZXJZO1xuXG4gIHZhciBtaW5YID0gLUxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICB2YXIgbWF4WCA9IExheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICByYW5kb21DZW50ZXJYID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YICsgUmFuZG9tU2VlZC5uZXh0RG91YmxlKCkgKiAobWF4WCAtIG1pblgpICsgbWluWDtcblxuICB2YXIgbWluWSA9IC1MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgdmFyIG1heFkgPSBMYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgcmFuZG9tQ2VudGVyWSA9IExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSArIFJhbmRvbVNlZWQubmV4dERvdWJsZSgpICogKG1heFkgLSBtaW5ZKSArIG1pblk7XG5cbiAgdGhpcy5yZWN0LnggPSByYW5kb21DZW50ZXJYO1xuICB0aGlzLnJlY3QueSA9IHJhbmRvbUNlbnRlclk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICBpZiAodGhpcy5nZXRDaGlsZCgpLmdldE5vZGVzKCkubGVuZ3RoICE9IDApIHtcbiAgICAvLyB3cmFwIHRoZSBjaGlsZHJlbiBub2RlcyBieSByZS1hcnJhbmdpbmcgdGhlIGJvdW5kYXJpZXNcbiAgICB2YXIgY2hpbGRHcmFwaCA9IHRoaXMuZ2V0Q2hpbGQoKTtcbiAgICBjaGlsZEdyYXBoLnVwZGF0ZUJvdW5kcyh0cnVlKTtcblxuICAgIHRoaXMucmVjdC54ID0gY2hpbGRHcmFwaC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yZWN0LnkgPSBjaGlsZEdyYXBoLmdldFRvcCgpO1xuXG4gICAgdGhpcy5zZXRXaWR0aChjaGlsZEdyYXBoLmdldFJpZ2h0KCkgLSBjaGlsZEdyYXBoLmdldExlZnQoKSk7XG4gICAgdGhpcy5zZXRIZWlnaHQoY2hpbGRHcmFwaC5nZXRCb3R0b20oKSAtIGNoaWxkR3JhcGguZ2V0VG9wKCkpO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyAgICBcbiAgICBpZiAoTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjaGlsZEdyYXBoLmdldFJpZ2h0KCkgLSBjaGlsZEdyYXBoLmdldExlZnQoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBjaGlsZEdyYXBoLmdldEJvdHRvbSgpIC0gY2hpbGRHcmFwaC5nZXRUb3AoKTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgIHRoaXMucmVjdC54IC09ICh0aGlzLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB0aGlzLnNldFdpZHRoKHRoaXMubGFiZWxXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsUG9zID09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSAodGhpcy5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3MgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIHRoaXMucmVjdC55IC09IHRoaXMubGFiZWxIZWlnaHQgLSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRIZWlnaHQodGhpcy5sYWJlbEhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0SW5jbHVzaW9uVHJlZURlcHRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pbmNsdXNpb25UcmVlRGVwdGggPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICByZXR1cm4gdGhpcy5pbmNsdXNpb25UcmVlRGVwdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gIHZhciBsZWZ0ID0gdGhpcy5yZWN0Lng7XG5cbiAgaWYgKGxlZnQgPiBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICBsZWZ0ID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9IGVsc2UgaWYgKGxlZnQgPCAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgbGVmdCA9IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH1cblxuICB2YXIgdG9wID0gdGhpcy5yZWN0Lnk7XG5cbiAgaWYgKHRvcCA+IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIHRvcCA9IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfSBlbHNlIGlmICh0b3AgPCAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgdG9wID0gLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfVxuXG4gIHZhciBsZWZ0VG9wID0gbmV3IFBvaW50RChsZWZ0LCB0b3ApO1xuICB2YXIgdkxlZnRUb3AgPSB0cmFucy5pbnZlcnNlVHJhbnNmb3JtUG9pbnQobGVmdFRvcCk7XG5cbiAgdGhpcy5zZXRMb2NhdGlvbih2TGVmdFRvcC54LCB2TGVmdFRvcC55KTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0Lng7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueSArIHRoaXMucmVjdC5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vd25lciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5vd25lci5nZXRQYXJlbnQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTE5vZGU7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBQb2ludEQoeCwgeSkge1xuICBpZiAoeCA9PSBudWxsICYmIHkgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbn1cblxuUG9pbnRELnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gKHgpIHtcbiAgdGhpcy54ID0geDtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uICh5KSB7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLmdldERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHQpIHtcbiAgcmV0dXJuIG5ldyBEaW1lbnNpb25EKHRoaXMueCAtIHB0LngsIHRoaXMueSAtIHB0LnkpO1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXRDb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgdGhpcy54ICs9IGRpbS53aWR0aDtcbiAgdGhpcy55ICs9IGRpbS5oZWlnaHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludEQ7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuZnVuY3Rpb24gTEdyYXBoKHBhcmVudCwgb2JqMiwgdkdyYXBoKSB7XG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZHcmFwaCk7XG4gIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IEludGVnZXIuTUlOX1ZBTFVFO1xuICB0aGlzLm1hcmdpbiA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVBIX01BUkdJTjtcbiAgdGhpcy5lZGdlcyA9IFtdO1xuICB0aGlzLm5vZGVzID0gW107XG4gIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgaWYgKG9iajIgIT0gbnVsbCAmJiBvYmoyIGluc3RhbmNlb2YgTEdyYXBoTWFuYWdlcikge1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyID0gb2JqMjtcbiAgfSBlbHNlIGlmIChvYmoyICE9IG51bGwgJiYgb2JqMiBpbnN0YW5jZW9mIExheW91dCkge1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyID0gb2JqMi5ncmFwaE1hbmFnZXI7XG4gIH1cbn1cblxuTEdyYXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoT2JqZWN0LnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMR3JhcGhbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWRnZXM7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEdyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVmdDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJpZ2h0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRvcDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ib3R0b207XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iajEsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpIHtcbiAgaWYgKHNvdXJjZU5vZGUgPT0gbnVsbCAmJiB0YXJnZXROb2RlID09IG51bGwpIHtcbiAgICB2YXIgbmV3Tm9kZSA9IG9iajE7XG4gICAgaWYgKHRoaXMuZ3JhcGhNYW5hZ2VyID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiR3JhcGggaGFzIG5vIGdyYXBoIG1nciFcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0Tm9kZXMoKS5pbmRleE9mKG5ld05vZGUpID4gLTEpIHtcbiAgICAgIHRocm93IFwiTm9kZSBhbHJlYWR5IGluIGdyYXBoIVwiO1xuICAgIH1cbiAgICBuZXdOb2RlLm93bmVyID0gdGhpcztcbiAgICB0aGlzLmdldE5vZGVzKCkucHVzaChuZXdOb2RlKTtcblxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXdFZGdlID0gb2JqMTtcbiAgICBpZiAoISh0aGlzLmdldE5vZGVzKCkuaW5kZXhPZihzb3VyY2VOb2RlKSA+IC0xICYmIHRoaXMuZ2V0Tm9kZXMoKS5pbmRleE9mKHRhcmdldE5vZGUpID4gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBvciB0YXJnZXQgbm90IGluIGdyYXBoIVwiO1xuICAgIH1cblxuICAgIGlmICghKHNvdXJjZU5vZGUub3duZXIgPT0gdGFyZ2V0Tm9kZS5vd25lciAmJiBzb3VyY2VOb2RlLm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIkJvdGggb3duZXJzIG11c3QgYmUgdGhpcyBncmFwaCFcIjtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlTm9kZS5vd25lciAhPSB0YXJnZXROb2RlLm93bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgc291cmNlIGFuZCB0YXJnZXRcbiAgICBuZXdFZGdlLnNvdXJjZSA9IHNvdXJjZU5vZGU7XG4gICAgbmV3RWRnZS50YXJnZXQgPSB0YXJnZXROb2RlO1xuXG4gICAgLy8gc2V0IGFzIGludHJhLWdyYXBoIGVkZ2VcbiAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IGZhbHNlO1xuXG4gICAgLy8gYWRkIHRvIGdyYXBoIGVkZ2UgbGlzdFxuICAgIHRoaXMuZ2V0RWRnZXMoKS5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgLy8gYWRkIHRvIGluY2lkZW5jeSBsaXN0c1xuICAgIHNvdXJjZU5vZGUuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgIGlmICh0YXJnZXROb2RlICE9IHNvdXJjZU5vZGUpIHtcbiAgICAgIHRhcmdldE5vZGUuZWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWRnZTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBub2RlID0gb2JqO1xuICBpZiAob2JqIGluc3RhbmNlb2YgTE5vZGUpIHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCEobm9kZS5vd25lciAhPSBudWxsICYmIG5vZGUub3duZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiT3duZXIgZ3JhcGggaXMgaW52YWxpZCFcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JhcGhNYW5hZ2VyID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiT3duZXIgZ3JhcGggbWFuYWdlciBpcyBpbnZhbGlkIVwiO1xuICAgIH1cbiAgICAvLyByZW1vdmUgaW5jaWRlbnQgZWRnZXMgZmlyc3QgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgZWRnZXNUb0JlUmVtb3ZlZCA9IG5vZGUuZWRnZXMuc2xpY2UoKTtcbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgcyA9IGVkZ2VzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBlZGdlID0gZWRnZXNUb0JlUmVtb3ZlZFtpXTtcblxuICAgICAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZShlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2Uuc291cmNlLm93bmVyLnJlbW92ZShlZGdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3cgdGhlIG5vZGUgaXRzZWxmXG4gICAgdmFyIGluZGV4ID0gdGhpcy5ub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb2RlIG5vdCBpbiBvd25lciBub2RlIGxpc3QhXCI7XG4gICAgfVxuXG4gICAgdGhpcy5ub2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExFZGdlKSB7XG4gICAgdmFyIGVkZ2UgPSBvYmo7XG4gICAgaWYgKGVkZ2UgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJFZGdlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlICE9IG51bGwgJiYgZWRnZS50YXJnZXQgIT0gbnVsbCkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCEoZWRnZS5zb3VyY2Uub3duZXIgIT0gbnVsbCAmJiBlZGdlLnRhcmdldC5vd25lciAhPSBudWxsICYmIGVkZ2Uuc291cmNlLm93bmVyID09IHRoaXMgJiYgZWRnZS50YXJnZXQub3duZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgb3duZXIgaXMgaW52YWxpZCFcIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5kZXggPSBlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIHZhciB0YXJnZXRJbmRleCA9IGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgaWYgKCEoc291cmNlSW5kZXggPiAtMSAmJiB0YXJnZXRJbmRleCA+IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBkb2Vzbid0IGtub3cgdGhpcyBlZGdlIVwiO1xuICAgIH1cblxuICAgIGVkZ2Uuc291cmNlLmVkZ2VzLnNwbGljZShzb3VyY2VJbmRleCwgMSk7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgIT0gZWRnZS5zb3VyY2UpIHtcbiAgICAgIGVkZ2UudGFyZ2V0LmVkZ2VzLnNwbGljZSh0YXJnZXRJbmRleCwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2Uub3duZXIuZ2V0RWRnZXMoKS5pbmRleE9mKGVkZ2UpO1xuICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb3QgaW4gb3duZXIncyBlZGdlIGxpc3QhXCI7XG4gICAgfVxuXG4gICAgZWRnZS5zb3VyY2Uub3duZXIuZ2V0RWRnZXMoKS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUxlZnRUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b3AgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIGxlZnQgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG5vZGVUb3A7XG4gIHZhciBub2RlTGVmdDtcbiAgdmFyIG1hcmdpbjtcblxuICB2YXIgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuXG4gICAgaWYgKHRvcCA+IG5vZGVUb3ApIHtcbiAgICAgIHRvcCA9IG5vZGVUb3A7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQgPiBub2RlTGVmdCkge1xuICAgICAgbGVmdCA9IG5vZGVMZWZ0O1xuICAgIH1cbiAgfVxuXG4gIC8vIERvIHdlIGhhdmUgYW55IG5vZGVzIGluIHRoaXMgZ3JhcGg/XG4gIGlmICh0b3AgPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdCAhPSB1bmRlZmluZWQpIHtcbiAgICBtYXJnaW4gPSBub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdDtcbiAgfSBlbHNlIHtcbiAgICBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgfVxuXG4gIHRoaXMubGVmdCA9IGxlZnQgLSBtYXJnaW47XG4gIHRoaXMudG9wID0gdG9wIC0gbWFyZ2luO1xuXG4gIC8vIEFwcGx5IHRoZSBtYXJnaW5zIGFuZCByZXR1cm4gdGhlIHJlc3VsdFxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAocmVjdXJzaXZlKSB7XG4gIC8vIGNhbGN1bGF0ZSBib3VuZHNcbiAgdmFyIGxlZnQgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHJpZ2h0ID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBib3R0b20gPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlTGVmdDtcbiAgdmFyIG5vZGVSaWdodDtcbiAgdmFyIG5vZGVUb3A7XG4gIHZhciBub2RlQm90dG9tO1xuICB2YXIgbWFyZ2luO1xuXG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKHJlY3Vyc2l2ZSAmJiBsTm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICBsTm9kZS51cGRhdGVCb3VuZHMoKTtcbiAgICB9XG4gICAgbm9kZUxlZnQgPSBsTm9kZS5nZXRMZWZ0KCk7XG4gICAgbm9kZVJpZ2h0ID0gbE5vZGUuZ2V0UmlnaHQoKTtcbiAgICBub2RlVG9wID0gbE5vZGUuZ2V0VG9wKCk7XG4gICAgbm9kZUJvdHRvbSA9IGxOb2RlLmdldEJvdHRvbSgpO1xuXG4gICAgaWYgKGxlZnQgPiBub2RlTGVmdCkge1xuICAgICAgbGVmdCA9IG5vZGVMZWZ0O1xuICAgIH1cblxuICAgIGlmIChyaWdodCA8IG5vZGVSaWdodCkge1xuICAgICAgcmlnaHQgPSBub2RlUmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRvcCA+IG5vZGVUb3ApIHtcbiAgICAgIHRvcCA9IG5vZGVUb3A7XG4gICAgfVxuXG4gICAgaWYgKGJvdHRvbSA8IG5vZGVCb3R0b20pIHtcbiAgICAgIGJvdHRvbSA9IG5vZGVCb3R0b207XG4gICAgfVxuICB9XG5cbiAgdmFyIGJvdW5kaW5nUmVjdCA9IG5ldyBSZWN0YW5nbGVEKGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICBpZiAobGVmdCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHRoaXMubGVmdCA9IHRoaXMucGFyZW50LmdldExlZnQoKTtcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5wYXJlbnQuZ2V0UmlnaHQoKTtcbiAgICB0aGlzLnRvcCA9IHRoaXMucGFyZW50LmdldFRvcCgpO1xuICAgIHRoaXMuYm90dG9tID0gdGhpcy5wYXJlbnQuZ2V0Qm90dG9tKCk7XG4gIH1cblxuICBpZiAobm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgbWFyZ2luID0gbm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQ7XG4gIH0gZWxzZSB7XG4gICAgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gIH1cblxuICB0aGlzLmxlZnQgPSBib3VuZGluZ1JlY3QueCAtIG1hcmdpbjtcbiAgdGhpcy5yaWdodCA9IGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoICsgbWFyZ2luO1xuICB0aGlzLnRvcCA9IGJvdW5kaW5nUmVjdC55IC0gbWFyZ2luO1xuICB0aGlzLmJvdHRvbSA9IGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCArIG1hcmdpbjtcbn07XG5cbkxHcmFwaC5jYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIGxlZnQgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHJpZ2h0ID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBib3R0b20gPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlTGVmdDtcbiAgdmFyIG5vZGVSaWdodDtcbiAgdmFyIG5vZGVUb3A7XG4gIHZhciBub2RlQm90dG9tO1xuXG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG4gICAgbm9kZUxlZnQgPSBsTm9kZS5nZXRMZWZ0KCk7XG4gICAgbm9kZVJpZ2h0ID0gbE5vZGUuZ2V0UmlnaHQoKTtcbiAgICBub2RlVG9wID0gbE5vZGUuZ2V0VG9wKCk7XG4gICAgbm9kZUJvdHRvbSA9IGxOb2RlLmdldEJvdHRvbSgpO1xuXG4gICAgaWYgKGxlZnQgPiBub2RlTGVmdCkge1xuICAgICAgbGVmdCA9IG5vZGVMZWZ0O1xuICAgIH1cblxuICAgIGlmIChyaWdodCA8IG5vZGVSaWdodCkge1xuICAgICAgcmlnaHQgPSBub2RlUmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRvcCA+IG5vZGVUb3ApIHtcbiAgICAgIHRvcCA9IG5vZGVUb3A7XG4gICAgfVxuXG4gICAgaWYgKGJvdHRvbSA8IG5vZGVCb3R0b20pIHtcbiAgICAgIGJvdHRvbSA9IG5vZGVCb3R0b207XG4gICAgfVxuICB9XG5cbiAgdmFyIGJvdW5kaW5nUmVjdCA9IG5ldyBSZWN0YW5nbGVEKGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuXG4gIHJldHVybiBib3VuZGluZ1JlY3Q7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEluY2x1c2lvblRyZWVEZXB0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMgPT0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEluY2x1c2lvblRyZWVEZXB0aCgpO1xuICB9XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEVzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmVzdGltYXRlZFNpemUgPT0gSW50ZWdlci5NSU5fVkFMVUUpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5jYWxjRXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIHNpemUgKz0gbE5vZGUuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgfVxuXG4gIGlmIChzaXplID09IDApIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBMYXlvdXRDb25zdGFudHMuRU1QVFlfQ09NUE9VTkRfTk9ERV9TSVpFO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IHNpemUgLyBNYXRoLnNxcnQodGhpcy5ub2Rlcy5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMubm9kZXNbMF07XG4gIHZhciBuZWlnaGJvckVkZ2VzO1xuICB2YXIgY3VycmVudE5laWdoYm9yO1xuICB2YXIgY2hpbGRyZW5PZk5vZGUgPSBjdXJyZW50Tm9kZS53aXRoQ2hpbGRyZW4oKTtcbiAgY2hpbGRyZW5PZk5vZGUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgdmlzaXRlZC5hZGQobm9kZSk7XG4gIH0pO1xuXG4gIHdoaWxlIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZVxuICAgIG5laWdoYm9yRWRnZXMgPSBjdXJyZW50Tm9kZS5nZXRFZGdlcygpO1xuICAgIHZhciBzaXplID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHZhciBuZWlnaGJvckVkZ2UgPSBuZWlnaGJvckVkZ2VzW2ldO1xuICAgICAgY3VycmVudE5laWdoYm9yID0gbmVpZ2hib3JFZGdlLmdldE90aGVyRW5kSW5HcmFwaChjdXJyZW50Tm9kZSwgdGhpcyk7XG5cbiAgICAgIC8vIEFkZCB1bnZpc2l0ZWQgbmVpZ2hib3JzIHRvIHRoZSBsaXN0IHRvIHZpc2l0XG4gICAgICBpZiAoY3VycmVudE5laWdoYm9yICE9IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGN1cnJlbnROZWlnaGJvcikpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuT2ZOZWlnaGJvciA9IGN1cnJlbnROZWlnaGJvci53aXRoQ2hpbGRyZW4oKTtcblxuICAgICAgICBjaGlsZHJlbk9mTmVpZ2hib3IuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgICAgICAgdmlzaXRlZC5hZGQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcblxuICBpZiAodmlzaXRlZC5zaXplID49IHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGggPSAwO1xuXG4gICAgdmlzaXRlZC5mb3JFYWNoKGZ1bmN0aW9uICh2aXNpdGVkTm9kZSkge1xuICAgICAgaWYgKHZpc2l0ZWROb2RlLm93bmVyID09IHNlbGYpIHtcbiAgICAgICAgbm9PZlZpc2l0ZWRJblRoaXNHcmFwaCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGggPT0gdGhpcy5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMR3JhcGg7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZnVuY3Rpb24gTEdyYXBoTWFuYWdlcihsYXlvdXQpIHtcbiAgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTsgLy8gSXQgbWF5IGJlIGJldHRlciB0byBpbml0aWxpemUgdGhpcyBvdXQgb2YgdGhpcyBmdW5jdGlvbiBidXQgaXQgZ2l2ZXMgYW4gZXJyb3IgKFJpZ2h0LWhhbmQgc2lkZSBvZiAnaW5zdGFuY2VvZicgaXMgbm90IGNhbGxhYmxlKSBub3cuXG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuXG4gIHRoaXMuZ3JhcGhzID0gW107XG4gIHRoaXMuZWRnZXMgPSBbXTtcbn1cblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuYWRkUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5ncmFwaCA9IHRoaXMubGF5b3V0Lm5ld0dyYXBoKCk7XG4gIHZhciBubm9kZSA9IHRoaXMubGF5b3V0Lm5ld05vZGUobnVsbCk7XG4gIHZhciByb290ID0gdGhpcy5hZGQobmdyYXBoLCBubm9kZSk7XG4gIHRoaXMuc2V0Um9vdEdyYXBoKHJvb3QpO1xuICByZXR1cm4gdGhpcy5yb290R3JhcGg7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmV3R3JhcGgsIHBhcmVudE5vZGUsIG5ld0VkZ2UsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpIHtcbiAgLy90aGVyZSBhcmUganVzdCAyIHBhcmFtZXRlcnMgYXJlIHBhc3NlZCB0aGVuIGl0IGFkZHMgYW4gTEdyYXBoIGVsc2UgaXQgYWRkcyBhbiBMRWRnZVxuICBpZiAobmV3RWRnZSA9PSBudWxsICYmIHNvdXJjZU5vZGUgPT0gbnVsbCAmJiB0YXJnZXROb2RlID09IG51bGwpIHtcbiAgICBpZiAobmV3R3JhcGggPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIlBhcmVudCBub2RlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyYXBocy5pbmRleE9mKG5ld0dyYXBoKSA+IC0xKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGFscmVhZHkgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuXG4gICAgdGhpcy5ncmFwaHMucHVzaChuZXdHcmFwaCk7XG5cbiAgICBpZiAobmV3R3JhcGgucGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHRocm93IFwiQWxyZWFkeSBoYXMgYSBwYXJlbnQhXCI7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlLmNoaWxkICE9IG51bGwpIHtcbiAgICAgIHRocm93IFwiQWxyZWFkeSBoYXMgYSBjaGlsZCFcIjtcbiAgICB9XG5cbiAgICBuZXdHcmFwaC5wYXJlbnQgPSBwYXJlbnROb2RlO1xuICAgIHBhcmVudE5vZGUuY2hpbGQgPSBuZXdHcmFwaDtcblxuICAgIHJldHVybiBuZXdHcmFwaDtcbiAgfSBlbHNlIHtcbiAgICAvL2NoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHBhcmFtZXRlcnNcbiAgICB0YXJnZXROb2RlID0gbmV3RWRnZTtcbiAgICBzb3VyY2VOb2RlID0gcGFyZW50Tm9kZTtcbiAgICBuZXdFZGdlID0gbmV3R3JhcGg7XG4gICAgdmFyIHNvdXJjZUdyYXBoID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuICAgIHZhciB0YXJnZXRHcmFwaCA9IHRhcmdldE5vZGUuZ2V0T3duZXIoKTtcblxuICAgIGlmICghKHNvdXJjZUdyYXBoICE9IG51bGwgJiYgc291cmNlR3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiU291cmNlIG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG4gICAgaWYgKCEodGFyZ2V0R3JhcGggIT0gbnVsbCAmJiB0YXJnZXRHcmFwaC5nZXRHcmFwaE1hbmFnZXIoKSA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJUYXJnZXQgbm90IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VHcmFwaCA9PSB0YXJnZXRHcmFwaCkge1xuICAgICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSBmYWxzZTtcbiAgICAgIHJldHVybiBzb3VyY2VHcmFwaC5hZGQobmV3RWRnZSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gdHJ1ZTtcblxuICAgICAgLy8gc2V0IHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgICBuZXdFZGdlLnNvdXJjZSA9IHNvdXJjZU5vZGU7XG4gICAgICBuZXdFZGdlLnRhcmdldCA9IHRhcmdldE5vZGU7XG5cbiAgICAgIC8vIGFkZCBlZGdlIHRvIGludGVyLWdyYXBoIGVkZ2UgbGlzdFxuICAgICAgaWYgKHRoaXMuZWRnZXMuaW5kZXhPZihuZXdFZGdlKSA+IC0xKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBhbHJlYWR5IGluIGludGVyLWdyYXBoIGVkZ2UgbGlzdCFcIjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgICAvLyBhZGQgZWRnZSB0byBzb3VyY2UgYW5kIHRhcmdldCBpbmNpZGVuY3kgbGlzdHNcbiAgICAgIGlmICghKG5ld0VkZ2Uuc291cmNlICE9IG51bGwgJiYgbmV3RWRnZS50YXJnZXQgIT0gbnVsbCkpIHtcbiAgICAgICAgdGhyb3cgXCJFZGdlIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICghKG5ld0VkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPT0gLTEgJiYgbmV3RWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihuZXdFZGdlKSA9PSAtMSkpIHtcbiAgICAgICAgdGhyb3cgXCJFZGdlIGFscmVhZHkgaW4gc291cmNlIGFuZC9vciB0YXJnZXQgaW5jaWRlbmN5IGxpc3QhXCI7XG4gICAgICB9XG5cbiAgICAgIG5ld0VkZ2Uuc291cmNlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG4gICAgICBuZXdFZGdlLnRhcmdldC5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICB9XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsT2JqKSB7XG4gIGlmIChsT2JqIGluc3RhbmNlb2YgTEdyYXBoKSB7XG4gICAgdmFyIGdyYXBoID0gbE9iajtcbiAgICBpZiAoZ3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgIT0gdGhpcykge1xuICAgICAgdGhyb3cgXCJHcmFwaCBub3QgaW4gdGhpcyBncmFwaCBtZ3JcIjtcbiAgICB9XG4gICAgaWYgKCEoZ3JhcGggPT0gdGhpcy5yb290R3JhcGggfHwgZ3JhcGgucGFyZW50ICE9IG51bGwgJiYgZ3JhcGgucGFyZW50LmdyYXBoTWFuYWdlciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJJbnZhbGlkIHBhcmVudCBub2RlIVwiO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IHRoZSBlZGdlcyAobWFrZSBhIGNvcHkgdG8gZG8gaXQgc2FmZWx5KVxuICAgIHZhciBlZGdlc1RvQmVSZW1vdmVkID0gW107XG5cbiAgICBlZGdlc1RvQmVSZW1vdmVkID0gZWRnZXNUb0JlUmVtb3ZlZC5jb25jYXQoZ3JhcGguZ2V0RWRnZXMoKSk7XG5cbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgcyA9IGVkZ2VzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBlZGdlID0gZWRnZXNUb0JlUmVtb3ZlZFtpXTtcbiAgICAgIGdyYXBoLnJlbW92ZShlZGdlKTtcbiAgICB9XG5cbiAgICAvLyB0aGVuIHRoZSBub2RlcyAobWFrZSBhIGNvcHkgdG8gZG8gaXQgc2FmZWx5KVxuICAgIHZhciBub2Rlc1RvQmVSZW1vdmVkID0gW107XG5cbiAgICBub2Rlc1RvQmVSZW1vdmVkID0gbm9kZXNUb0JlUmVtb3ZlZC5jb25jYXQoZ3JhcGguZ2V0Tm9kZXMoKSk7XG5cbiAgICB2YXIgbm9kZTtcbiAgICBzID0gbm9kZXNUb0JlUmVtb3ZlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1RvQmVSZW1vdmVkW2ldO1xuICAgICAgZ3JhcGgucmVtb3ZlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGdyYXBoIGlzIHRoZSByb290XG4gICAgaWYgKGdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICB0aGlzLnNldFJvb3RHcmFwaChudWxsKTtcbiAgICB9XG5cbiAgICAvLyBub3cgcmVtb3ZlIHRoZSBncmFwaCBpdHNlbGZcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdyYXBocy5pbmRleE9mKGdyYXBoKTtcbiAgICB0aGlzLmdyYXBocy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gYWxzbyByZXNldCB0aGUgcGFyZW50IG9mIHRoZSBncmFwaFxuICAgIGdyYXBoLnBhcmVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAobE9iaiBpbnN0YW5jZW9mIExFZGdlKSB7XG4gICAgZWRnZSA9IGxPYmo7XG4gICAgaWYgKGVkZ2UgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJFZGdlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgIHRocm93IFwiTm90IGFuIGludGVyLWdyYXBoIGVkZ2UhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlICE9IG51bGwgJiYgZWRnZS50YXJnZXQgIT0gbnVsbCkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgaXMgbnVsbCFcIjtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZWRnZSBmcm9tIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzJyBpbmNpZGVuY3kgbGlzdHNcblxuICAgIGlmICghKGVkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YoZWRnZSkgIT0gLTEgJiYgZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKSAhPSAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgZG9lc24ndCBrbm93IHRoaXMgZWRnZSFcIjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2Uuc291cmNlLmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgaW5kZXggPSBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2UudGFyZ2V0LmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAvLyByZW1vdmUgZWRnZSBmcm9tIG93bmVyIGdyYXBoIG1hbmFnZXIncyBpbnRlci1ncmFwaCBlZGdlIGxpc3RcblxuICAgIGlmICghKGVkZ2Uuc291cmNlLm93bmVyICE9IG51bGwgJiYgZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkgIT0gbnVsbCkpIHtcbiAgICAgIHRocm93IFwiRWRnZSBvd25lciBncmFwaCBvciBvd25lciBncmFwaCBtYW5hZ2VyIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmIChlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5pbmRleE9mKGVkZ2UpID09IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vdCBpbiBvd25lciBncmFwaCBtYW5hZ2VyJ3MgZWRnZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJvb3RHcmFwaC51cGRhdGVCb3VuZHModHJ1ZSk7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRHcmFwaHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBocztcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbGxOb2RlcyA9PSBudWxsKSB7XG4gICAgdmFyIG5vZGVMaXN0ID0gW107XG4gICAgdmFyIGdyYXBocyA9IHRoaXMuZ2V0R3JhcGhzKCk7XG4gICAgdmFyIHMgPSBncmFwaHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBub2RlTGlzdCA9IG5vZGVMaXN0LmNvbmNhdChncmFwaHNbaV0uZ2V0Tm9kZXMoKSk7XG4gICAgfVxuICAgIHRoaXMuYWxsTm9kZXMgPSBub2RlTGlzdDtcbiAgfVxuICByZXR1cm4gdGhpcy5hbGxOb2Rlcztcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsTm9kZXMgPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxFZGdlcyA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbGxFZGdlcyA9PSBudWxsKSB7XG4gICAgdmFyIGVkZ2VMaXN0ID0gW107XG4gICAgdmFyIGdyYXBocyA9IHRoaXMuZ2V0R3JhcGhzKCk7XG4gICAgdmFyIHMgPSBncmFwaHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdChncmFwaHNbaV0uZ2V0RWRnZXMoKSk7XG4gICAgfVxuXG4gICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQodGhpcy5lZGdlcyk7XG5cbiAgICB0aGlzLmFsbEVkZ2VzID0gZWRnZUxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYWxsRWRnZXM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb247XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uIChub2RlTGlzdCkge1xuICBpZiAodGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiAhPSBudWxsKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cblxuICB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gbm9kZUxpc3Q7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yb290R3JhcGg7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5zZXRSb290R3JhcGggPSBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgaWYgKGdyYXBoLmdldEdyYXBoTWFuYWdlcigpICE9IHRoaXMpIHtcbiAgICB0aHJvdyBcIlJvb3Qgbm90IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICB9XG5cbiAgdGhpcy5yb290R3JhcGggPSBncmFwaDtcbiAgLy8gcm9vdCBncmFwaCBtdXN0IGhhdmUgYSByb290IG5vZGUgYXNzb2NpYXRlZCB3aXRoIGl0IGZvciBjb252ZW5pZW5jZVxuICBpZiAoZ3JhcGgucGFyZW50ID09IG51bGwpIHtcbiAgICBncmFwaC5wYXJlbnQgPSB0aGlzLmxheW91dC5uZXdOb2RlKFwiUm9vdCBub2RlXCIpO1xuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxheW91dDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmlzT25lQW5jZXN0b3JPZk90aGVyID0gZnVuY3Rpb24gKGZpcnN0Tm9kZSwgc2Vjb25kTm9kZSkge1xuICBpZiAoIShmaXJzdE5vZGUgIT0gbnVsbCAmJiBzZWNvbmROb2RlICE9IG51bGwpKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cblxuICBpZiAoZmlyc3ROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJcyBzZWNvbmQgbm9kZSBhbiBhbmNlc3RvciBvZiB0aGUgZmlyc3Qgb25lP1xuICB2YXIgb3duZXJHcmFwaCA9IGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuICB2YXIgcGFyZW50Tm9kZTtcblxuICBkbyB7XG4gICAgcGFyZW50Tm9kZSA9IG93bmVyR3JhcGguZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvd25lckdyYXBoID0gcGFyZW50Tm9kZS5nZXRPd25lcigpO1xuICAgIGlmIChvd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG4gIC8vIElzIGZpcnN0IG5vZGUgYW4gYW5jZXN0b3Igb2YgdGhlIHNlY29uZCBvbmU/XG4gIG93bmVyR3JhcGggPSBzZWNvbmROb2RlLmdldE93bmVyKCk7XG5cbiAgZG8ge1xuICAgIHBhcmVudE5vZGUgPSBvd25lckdyYXBoLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gZmlyc3ROb2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvd25lckdyYXBoID0gcGFyZW50Tm9kZS5nZXRPd25lcigpO1xuICAgIGlmIChvd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2U7XG4gIHZhciBzb3VyY2VOb2RlO1xuICB2YXIgdGFyZ2V0Tm9kZTtcbiAgdmFyIHNvdXJjZUFuY2VzdG9yR3JhcGg7XG4gIHZhciB0YXJnZXRBbmNlc3RvckdyYXBoO1xuXG4gIHZhciBlZGdlcyA9IHRoaXMuZ2V0QWxsRWRnZXMoKTtcbiAgdmFyIHMgPSBlZGdlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgZWRnZSA9IGVkZ2VzW2ldO1xuXG4gICAgc291cmNlTm9kZSA9IGVkZ2Uuc291cmNlO1xuICAgIHRhcmdldE5vZGUgPSBlZGdlLnRhcmdldDtcbiAgICBlZGdlLmxjYSA9IG51bGw7XG4gICAgZWRnZS5zb3VyY2VJbkxjYSA9IHNvdXJjZU5vZGU7XG4gICAgZWRnZS50YXJnZXRJbkxjYSA9IHRhcmdldE5vZGU7XG5cbiAgICBpZiAoc291cmNlTm9kZSA9PSB0YXJnZXROb2RlKSB7XG4gICAgICBlZGdlLmxjYSA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHNvdXJjZUFuY2VzdG9yR3JhcGggPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG5cbiAgICB3aGlsZSAoZWRnZS5sY2EgPT0gbnVsbCkge1xuICAgICAgZWRnZS50YXJnZXRJbkxjYSA9IHRhcmdldE5vZGU7XG4gICAgICB0YXJnZXRBbmNlc3RvckdyYXBoID0gdGFyZ2V0Tm9kZS5nZXRPd25lcigpO1xuXG4gICAgICB3aGlsZSAoZWRnZS5sY2EgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGFyZ2V0QW5jZXN0b3JHcmFwaCA9PSBzb3VyY2VBbmNlc3RvckdyYXBoKSB7XG4gICAgICAgICAgZWRnZS5sY2EgPSB0YXJnZXRBbmNlc3RvckdyYXBoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldEFuY2VzdG9yR3JhcGggPT0gdGhpcy5yb290R3JhcGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlLmxjYSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWRnZS50YXJnZXRJbkxjYSA9IHRhcmdldEFuY2VzdG9yR3JhcGguZ2V0UGFyZW50KCk7XG4gICAgICAgIHRhcmdldEFuY2VzdG9yR3JhcGggPSBlZGdlLnRhcmdldEluTGNhLmdldE93bmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VBbmNlc3RvckdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWRnZS5sY2EgPT0gbnVsbCkge1xuICAgICAgICBlZGdlLnNvdXJjZUluTGNhID0gc291cmNlQW5jZXN0b3JHcmFwaC5nZXRQYXJlbnQoKTtcbiAgICAgICAgc291cmNlQW5jZXN0b3JHcmFwaCA9IGVkZ2Uuc291cmNlSW5MY2EuZ2V0T3duZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWRnZS5sY2EgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3IgPSBmdW5jdGlvbiAoZmlyc3ROb2RlLCBzZWNvbmROb2RlKSB7XG4gIGlmIChmaXJzdE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgIHJldHVybiBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcbiAgfVxuICB2YXIgZmlyc3RPd25lckdyYXBoID0gZmlyc3ROb2RlLmdldE93bmVyKCk7XG5cbiAgZG8ge1xuICAgIGlmIChmaXJzdE93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBzZWNvbmRPd25lckdyYXBoID0gc2Vjb25kTm9kZS5nZXRPd25lcigpO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNlY29uZE93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlY29uZE93bmVyR3JhcGggPT0gZmlyc3RPd25lckdyYXBoKSB7XG4gICAgICAgIHJldHVybiBzZWNvbmRPd25lckdyYXBoO1xuICAgICAgfVxuICAgICAgc2Vjb25kT3duZXJHcmFwaCA9IHNlY29uZE93bmVyR3JhcGguZ2V0UGFyZW50KCkuZ2V0T3duZXIoKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIGZpcnN0T3duZXJHcmFwaCA9IGZpcnN0T3duZXJHcmFwaC5nZXRQYXJlbnQoKS5nZXRPd25lcigpO1xuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXR1cm4gZmlyc3RPd25lckdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0luY2x1c2lvblRyZWVEZXB0aHMgPSBmdW5jdGlvbiAoZ3JhcGgsIGRlcHRoKSB7XG4gIGlmIChncmFwaCA9PSBudWxsICYmIGRlcHRoID09IG51bGwpIHtcbiAgICBncmFwaCA9IHRoaXMucm9vdEdyYXBoO1xuICAgIGRlcHRoID0gMTtcbiAgfVxuICB2YXIgbm9kZTtcblxuICB2YXIgbm9kZXMgPSBncmFwaC5nZXROb2RlcygpO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICBub2RlID0gbm9kZXNbaV07XG4gICAgbm9kZS5pbmNsdXNpb25UcmVlRGVwdGggPSBkZXB0aDtcblxuICAgIGlmIChub2RlLmNoaWxkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY2FsY0luY2x1c2lvblRyZWVEZXB0aHMobm9kZS5jaGlsZCwgZGVwdGggKyAxKTtcbiAgICB9XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmluY2x1ZGVzSW52YWxpZEVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuXG4gIHZhciBzID0gdGhpcy5lZGdlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgZWRnZSA9IHRoaXMuZWRnZXNbaV07XG5cbiAgICBpZiAodGhpcy5pc09uZUFuY2VzdG9yT2ZPdGhlcihlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMR3JhcGhNYW5hZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0Q29uc3RhbnRzKCkge31cblxuLy9GRExheW91dENvbnN0YW50cyBpbmhlcml0cyBzdGF0aWMgcHJvcHMgaW4gTGF5b3V0Q29uc3RhbnRzXG5mb3IgKHZhciBwcm9wIGluIExheW91dENvbnN0YW50cykge1xuICBGRExheW91dENvbnN0YW50c1twcm9wXSA9IExheW91dENvbnN0YW50c1twcm9wXTtcbn1cblxuRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSAyNTAwO1xuXG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gNTA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSCA9IDAuNDU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSCA9IDQ1MDAuMDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IDAuNDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IDEuMDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSAzLjg7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gMS41O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT04gPSB0cnVlO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OID0gdHJ1ZTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgPSAwLjM7XG5GRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SID0gMC4zMztcbkZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCA9IDEwMDA7XG5GRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgPSA1MDAwO1xuRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMID0gMTAwLjA7XG5GRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUwgKiAzO1xuRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwLjA7XG5GRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgPSAxMDA7XG5GRExheW91dENvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gMC4xO1xuRkRMYXlvdXRDb25zdGFudHMuTUlOX0VER0VfTEVOR1RIID0gMTtcbkZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID0gMTA7XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXRDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgbWFpbnRhaW5zIGEgbGlzdCBvZiBzdGF0aWMgZ2VvbWV0cnkgcmVsYXRlZCB1dGlsaXR5IG1ldGhvZHMuXG4gKlxuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuZnVuY3Rpb24gSUdlb21ldHJ5KCkge31cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzICpoYWxmKiB0aGUgYW1vdW50IGluIHggYW5kIHkgZGlyZWN0aW9ucyBvZiB0aGUgdHdvXG4gKiBpbnB1dCByZWN0YW5nbGVzIG5lZWRlZCB0byBzZXBhcmF0ZSB0aGVtIGtlZXBpbmcgdGhlaXIgcmVzcGVjdGl2ZVxuICogcG9zaXRpb25pbmcsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IGFycmF5LiBBbiBpbnB1dFxuICogc2VwYXJhdGlvbiBidWZmZXIgYWRkZWQgdG8gdGhlIGFtb3VudCBpbiBib3RoIGRpcmVjdGlvbnMuIFdlIGFzc3VtZSB0aGF0XG4gKiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gaW50ZXJzZWN0LlxuICovXG5JR2VvbWV0cnkuY2FsY1NlcGFyYXRpb25BbW91bnQgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdmVybGFwQW1vdW50LCBzZXBhcmF0aW9uQnVmZmVyKSB7XG4gIGlmICghcmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIHZhciBkaXJlY3Rpb25zID0gbmV3IEFycmF5KDIpO1xuXG4gIHRoaXMuZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMocmVjdEEsIHJlY3RCLCBkaXJlY3Rpb25zKTtcblxuICBvdmVybGFwQW1vdW50WzBdID0gTWF0aC5taW4ocmVjdEEuZ2V0UmlnaHQoKSwgcmVjdEIuZ2V0UmlnaHQoKSkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KTtcbiAgb3ZlcmxhcEFtb3VudFsxXSA9IE1hdGgubWluKHJlY3RBLmdldEJvdHRvbSgpLCByZWN0Qi5nZXRCb3R0b20oKSkgLSBNYXRoLm1heChyZWN0QS55LCByZWN0Qi55KTtcblxuICAvLyB1cGRhdGUgdGhlIG92ZXJsYXBwaW5nIGFtb3VudHMgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gIGlmIChyZWN0QS5nZXRYKCkgPD0gcmVjdEIuZ2V0WCgpICYmIHJlY3RBLmdldFJpZ2h0KCkgPj0gcmVjdEIuZ2V0UmlnaHQoKSkge1xuICAgIC8qIENhc2UgeC4xOlxuICAgICpcbiAgICAqIHJlY3RBXG4gICAgKiBcdHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgX19fX19fX19fICAgICAgfFxuICAgICogXHR8ICAgICAgICB8ICAgICAgIHwgICAgICB8XG4gICAgKiBcdHxfX19fX19fX3xfX19fX19ffF9fX19fX3xcbiAgICAqIFx0XHRcdCB8ICAgICAgIHxcbiAgICAqICAgICAgICAgICB8ICAgICAgIHxcbiAgICAqICAgICAgICByZWN0QlxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFswXSArPSBNYXRoLm1pbihyZWN0Qi5nZXRYKCkgLSByZWN0QS5nZXRYKCksIHJlY3RBLmdldFJpZ2h0KCkgLSByZWN0Qi5nZXRSaWdodCgpKTtcbiAgfSBlbHNlIGlmIChyZWN0Qi5nZXRYKCkgPD0gcmVjdEEuZ2V0WCgpICYmIHJlY3RCLmdldFJpZ2h0KCkgPj0gcmVjdEEuZ2V0UmlnaHQoKSkge1xuICAgIC8qIENhc2UgeC4yOlxuICAgICpcbiAgICAqIHJlY3RCXG4gICAgKiBcdHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgX19fX19fX19fICAgICAgfFxuICAgICogXHR8ICAgICAgICB8ICAgICAgIHwgICAgICB8XG4gICAgKiBcdHxfX19fX19fX3xfX19fX19ffF9fX19fX3xcbiAgICAqIFx0XHRcdCB8ICAgICAgIHxcbiAgICAqICAgICAgICAgICB8ICAgICAgIHxcbiAgICAqICAgICAgICByZWN0QVxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFswXSArPSBNYXRoLm1pbihyZWN0QS5nZXRYKCkgLSByZWN0Qi5nZXRYKCksIHJlY3RCLmdldFJpZ2h0KCkgLSByZWN0QS5nZXRSaWdodCgpKTtcbiAgfVxuICBpZiAocmVjdEEuZ2V0WSgpIDw9IHJlY3RCLmdldFkoKSAmJiByZWN0QS5nZXRCb3R0b20oKSA+PSByZWN0Qi5nZXRCb3R0b20oKSkge1xuICAgIC8qIENhc2UgeS4xOlxuICAgICAqICAgICAgICAgIF9fX19fX19fIHJlY3RBXG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8XG4gICAgICogICBfX19fX198X19fXyAgcmVjdEJcbiAgICAgKiAgICAgICAgIHwgICAgfFxuICAgICAqICAgICAgICAgfCAgICB8XG4gICAgICogICBfX19fX198X19fX3xcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxfX19fX19fX1xuICAgICAqXG4gICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFsxXSArPSBNYXRoLm1pbihyZWN0Qi5nZXRZKCkgLSByZWN0QS5nZXRZKCksIHJlY3RBLmdldEJvdHRvbSgpIC0gcmVjdEIuZ2V0Qm90dG9tKCkpO1xuICB9IGVsc2UgaWYgKHJlY3RCLmdldFkoKSA8PSByZWN0QS5nZXRZKCkgJiYgcmVjdEIuZ2V0Qm90dG9tKCkgPj0gcmVjdEEuZ2V0Qm90dG9tKCkpIHtcbiAgICAvKiBDYXNlIHkuMjpcbiAgICAqICAgICAgICAgIF9fX19fX19fIHJlY3RCXG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfFxuICAgICogICBfX19fX198X19fXyAgcmVjdEFcbiAgICAqICAgICAgICAgfCAgICB8XG4gICAgKiAgICAgICAgIHwgICAgfFxuICAgICogICBfX19fX198X19fX3xcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxfX19fX19fX1xuICAgICpcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMV0gKz0gTWF0aC5taW4ocmVjdEEuZ2V0WSgpIC0gcmVjdEIuZ2V0WSgpLCByZWN0Qi5nZXRCb3R0b20oKSAtIHJlY3RBLmdldEJvdHRvbSgpKTtcbiAgfVxuXG4gIC8vIGZpbmQgc2xvcGUgb2YgdGhlIGxpbmUgcGFzc2VzIHR3byBjZW50ZXJzXG4gIHZhciBzbG9wZSA9IE1hdGguYWJzKChyZWN0Qi5nZXRDZW50ZXJZKCkgLSByZWN0QS5nZXRDZW50ZXJZKCkpIC8gKHJlY3RCLmdldENlbnRlclgoKSAtIHJlY3RBLmdldENlbnRlclgoKSkpO1xuICAvLyBpZiBjZW50ZXJzIGFyZSBvdmVybGFwcGVkXG4gIGlmIChyZWN0Qi5nZXRDZW50ZXJZKCkgPT09IHJlY3RBLmdldENlbnRlclkoKSAmJiByZWN0Qi5nZXRDZW50ZXJYKCkgPT09IHJlY3RBLmdldENlbnRlclgoKSkge1xuICAgIC8vIGFzc3VtZSB0aGUgc2xvcGUgaXMgMSAoNDUgZGVncmVlKVxuICAgIHNsb3BlID0gMS4wO1xuICB9XG5cbiAgdmFyIG1vdmVCeVkgPSBzbG9wZSAqIG92ZXJsYXBBbW91bnRbMF07XG4gIHZhciBtb3ZlQnlYID0gb3ZlcmxhcEFtb3VudFsxXSAvIHNsb3BlO1xuICBpZiAob3ZlcmxhcEFtb3VudFswXSA8IG1vdmVCeVgpIHtcbiAgICBtb3ZlQnlYID0gb3ZlcmxhcEFtb3VudFswXTtcbiAgfSBlbHNlIHtcbiAgICBtb3ZlQnlZID0gb3ZlcmxhcEFtb3VudFsxXTtcbiAgfVxuICAvLyByZXR1cm4gaGFsZiB0aGUgYW1vdW50IHNvIHRoYXQgaWYgZWFjaCByZWN0YW5nbGUgaXMgbW92ZWQgYnkgdGhlc2VcbiAgLy8gYW1vdW50cyBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zLCBvdmVybGFwIHdpbGwgYmUgcmVzb2x2ZWRcbiAgb3ZlcmxhcEFtb3VudFswXSA9IC0xICogZGlyZWN0aW9uc1swXSAqIChtb3ZlQnlYIC8gMiArIHNlcGFyYXRpb25CdWZmZXIpO1xuICBvdmVybGFwQW1vdW50WzFdID0gLTEgKiBkaXJlY3Rpb25zWzFdICogKG1vdmVCeVkgLyAyICsgc2VwYXJhdGlvbkJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRlY2lkZXMgdGhlIHNlcGFyYXRpb24gZGlyZWN0aW9uIG9mIG92ZXJsYXBwaW5nIG5vZGVzXG4gKlxuICogaWYgZGlyZWN0aW9uc1swXSA9IC0xLCB0aGVuIHJlY3RBIGdvZXMgbGVmdFxuICogaWYgZGlyZWN0aW9uc1swXSA9IDEsICB0aGVuIHJlY3RBIGdvZXMgcmlnaHRcbiAqIGlmIGRpcmVjdGlvbnNbMV0gPSAtMSwgdGhlbiByZWN0QSBnb2VzIHVwXG4gKiBpZiBkaXJlY3Rpb25zWzFdID0gMSwgIHRoZW4gcmVjdEEgZ29lcyBkb3duXG4gKi9cbklHZW9tZXRyeS5kZWNpZGVEaXJlY3Rpb25zRm9yT3ZlcmxhcHBpbmdOb2RlcyA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIGRpcmVjdGlvbnMpIHtcbiAgaWYgKHJlY3RBLmdldENlbnRlclgoKSA8IHJlY3RCLmdldENlbnRlclgoKSkge1xuICAgIGRpcmVjdGlvbnNbMF0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3Rpb25zWzBdID0gMTtcbiAgfVxuXG4gIGlmIChyZWN0QS5nZXRDZW50ZXJZKCkgPCByZWN0Qi5nZXRDZW50ZXJZKCkpIHtcbiAgICBkaXJlY3Rpb25zWzFdID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0aW9uc1sxXSA9IDE7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIChjbGlwcGluZykgcG9pbnRzIG9mIHRoZSB0d29cbiAqIGlucHV0IHJlY3RhbmdsZXMgd2l0aCBsaW5lIHNlZ21lbnQgZGVmaW5lZCBieSB0aGUgY2VudGVycyBvZiB0aGVzZSB0d29cbiAqIHJlY3RhbmdsZXMuIFRoZSBjbGlwcGluZyBwb2ludHMgYXJlIHNhdmVkIGluIHRoZSBpbnB1dCBkb3VibGUgYXJyYXkgYW5kXG4gKiB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIHJlY3RhbmdsZXMgb3ZlcmxhcCBpcyByZXR1cm5lZC5cbiAqL1xuSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbjIgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCByZXN1bHQpIHtcbiAgLy9yZXN1bHRbMC0xXSB3aWxsIGNvbnRhaW4gY2xpcFBvaW50IG9mIHJlY3RBLCByZXN1bHRbMi0zXSB3aWxsIGNvbnRhaW4gY2xpcFBvaW50IG9mIHJlY3RCXG4gIHZhciBwMXggPSByZWN0QS5nZXRDZW50ZXJYKCk7XG4gIHZhciBwMXkgPSByZWN0QS5nZXRDZW50ZXJZKCk7XG4gIHZhciBwMnggPSByZWN0Qi5nZXRDZW50ZXJYKCk7XG4gIHZhciBwMnkgPSByZWN0Qi5nZXRDZW50ZXJZKCk7XG5cbiAgLy9pZiB0d28gcmVjdGFuZ2xlcyBpbnRlcnNlY3QsIHRoZW4gY2xpcHBpbmcgcG9pbnRzIGFyZSBjZW50ZXJzXG4gIGlmIChyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkge1xuICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvL3ZhcmlhYmxlcyBmb3IgcmVjdEFcbiAgdmFyIHRvcExlZnRBeCA9IHJlY3RBLmdldFgoKTtcbiAgdmFyIHRvcExlZnRBeSA9IHJlY3RBLmdldFkoKTtcbiAgdmFyIHRvcFJpZ2h0QXggPSByZWN0QS5nZXRSaWdodCgpO1xuICB2YXIgYm90dG9tTGVmdEF4ID0gcmVjdEEuZ2V0WCgpO1xuICB2YXIgYm90dG9tTGVmdEF5ID0gcmVjdEEuZ2V0Qm90dG9tKCk7XG4gIHZhciBib3R0b21SaWdodEF4ID0gcmVjdEEuZ2V0UmlnaHQoKTtcbiAgdmFyIGhhbGZXaWR0aEEgPSByZWN0QS5nZXRXaWR0aEhhbGYoKTtcbiAgdmFyIGhhbGZIZWlnaHRBID0gcmVjdEEuZ2V0SGVpZ2h0SGFsZigpO1xuICAvL3ZhcmlhYmxlcyBmb3IgcmVjdEJcbiAgdmFyIHRvcExlZnRCeCA9IHJlY3RCLmdldFgoKTtcbiAgdmFyIHRvcExlZnRCeSA9IHJlY3RCLmdldFkoKTtcbiAgdmFyIHRvcFJpZ2h0QnggPSByZWN0Qi5nZXRSaWdodCgpO1xuICB2YXIgYm90dG9tTGVmdEJ4ID0gcmVjdEIuZ2V0WCgpO1xuICB2YXIgYm90dG9tTGVmdEJ5ID0gcmVjdEIuZ2V0Qm90dG9tKCk7XG4gIHZhciBib3R0b21SaWdodEJ4ID0gcmVjdEIuZ2V0UmlnaHQoKTtcbiAgdmFyIGhhbGZXaWR0aEIgPSByZWN0Qi5nZXRXaWR0aEhhbGYoKTtcbiAgdmFyIGhhbGZIZWlnaHRCID0gcmVjdEIuZ2V0SGVpZ2h0SGFsZigpO1xuXG4gIC8vZmxhZyB3aGV0aGVyIGNsaXBwaW5nIHBvaW50cyBhcmUgZm91bmRcbiAgdmFyIGNsaXBQb2ludEFGb3VuZCA9IGZhbHNlO1xuICB2YXIgY2xpcFBvaW50QkZvdW5kID0gZmFsc2U7XG5cbiAgLy8gbGluZSBpcyB2ZXJ0aWNhbFxuICBpZiAocDF4ID09PSBwMngpIHtcbiAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChwMXkgPCBwMnkpIHtcbiAgICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9ub3QgbGluZSwgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8vIGxpbmUgaXMgaG9yaXpvbnRhbFxuICBlbHNlIGlmIChwMXkgPT09IHAyeSkge1xuICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICByZXN1bHRbMF0gPSB0b3BMZWZ0QXg7XG4gICAgICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICAgICAgcmVzdWx0WzJdID0gdG9wUmlnaHRCeDtcbiAgICAgICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHAxeCA8IHAyeCkge1xuICAgICAgICByZXN1bHRbMF0gPSB0b3BSaWdodEF4O1xuICAgICAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgICAgIHJlc3VsdFsyXSA9IHRvcExlZnRCeDtcbiAgICAgICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL25vdCB2YWxpZCBsaW5lLCByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9zbG9wZXMgb2YgcmVjdEEncyBhbmQgcmVjdEIncyBkaWFnb25hbHNcbiAgICAgIHZhciBzbG9wZUEgPSByZWN0QS5oZWlnaHQgLyByZWN0QS53aWR0aDtcbiAgICAgIHZhciBzbG9wZUIgPSByZWN0Qi5oZWlnaHQgLyByZWN0Qi53aWR0aDtcblxuICAgICAgLy9zbG9wZSBvZiBsaW5lIGJldHdlZW4gY2VudGVyIG9mIHJlY3RBIGFuZCBjZW50ZXIgb2YgcmVjdEJcbiAgICAgIHZhciBzbG9wZVByaW1lID0gKHAyeSAtIHAxeSkgLyAocDJ4IC0gcDF4KTtcbiAgICAgIHZhciBjYXJkaW5hbERpcmVjdGlvbkEgPSB2b2lkIDA7XG4gICAgICB2YXIgY2FyZGluYWxEaXJlY3Rpb25CID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEF4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEF5ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEJ4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEJ5ID0gdm9pZCAwO1xuXG4gICAgICAvL2RldGVybWluZSB3aGV0aGVyIGNsaXBwaW5nIHBvaW50IGlzIHRoZSBjb3JuZXIgb2Ygbm9kZUFcbiAgICAgIGlmICgtc2xvcGVBID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSBib3R0b21MZWZ0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gdG9wUmlnaHRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzbG9wZUEgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICAgIHJlc3VsdFswXSA9IHRvcExlZnRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSBib3R0b21SaWdodEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnQgaXMgdGhlIGNvcm5lciBvZiBub2RlQlxuICAgICAgaWYgKC1zbG9wZUIgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAyeCA+IHAxeCkge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGJvdHRvbUxlZnRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSB0b3BSaWdodEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNsb3BlQiA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDJ4ID4gcDF4KSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gdG9wTGVmdEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGJvdHRvbVJpZ2h0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9pZiBib3RoIGNsaXBwaW5nIHBvaW50cyBhcmUgY29ybmVyc1xuICAgICAgaWYgKGNsaXBQb2ludEFGb3VuZCAmJiBjbGlwUG9pbnRCRm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL2RldGVybWluZSBDYXJkaW5hbCBEaXJlY3Rpb24gb2YgcmVjdGFuZ2xlc1xuICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUEsIHNsb3BlUHJpbWUsIDQpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVCLCBzbG9wZVByaW1lLCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUEsIHNsb3BlUHJpbWUsIDMpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQiwgc2xvcGVQcmltZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUEsIHNsb3BlUHJpbWUsIDEpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQiwgc2xvcGVQcmltZSwgMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUEsIHNsb3BlUHJpbWUsIDIpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVCLCBzbG9wZVByaW1lLCA0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9jYWxjdWxhdGUgY2xpcHBpbmcgUG9pbnQgaWYgaXQgaXMgbm90IGZvdW5kIGJlZm9yZVxuICAgICAgaWYgKCFjbGlwUG9pbnRBRm91bmQpIHtcbiAgICAgICAgc3dpdGNoIChjYXJkaW5hbERpcmVjdGlvbkEpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHRvcExlZnRBeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gcDF4ICsgLWhhbGZIZWlnaHRBIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IGJvdHRvbVJpZ2h0QXg7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHAxeSArIGhhbGZXaWR0aEEgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBwMXggKyBoYWxmSGVpZ2h0QSAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBib3R0b21MZWZ0QXg7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHAxeSArIC1oYWxmV2lkdGhBICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbGlwUG9pbnRCRm91bmQpIHtcbiAgICAgICAgc3dpdGNoIChjYXJkaW5hbERpcmVjdGlvbkIpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHRvcExlZnRCeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gcDJ4ICsgLWhhbGZIZWlnaHRCIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IGJvdHRvbVJpZ2h0Qng7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHAyeSArIGhhbGZXaWR0aEIgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBwMnggKyBoYWxmSGVpZ2h0QiAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBib3R0b21MZWZ0Qng7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHAyeSArIC1oYWxmV2lkdGhCICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGluIHdoaWNoIGNhcmRpbmFsIGRpcmVjdGlvbiBkb2VzIGlucHV0IHBvaW50IHN0YXlzXG4gKiAxOiBOb3J0aFxuICogMjogRWFzdFxuICogMzogU291dGhcbiAqIDQ6IFdlc3RcbiAqL1xuSUdlb21ldHJ5LmdldENhcmRpbmFsRGlyZWN0aW9uID0gZnVuY3Rpb24gKHNsb3BlLCBzbG9wZVByaW1lLCBsaW5lKSB7XG4gIGlmIChzbG9wZSA+IHNsb3BlUHJpbWUpIHtcbiAgICByZXR1cm4gbGluZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMSArIGxpbmUgJSA0O1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIGRlZmluZWQgYnlcbiAqIHBvaW50IHBhaXJzIChzMSxzMikgYW5kIChmMSxmMikuXG4gKi9cbklHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoczEsIHMyLCBmMSwgZjIpIHtcbiAgaWYgKGYyID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnRlcnNlY3Rpb24yKHMxLCBzMiwgZjEpO1xuICB9XG5cbiAgdmFyIHgxID0gczEueDtcbiAgdmFyIHkxID0gczEueTtcbiAgdmFyIHgyID0gczIueDtcbiAgdmFyIHkyID0gczIueTtcbiAgdmFyIHgzID0gZjEueDtcbiAgdmFyIHkzID0gZjEueTtcbiAgdmFyIHg0ID0gZjIueDtcbiAgdmFyIHk0ID0gZjIueTtcbiAgdmFyIHggPSB2b2lkIDAsXG4gICAgICB5ID0gdm9pZCAwOyAvLyBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgdmFyIGExID0gdm9pZCAwLFxuICAgICAgYTIgPSB2b2lkIDAsXG4gICAgICBiMSA9IHZvaWQgMCxcbiAgICAgIGIyID0gdm9pZCAwLFxuICAgICAgYzEgPSB2b2lkIDAsXG4gICAgICBjMiA9IHZvaWQgMDsgLy8gY29lZmZpY2llbnRzIG9mIGxpbmUgZXFucy5cbiAgdmFyIGRlbm9tID0gdm9pZCAwO1xuXG4gIGExID0geTIgLSB5MTtcbiAgYjEgPSB4MSAtIHgyO1xuICBjMSA9IHgyICogeTEgLSB4MSAqIHkyOyAvLyB7IGExKnggKyBiMSp5ICsgYzEgPSAwIGlzIGxpbmUgMSB9XG5cbiAgYTIgPSB5NCAtIHkzO1xuICBiMiA9IHgzIC0geDQ7XG4gIGMyID0geDQgKiB5MyAtIHgzICogeTQ7IC8vIHsgYTIqeCArIGIyKnkgKyBjMiA9IDAgaXMgbGluZSAyIH1cblxuICBkZW5vbSA9IGExICogYjIgLSBhMiAqIGIxO1xuXG4gIGlmIChkZW5vbSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgeCA9IChiMSAqIGMyIC0gYjIgKiBjMSkgLyBkZW5vbTtcbiAgeSA9IChhMiAqIGMxIC0gYTEgKiBjMikgLyBkZW5vbTtcblxuICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBmaW5kcyBhbmQgcmV0dXJucyB0aGUgYW5nbGUgb2YgdGhlIHZlY3RvciBmcm9tIHRoZSArIHgtYXhpc1xuICogaW4gY2xvY2t3aXNlIGRpcmVjdGlvbiAoY29tcGF0aWJsZSB3LyBKYXZhIGNvb3JkaW5hdGUgc3lzdGVtISkuXG4gKi9cbklHZW9tZXRyeS5hbmdsZU9mVmVjdG9yID0gZnVuY3Rpb24gKEN4LCBDeSwgTngsIE55KSB7XG4gIHZhciBDX2FuZ2xlID0gdm9pZCAwO1xuXG4gIGlmIChDeCAhPT0gTngpIHtcbiAgICBDX2FuZ2xlID0gTWF0aC5hdGFuKChOeSAtIEN5KSAvIChOeCAtIEN4KSk7XG5cbiAgICBpZiAoTnggPCBDeCkge1xuICAgICAgQ19hbmdsZSArPSBNYXRoLlBJO1xuICAgIH0gZWxzZSBpZiAoTnkgPCBDeSkge1xuICAgICAgQ19hbmdsZSArPSB0aGlzLlRXT19QSTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnkgPCBDeSkge1xuICAgIENfYW5nbGUgPSB0aGlzLk9ORV9BTkRfSEFMRl9QSTsgLy8gMjcwIGRlZ3JlZXNcbiAgfSBlbHNlIHtcbiAgICBDX2FuZ2xlID0gdGhpcy5IQUxGX1BJOyAvLyA5MCBkZWdyZWVzXG4gIH1cblxuICByZXR1cm4gQ19hbmdsZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHR3byBsaW5lIHNlZ21lbnRzIChvbmUgd2l0aCBwb2ludFxuICogcDEgYW5kIHAyLCB0aGUgb3RoZXIgd2l0aCBwb2ludCBwMyBhbmQgcDQpIGludGVyc2VjdCBhdCBhIHBvaW50IG90aGVyXG4gKiB0aGFuIHRoZXNlIHBvaW50cy5cbiAqL1xuSUdlb21ldHJ5LmRvSW50ZXJzZWN0ID0gZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gIHZhciBhID0gcDEueDtcbiAgdmFyIGIgPSBwMS55O1xuICB2YXIgYyA9IHAyLng7XG4gIHZhciBkID0gcDIueTtcbiAgdmFyIHAgPSBwMy54O1xuICB2YXIgcSA9IHAzLnk7XG4gIHZhciByID0gcDQueDtcbiAgdmFyIHMgPSBwNC55O1xuICB2YXIgZGV0ID0gKGMgLSBhKSAqIChzIC0gcSkgLSAociAtIHApICogKGQgLSBiKTtcblxuICBpZiAoZGV0ID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBsYW1iZGEgPSAoKHMgLSBxKSAqIChyIC0gYSkgKyAocCAtIHIpICogKHMgLSBiKSkgLyBkZXQ7XG4gICAgdmFyIGdhbW1hID0gKChiIC0gZCkgKiAociAtIGEpICsgKGMgLSBhKSAqIChzIC0gYikpIC8gZGV0O1xuICAgIHJldHVybiAwIDwgbGFtYmRhICYmIGxhbWJkYSA8IDEgJiYgMCA8IGdhbW1hICYmIGdhbW1hIDwgMTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IENsYXNzIENvbnN0YW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogU29tZSB1c2VmdWwgcHJlLWNhbGN1bGF0ZWQgY29uc3RhbnRzXG4gKi9cbklHZW9tZXRyeS5IQUxGX1BJID0gMC41ICogTWF0aC5QSTtcbklHZW9tZXRyeS5PTkVfQU5EX0hBTEZfUEkgPSAxLjUgKiBNYXRoLlBJO1xuSUdlb21ldHJ5LlRXT19QSSA9IDIuMCAqIE1hdGguUEk7XG5JR2VvbWV0cnkuVEhSRUVfUEkgPSAzLjAgKiBNYXRoLlBJO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElHZW9tZXRyeTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIElNYXRoKCkge31cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBzaWduIG9mIHRoZSBpbnB1dCB2YWx1ZS5cbiAqL1xuSU1hdGguc2lnbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5JTWF0aC5mbG9vciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCAwID8gTWF0aC5jZWlsKHZhbHVlKSA6IE1hdGguZmxvb3IodmFsdWUpO1xufTtcblxuSU1hdGguY2VpbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCAwID8gTWF0aC5mbG9vcih2YWx1ZSkgOiBNYXRoLmNlaWwodmFsdWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJTWF0aDtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBJbnRlZ2VyKCkge31cblxuSW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuSW50ZWdlci5NSU5fVkFMVUUgPSAtMjE0NzQ4MzY0ODtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBub2RlRnJvbSA9IGZ1bmN0aW9uIG5vZGVGcm9tKHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgbmV4dDogbnVsbCwgcHJldjogbnVsbCB9O1xufTtcblxudmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChwcmV2LCBub2RlLCBuZXh0LCBsaXN0KSB7XG4gIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgcHJldi5uZXh0ID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LmhlYWQgPSBub2RlO1xuICB9XG5cbiAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICBuZXh0LnByZXYgPSBub2RlO1xuICB9IGVsc2Uge1xuICAgIGxpc3QudGFpbCA9IG5vZGU7XG4gIH1cblxuICBub2RlLnByZXYgPSBwcmV2O1xuICBub2RlLm5leHQgPSBuZXh0O1xuXG4gIGxpc3QubGVuZ3RoKys7XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgX3JlbW92ZSA9IGZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgbGlzdCkge1xuICB2YXIgcHJldiA9IG5vZGUucHJldixcbiAgICAgIG5leHQgPSBub2RlLm5leHQ7XG5cblxuICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgIHByZXYubmV4dCA9IG5leHQ7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC5oZWFkID0gbmV4dDtcbiAgfVxuXG4gIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LnRhaWwgPSBwcmV2O1xuICB9XG5cbiAgbm9kZS5wcmV2ID0gbm9kZS5uZXh0ID0gbnVsbDtcblxuICBsaXN0Lmxlbmd0aC0tO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmtlZExpc3QodmFscykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlua2VkTGlzdCk7XG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgaWYgKHZhbHMgIT0gbnVsbCkge1xuICAgICAgdmFscy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wdXNoKHYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmtlZExpc3QsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0QmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZSh2YWwsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUucHJldiwgbm9kZUZyb20odmFsKSwgb3RoZXJOb2RlLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0QWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIodmFsLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLCBub2RlRnJvbSh2YWwpLCBvdGhlck5vZGUubmV4dCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydE5vZGVCZWZvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZUJlZm9yZShuZXdOb2RlLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLnByZXYsIG5ld05vZGUsIG90aGVyTm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydE5vZGVBZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlQWZ0ZXIobmV3Tm9kZSwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZSwgbmV3Tm9kZSwgb3RoZXJOb2RlLm5leHQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godmFsKSB7XG4gICAgICByZXR1cm4gYWRkKHRoaXMudGFpbCwgbm9kZUZyb20odmFsKSwgbnVsbCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2YWwpIHtcbiAgICAgIHJldHVybiBhZGQobnVsbCwgbm9kZUZyb20odmFsKSwgdGhpcy5oZWFkLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShub2RlKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZShub2RlLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMudGFpbCwgdGhpcykudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wTm9kZSgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMudGFpbCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy5oZWFkLCB0aGlzKS52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0Tm9kZSgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMuaGVhZCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldF9vYmplY3RfYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X29iamVjdF9hdChpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDw9IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGkgPCBpbmRleCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRfb2JqZWN0X2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldF9vYmplY3RfYXQoaW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAoaW5kZXggPD0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5rZWRMaXN0O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZExpc3Q7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcclxuICpUaGlzIGNsYXNzIGlzIHRoZSBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBQb2ludC5qYXZhIGNsYXNzIGluIGpka1xyXG4gKi9cbmZ1bmN0aW9uIFBvaW50KHgsIHksIHApIHtcbiAgdGhpcy54ID0gbnVsbDtcbiAgdGhpcy55ID0gbnVsbDtcbiAgaWYgKHggPT0gbnVsbCAmJiB5ID09IG51bGwgJiYgcCA9PSBudWxsKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInICYmIHR5cGVvZiB5ID09ICdudW1iZXInICYmIHAgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfSBlbHNlIGlmICh4LmNvbnN0cnVjdG9yLm5hbWUgPT0gJ1BvaW50JyAmJiB5ID09IG51bGwgJiYgcCA9PSBudWxsKSB7XG4gICAgcCA9IHg7XG4gICAgdGhpcy54ID0gcC54O1xuICAgIHRoaXMueSA9IHAueTtcbiAgfVxufVxuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCBwKSB7XG4gIGlmICh4LmNvbnN0cnVjdG9yLm5hbWUgPT0gJ1BvaW50JyAmJiB5ID09IG51bGwgJiYgcCA9PSBudWxsKSB7XG4gICAgcCA9IHg7XG4gICAgdGhpcy5zZXRMb2NhdGlvbihwLngsIHAueSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT0gJ251bWJlcicgJiYgcCA9PSBudWxsKSB7XG4gICAgLy9pZiBib3RoIHBhcmFtZXRlcnMgYXJlIGludGVnZXIganVzdCBtb3ZlICh4LHkpIGxvY2F0aW9uXG4gICAgaWYgKHBhcnNlSW50KHgpID09IHggJiYgcGFyc2VJbnQoeSkgPT0geSkge1xuICAgICAgdGhpcy5tb3ZlKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggPSBNYXRoLmZsb29yKHggKyAwLjUpO1xuICAgICAgdGhpcy55ID0gTWF0aC5mbG9vcih5ICsgMC41KTtcbiAgICB9XG4gIH1cbn07XG5cblBvaW50LnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn07XG5cblBvaW50LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gIHRoaXMueCArPSBkeDtcbiAgdGhpcy55ICs9IGR5O1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKG9iai5jb25zdHJ1Y3Rvci5uYW1lID09IFwiUG9pbnRcIikge1xuICAgIHZhciBwdCA9IG9iajtcbiAgICByZXR1cm4gdGhpcy54ID09IHB0LnggJiYgdGhpcy55ID09IHB0Lnk7XG4gIH1cbiAgcmV0dXJuIHRoaXMgPT0gb2JqO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50KCkuY29uc3RydWN0b3IubmFtZSArIFwiW3g9XCIgKyB0aGlzLnggKyBcIix5PVwiICsgdGhpcy55ICsgXCJdXCI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJlY3RhbmdsZUQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB0aGlzLnggPSAwO1xuICB0aGlzLnkgPSAwO1xuICB0aGlzLndpZHRoID0gMDtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuXG4gIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsICYmIHdpZHRoICE9IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG59XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gKHgpIHtcbiAgdGhpcy54ID0geDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gKHkpIHtcbiAgdGhpcy55ID0geTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChhKSB7XG4gIGlmICh0aGlzLmdldFJpZ2h0KCkgPCBhLngpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5nZXRCb3R0b20oKSA8IGEueSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLmdldFJpZ2h0KCkgPCB0aGlzLngpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5nZXRCb3R0b20oKSA8IHRoaXMueSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0Q2VudGVyWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWluWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWF4WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpICsgdGhpcy53aWR0aDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldENlbnRlclkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDI7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNaW5ZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRZKCk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNYXhZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRZKCkgKyB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFdpZHRoSGFsZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGggLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0SGVpZ2h0SGFsZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGVpZ2h0IC8gMjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlRDtcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIFVuaXF1ZUlER2VuZXJldG9yKCkge31cblxuVW5pcXVlSURHZW5lcmV0b3IubGFzdElEID0gMDtcblxuVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChVbmlxdWVJREdlbmVyZXRvci5pc1ByaW1pdGl2ZShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAob2JqLnVuaXF1ZUlEICE9IG51bGwpIHtcbiAgICByZXR1cm4gb2JqLnVuaXF1ZUlEO1xuICB9XG4gIG9iai51bmlxdWVJRCA9IFVuaXF1ZUlER2VuZXJldG9yLmdldFN0cmluZygpO1xuICBVbmlxdWVJREdlbmVyZXRvci5sYXN0SUQrKztcbiAgcmV0dXJuIG9iai51bmlxdWVJRDtcbn07XG5cblVuaXF1ZUlER2VuZXJldG9yLmdldFN0cmluZyA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaWQgPT0gbnVsbCkgaWQgPSBVbmlxdWVJREdlbmVyZXRvci5sYXN0SUQ7XG4gIHJldHVybiBcIk9iamVjdCNcIiArIGlkICsgXCJcIjtcbn07XG5cblVuaXF1ZUlER2VuZXJldG9yLmlzUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmcgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihhcmcpO1xuICByZXR1cm4gYXJnID09IG51bGwgfHwgdHlwZSAhPSBcIm9iamVjdFwiICYmIHR5cGUgIT0gXCJmdW5jdGlvblwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlxdWVJREdlbmVyZXRvcjtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG5mdW5jdGlvbiBMYXlvdXQoaXNSZW1vdGVVc2UpIHtcbiAgRW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIC8vTGF5b3V0IFF1YWxpdHk6IDA6ZHJhZnQsIDE6ZGVmYXVsdCwgMjpwcm9vZlxuICB0aGlzLmxheW91dFF1YWxpdHkgPSBMYXlvdXRDb25zdGFudHMuUVVBTElUWTtcbiAgLy9XaGV0aGVyIGxheW91dCBzaG91bGQgY3JlYXRlIGJlbmRwb2ludHMgYXMgbmVlZGVkIG9yIG5vdFxuICB0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICAvL1doZXRoZXIgbGF5b3V0IHNob3VsZCBiZSBpbmNyZW1lbnRhbCBvciBub3RcbiAgdGhpcy5pbmNyZW1lbnRhbCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMO1xuICAvL1doZXRoZXIgd2UgYW5pbWF0ZSBmcm9tIGJlZm9yZSB0byBhZnRlciBsYXlvdXQgbm9kZSBwb3NpdGlvbnNcbiAgdGhpcy5hbmltYXRpb25PbkxheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9PTl9MQVlPVVQ7XG4gIC8vV2hldGhlciB3ZSBhbmltYXRlIHRoZSBsYXlvdXQgcHJvY2VzcyBvciBub3RcbiAgdGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVDtcbiAgLy9OdW1iZXIgaXRlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSBkb25lIGJldHdlZW4gdHdvIHN1Y2Nlc3NpdmUgYW5pbWF0aW9uc1xuICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9QRVJJT0Q7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgb3Igbm90IGxlYWYgbm9kZXMgKG5vbi1jb21wb3VuZCBub2RlcykgYXJlIG9mIHVuaWZvcm0gc2l6ZXMuIFdoZW5cclxuICAgKiB0aGV5IGFyZSwgYm90aCBzcHJpbmcgYW5kIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiB0d28gbGVhZiBub2RlcyBjYW4gYmVcclxuICAgKiBjYWxjdWxhdGVkIHdpdGhvdXQgdGhlIGV4cGVuc2l2ZSBjbGlwcGluZyBwb2ludCBjYWxjdWxhdGlvbnMsIHJlc3VsdGluZ1xyXG4gICAqIGluIG1ham9yIHNwZWVkLXVwLlxyXG4gICAqL1xuICB0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVM7XG4gIC8qKlxyXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpb24gb2YgYmVuZHBvaW50cyBieSB1c2luZyBkdW1teSBub2RlcyBhbmQgZWRnZXMuXHJcbiAgICogTWFwcyBhbiBMRWRnZSB0byBpdHMgZHVtbXkgYmVuZHBvaW50IHBhdGguXHJcbiAgICovXG4gIHRoaXMuZWRnZVRvRHVtbXlOb2RlcyA9IG5ldyBNYXAoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBuZXcgTEdyYXBoTWFuYWdlcih0aGlzKTtcbiAgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gZmFsc2U7XG4gIHRoaXMuaXNTdWJMYXlvdXQgPSBmYWxzZTtcbiAgdGhpcy5pc1JlbW90ZVVzZSA9IGZhbHNlO1xuXG4gIGlmIChpc1JlbW90ZVVzZSAhPSBudWxsKSB7XG4gICAgdGhpcy5pc1JlbW90ZVVzZSA9IGlzUmVtb3RlVXNlO1xuICB9XG59XG5cbkxheW91dC5SQU5ET01fU0VFRCA9IDE7XG5cbkxheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVtaXR0ZXIucHJvdG90eXBlKTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlcjtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ20gPSBuZXcgTEdyYXBoTWFuYWdlcih0aGlzKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcbiAgcmV0dXJuIGdtO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaCA9IGZ1bmN0aW9uICh2R3JhcGgpIHtcbiAgcmV0dXJuIG5ldyBMR3JhcGgobnVsbCwgdGhpcy5ncmFwaE1hbmFnZXIsIHZHcmFwaCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld05vZGUgPSBmdW5jdGlvbiAodk5vZGUpIHtcbiAgcmV0dXJuIG5ldyBMTm9kZSh0aGlzLmdyYXBoTWFuYWdlciwgdk5vZGUpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdFZGdlID0gZnVuY3Rpb24gKHZFZGdlKSB7XG4gIHJldHVybiBuZXcgTEVkZ2UobnVsbCwgbnVsbCwgdkVkZ2UpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5jaGVja0xheW91dFN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkgPT0gbnVsbCB8fCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCB8fCB0aGlzLmdyYXBoTWFuYWdlci5pbmNsdWRlc0ludmFsaWRFZGdlKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnJ1bkxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMudGlsaW5nUHJlTGF5b3V0KSB7XG4gICAgdGhpcy50aWxpbmdQcmVMYXlvdXQoKTtcbiAgfVxuXG4gIHRoaXMuaW5pdFBhcmFtZXRlcnMoKTtcbiAgdmFyIGlzTGF5b3V0U3VjY2Vzc2Z1bGw7XG5cbiAgaWYgKHRoaXMuY2hlY2tMYXlvdXRTdWNjZXNzKCkpIHtcbiAgICBpc0xheW91dFN1Y2Nlc3NmdWxsID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaXNMYXlvdXRTdWNjZXNzZnVsbCA9IHRoaXMubGF5b3V0KCk7XG4gIH1cblxuICBpZiAoTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPT09ICdkdXJpbmcnKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhICdkdXJpbmcnIGxheW91dCBhbmltYXRpb24uIExheW91dCBpcyBub3QgZmluaXNoZWQgeWV0LiBcbiAgICAvLyBXZSBuZWVkIHRvIHBlcmZvcm0gdGhlc2UgaW4gaW5kZXguanMgd2hlbiBsYXlvdXQgaXMgcmVhbGx5IGZpbmlzaGVkLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0xheW91dFN1Y2Nlc3NmdWxsKSB7XG4gICAgaWYgKCF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgICB0aGlzLmRvUG9zdExheW91dCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnRpbGluZ1Bvc3RMYXlvdXQpIHtcbiAgICB0aGlzLnRpbGluZ1Bvc3RMYXlvdXQoKTtcbiAgfVxuXG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IHRydWU7XG5cbiAgcmV0dXJuIGlzTGF5b3V0U3VjY2Vzc2Z1bGw7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgcGVyZm9ybXMgdGhlIG9wZXJhdGlvbnMgcmVxdWlyZWQgYWZ0ZXIgbGF5b3V0LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuZG9Qb3N0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAvL2Fzc2VydCAhaXNTdWJMYXlvdXQgOiBcIlNob3VsZCBub3QgYmUgY2FsbGVkIG9uIHN1Yi1sYXlvdXQhXCI7XG4gIC8vIFByb3BhZ2F0ZSBnZW9tZXRyaWMgY2hhbmdlcyB0byB2LWxldmVsIG9iamVjdHNcbiAgaWYgKCF0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0oKTtcbiAgfVxuICB0aGlzLnVwZGF0ZSgpO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGdlb21ldHJ5IG9mIHRoZSB0YXJnZXQgZ3JhcGggYWNjb3JkaW5nIHRvXHJcbiAqIGNhbGN1bGF0ZWQgbGF5b3V0LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUudXBkYXRlMiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdXBkYXRlIGJlbmQgcG9pbnRzXG4gIGlmICh0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQpIHtcbiAgICB0aGlzLmNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcygpO1xuXG4gICAgLy8gcmVzZXQgYWxsIGVkZ2VzLCBzaW5jZSB0aGUgdG9wb2xvZ3kgaGFzIGNoYW5nZWRcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbEVkZ2VzKCk7XG4gIH1cblxuICAvLyBwZXJmb3JtIGVkZ2UsIG5vZGUgYW5kIHJvb3QgdXBkYXRlcyBpZiBsYXlvdXQgaXMgbm90IGNhbGxlZFxuICAvLyByZW1vdGVseVxuICBpZiAoIXRoaXMuaXNSZW1vdGVVc2UpIHtcbiAgICAvLyB1cGRhdGUgYWxsIGVkZ2VzXG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIGFsbEVkZ2VzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlZGdlID0gYWxsRWRnZXNbaV07XG4gICAgICAvLyAgICAgIHRoaXMudXBkYXRlKGVkZ2UpO1xuICAgIH1cblxuICAgIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSBub2Rlc1xuICAgIHZhciBub2RlO1xuICAgIHZhciBub2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIC8vICAgICAgdGhpcy51cGRhdGUobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHJvb3QgZ3JhcGhcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpO1xuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgdGhpcy51cGRhdGUyKCk7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTE5vZGUpIHtcbiAgICB2YXIgbm9kZSA9IG9iajtcbiAgICBpZiAobm9kZS5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIC8vIHNpbmNlIG5vZGUgaXMgY29tcG91bmQsIHJlY3Vyc2l2ZWx5IHVwZGF0ZSBjaGlsZCBub2Rlc1xuICAgICAgdmFyIG5vZGVzID0gbm9kZS5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZShub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGwtbGV2ZWwgbm9kZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2LWxldmVsIGdyYXBoIG9iamVjdCxcbiAgICAvLyB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdi1sZXZlbCBub2RlIGltcGxlbWVudHMgdGhlXG4gICAgLy8gaW50ZXJmYWNlIFVwZGF0YWJsZS5cbiAgICBpZiAobm9kZS52R3JhcGhPYmplY3QgIT0gbnVsbCkge1xuICAgICAgLy8gY2FzdCB0byBVcGRhdGFibGUgd2l0aG91dCBhbnkgdHlwZSBjaGVja1xuICAgICAgdmFyIHZOb2RlID0gbm9kZS52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdk5vZGUudXBkYXRlKG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIHZhciBlZGdlID0gb2JqO1xuICAgIC8vIGlmIHRoZSBsLWxldmVsIGVkZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgZWRnZSBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG5cbiAgICBpZiAoZWRnZS52R3JhcGhPYmplY3QgIT0gbnVsbCkge1xuICAgICAgLy8gY2FzdCB0byBVcGRhdGFibGUgd2l0aG91dCBhbnkgdHlwZSBjaGVja1xuICAgICAgdmFyIHZFZGdlID0gZWRnZS52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdkVkZ2UudXBkYXRlKGVkZ2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMR3JhcGgpIHtcbiAgICB2YXIgZ3JhcGggPSBvYmo7XG4gICAgLy8gaWYgdGhlIGwtbGV2ZWwgZ3JhcGggaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgb2JqZWN0IGltcGxlbWVudHMgdGhlXG4gICAgLy8gaW50ZXJmYWNlIFVwZGF0YWJsZS5cblxuICAgIGlmIChncmFwaC52R3JhcGhPYmplY3QgIT0gbnVsbCkge1xuICAgICAgLy8gY2FzdCB0byBVcGRhdGFibGUgd2l0aG91dCBhbnkgdHlwZSBjaGVja1xuICAgICAgdmFyIHZHcmFwaCA9IGdyYXBoLnZHcmFwaE9iamVjdDtcblxuICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIG1ldGhvZCBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICB2R3JhcGgudXBkYXRlKGdyYXBoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldCBhbGwgbGF5b3V0IHBhcmFtZXRlcnMgdG8gZGVmYXVsdCB2YWx1ZXNcclxuICogZGV0ZXJtaW5lZCBhdCBjb21waWxlIHRpbWUuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgdGhpcy5sYXlvdXRRdWFsaXR5ID0gTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFk7XG4gICAgdGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVDtcbiAgICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9QRVJJT0Q7XG4gICAgdGhpcy5hbmltYXRpb25PbkxheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9PTl9MQVlPVVQ7XG4gICAgdGhpcy5pbmNyZW1lbnRhbCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMO1xuICAgIHRoaXMuY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gICAgdGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTO1xuICB9XG5cbiAgaWYgKHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0KSB7XG4gICAgdGhpcy5hbmltYXRpb25PbkxheW91dCA9IGZhbHNlO1xuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChuZXdMZWZ0VG9wKSB7XG4gIGlmIChuZXdMZWZ0VG9wID09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudHJhbnNmb3JtKG5ldyBQb2ludEQoMCwgMCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBhIHRyYW5zZm9ybWF0aW9uIG9iamVjdCAoZnJvbSBFY2xpcHNlIHRvIGxheW91dCkuIFdoZW4gYW5cbiAgICAvLyBpbnZlcnNlIHRyYW5zZm9ybSBpcyBhcHBsaWVkLCB3ZSBnZXQgdXBwZXItbGVmdCBjb29yZGluYXRlIG9mIHRoZVxuICAgIC8vIGRyYXdpbmcgb3IgdGhlIHJvb3QgZ3JhcGggYXQgZ2l2ZW4gaW5wdXQgY29vcmRpbmF0ZSAoc29tZSBtYXJnaW5zXG4gICAgLy8gYWxyZWFkeSBpbmNsdWRlZCBpbiBjYWxjdWxhdGlvbiBvZiBsZWZ0LXRvcCkuXG5cbiAgICB2YXIgdHJhbnMgPSBuZXcgVHJhbnNmb3JtKCk7XG4gICAgdmFyIGxlZnRUb3AgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkudXBkYXRlTGVmdFRvcCgpO1xuXG4gICAgaWYgKGxlZnRUb3AgIT0gbnVsbCkge1xuICAgICAgdHJhbnMuc2V0V29ybGRPcmdYKG5ld0xlZnRUb3AueCk7XG4gICAgICB0cmFucy5zZXRXb3JsZE9yZ1kobmV3TGVmdFRvcC55KTtcblxuICAgICAgdHJhbnMuc2V0RGV2aWNlT3JnWChsZWZ0VG9wLngpO1xuICAgICAgdHJhbnMuc2V0RGV2aWNlT3JnWShsZWZ0VG9wLnkpO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gICAgICB2YXIgbm9kZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIG5vZGUudHJhbnNmb3JtKHRyYW5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxheW91dC5wcm90b3R5cGUucG9zaXRpb25Ob2Rlc1JhbmRvbWx5ID0gZnVuY3Rpb24gKGdyYXBoKSB7XG5cbiAgaWYgKGdyYXBoID09IHVuZGVmaW5lZCkge1xuICAgIC8vYXNzZXJ0ICF0aGlzLmluY3JlbWVudGFsO1xuICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KHRoaXMuZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0Um9vdCgpKTtcbiAgICB0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKS51cGRhdGVCb3VuZHModHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxOb2RlO1xuICAgIHZhciBjaGlsZEdyYXBoO1xuXG4gICAgdmFyIG5vZGVzID0gZ3JhcGguZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsTm9kZSA9IG5vZGVzW2ldO1xuICAgICAgY2hpbGRHcmFwaCA9IGxOb2RlLmdldENoaWxkKCk7XG5cbiAgICAgIGlmIChjaGlsZEdyYXBoID09IG51bGwpIHtcbiAgICAgICAgbE5vZGUuc2NhdHRlcigpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZEdyYXBoLmdldE5vZGVzKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgbE5vZGUuc2NhdHRlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFuZG9tbHkoY2hpbGRHcmFwaCk7XG4gICAgICAgIGxOb2RlLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBsaXN0IG9mIHRyZWVzIHdoZXJlIGVhY2ggdHJlZSBpcyByZXByZXNlbnRlZCBhcyBhXHJcbiAqIGxpc3Qgb2YgbC1ub2Rlcy4gVGhlIG1ldGhvZCByZXR1cm5zIGEgbGlzdCBvZiBzaXplIDAgd2hlbjpcclxuICogLSBUaGUgZ3JhcGggaXMgbm90IGZsYXQgb3JcclxuICogLSBPbmUgb2YgdGhlIGNvbXBvbmVudChzKSBvZiB0aGUgZ3JhcGggaXMgbm90IGEgdHJlZS5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmdldEZsYXRGb3Jlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmbGF0Rm9yZXN0ID0gW107XG4gIHZhciBpc0ZvcmVzdCA9IHRydWU7XG5cbiAgLy8gUXVpY2sgcmVmZXJlbmNlIGZvciBhbGwgbm9kZXMgaW4gdGhlIGdyYXBoIG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoXG4gIC8vIHRoaXMgbGF5b3V0LiBUaGUgbGlzdCBzaG91bGQgbm90IGJlIGNoYW5nZWQuXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXROb2RlcygpO1xuXG4gIC8vIEZpcnN0IGJlIHN1cmUgdGhhdCB0aGUgZ3JhcGggaXMgZmxhdFxuICB2YXIgaXNGbGF0ID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFsbE5vZGVzW2ldLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgaXNGbGF0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIGVtcHR5IGZvcmVzdCBpZiB0aGUgZ3JhcGggaXMgbm90IGZsYXQuXG4gIGlmICghaXNGbGF0KSB7XG4gICAgcmV0dXJuIGZsYXRGb3Jlc3Q7XG4gIH1cblxuICAvLyBSdW4gQkZTIGZvciBlYWNoIGNvbXBvbmVudCBvZiB0aGUgZ3JhcGguXG5cbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciB0b0JlVmlzaXRlZCA9IFtdO1xuICB2YXIgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgdmFyIHVuUHJvY2Vzc2VkTm9kZXMgPSBbXTtcblxuICB1blByb2Nlc3NlZE5vZGVzID0gdW5Qcm9jZXNzZWROb2Rlcy5jb25jYXQoYWxsTm9kZXMpO1xuXG4gIC8vIEVhY2ggaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCBmaW5kcyBhIGNvbXBvbmVudCBvZiB0aGUgZ3JhcGggYW5kXG4gIC8vIGRlY2lkZXMgd2hldGhlciBpdCBpcyBhIHRyZWUgb3Igbm90LiBJZiBpdCBpcyBhIHRyZWUsIGFkZHMgaXQgdG8gdGhlXG4gIC8vIGZvcmVzdCBhbmQgY29udGludWVkIHdpdGggdGhlIG5leHQgY29tcG9uZW50LlxuXG4gIHdoaWxlICh1blByb2Nlc3NlZE5vZGVzLmxlbmd0aCA+IDAgJiYgaXNGb3Jlc3QpIHtcbiAgICB0b0JlVmlzaXRlZC5wdXNoKHVuUHJvY2Vzc2VkTm9kZXNbMF0pO1xuXG4gICAgLy8gU3RhcnQgdGhlIEJGUy4gRWFjaCBpdGVyYXRpb24gb2YgdGhpcyBsb29wIHZpc2l0cyBhIG5vZGUgaW4gYVxuICAgIC8vIEJGUyBtYW5uZXIuXG4gICAgd2hpbGUgKHRvQmVWaXNpdGVkLmxlbmd0aCA+IDAgJiYgaXNGb3Jlc3QpIHtcbiAgICAgIC8vcG9vbCBvcGVyYXRpb25cbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRvQmVWaXNpdGVkWzBdO1xuICAgICAgdG9CZVZpc2l0ZWQuc3BsaWNlKDAsIDEpO1xuICAgICAgdmlzaXRlZC5hZGQoY3VycmVudE5vZGUpO1xuXG4gICAgICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZVxuICAgICAgdmFyIG5laWdoYm9yRWRnZXMgPSBjdXJyZW50Tm9kZS5nZXRFZGdlcygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9yRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZXNbaV0uZ2V0T3RoZXJFbmQoY3VycmVudE5vZGUpO1xuXG4gICAgICAgIC8vIElmIEJGUyBpcyBub3QgZ3Jvd2luZyBmcm9tIHRoaXMgbmVpZ2hib3IuXG4gICAgICAgIGlmIChwYXJlbnRzLmdldChjdXJyZW50Tm9kZSkgIT0gY3VycmVudE5laWdoYm9yKSB7XG4gICAgICAgICAgLy8gV2UgaGF2ZW4ndCBwcmV2aW91c2x5IHZpc2l0ZWQgdGhpcyBuZWlnaGJvci5cbiAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGN1cnJlbnROZWlnaGJvcikpIHtcbiAgICAgICAgICAgIHRvQmVWaXNpdGVkLnB1c2goY3VycmVudE5laWdoYm9yKTtcbiAgICAgICAgICAgIHBhcmVudHMuc2V0KGN1cnJlbnROZWlnaGJvciwgY3VycmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaW5jZSB3ZSBoYXZlIHByZXZpb3VzbHkgdmlzaXRlZCB0aGlzIG5laWdoYm9yIGFuZFxuICAgICAgICAgIC8vIHRoaXMgbmVpZ2hib3IgaXMgbm90IHBhcmVudCBvZiBjdXJyZW50Tm9kZSwgZ2l2ZW5cbiAgICAgICAgICAvLyBncmFwaCBjb250YWlucyBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB0cmVlLCBoZW5jZVxuICAgICAgICAgIC8vIGl0IGlzIG5vdCBhIGZvcmVzdC5cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaXNGb3Jlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgZ3JhcGggY29udGFpbnMgYSBjb21wb25lbnQgdGhhdCBpcyBub3QgYSB0cmVlLiBFbXB0eVxuICAgIC8vIHByZXZpb3VzbHkgZm91bmQgdHJlZXMuIFRoZSBtZXRob2Qgd2lsbCBlbmQuXG4gICAgaWYgKCFpc0ZvcmVzdCkge1xuICAgICAgZmxhdEZvcmVzdCA9IFtdO1xuICAgIH1cbiAgICAvLyBTYXZlIGN1cnJlbnRseSB2aXNpdGVkIG5vZGVzIGFzIGEgdHJlZSBpbiBvdXIgZm9yZXN0LiBSZXNldFxuICAgIC8vIHZpc2l0ZWQgYW5kIHBhcmVudHMgbGlzdHMuIENvbnRpbnVlIHdpdGggdGhlIG5leHQgY29tcG9uZW50IG9mXG4gICAgLy8gdGhlIGdyYXBoLCBpZiBhbnkuXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB0ZW1wID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh2aXNpdGVkKSk7XG4gICAgICAgIGZsYXRGb3Jlc3QucHVzaCh0ZW1wKTtcbiAgICAgICAgLy9mbGF0Rm9yZXN0ID0gZmxhdEZvcmVzdC5jb25jYXQodGVtcCk7XG4gICAgICAgIC8vdW5Qcm9jZXNzZWROb2Rlcy5yZW1vdmVBbGwodmlzaXRlZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRlbXBbaV07XG4gICAgICAgICAgdmFyIGluZGV4ID0gdW5Qcm9jZXNzZWROb2Rlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdW5Qcm9jZXNzZWROb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZsYXRGb3Jlc3Q7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgY3JlYXRlcyBkdW1teSBub2RlcyAoYW4gbC1sZXZlbCBub2RlIHdpdGggbWluaW1hbCBkaW1lbnNpb25zKVxyXG4gKiBmb3IgdGhlIGdpdmVuIGVkZ2UgKG9uZSBwZXIgYmVuZHBvaW50KS4gVGhlIGV4aXN0aW5nIGwtbGV2ZWwgc3RydWN0dXJlXHJcbiAqIGlzIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBkdW1teU5vZGVzID0gW107XG4gIHZhciBwcmV2ID0gZWRnZS5zb3VyY2U7XG5cbiAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9yKGVkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlLmJlbmRwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBjcmVhdGUgbmV3IGR1bW15IG5vZGVcbiAgICB2YXIgZHVtbXlOb2RlID0gdGhpcy5uZXdOb2RlKG51bGwpO1xuICAgIGR1bW15Tm9kZS5zZXRSZWN0KG5ldyBQb2ludCgwLCAwKSwgbmV3IERpbWVuc2lvbigxLCAxKSk7XG5cbiAgICBncmFwaC5hZGQoZHVtbXlOb2RlKTtcblxuICAgIC8vIGNyZWF0ZSBuZXcgZHVtbXkgZWRnZSBiZXR3ZWVuIHByZXYgYW5kIGR1bW15IG5vZGVcbiAgICB2YXIgZHVtbXlFZGdlID0gdGhpcy5uZXdFZGdlKG51bGwpO1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLmFkZChkdW1teUVkZ2UsIHByZXYsIGR1bW15Tm9kZSk7XG5cbiAgICBkdW1teU5vZGVzLmFkZChkdW1teU5vZGUpO1xuICAgIHByZXYgPSBkdW1teU5vZGU7XG4gIH1cblxuICB2YXIgZHVtbXlFZGdlID0gdGhpcy5uZXdFZGdlKG51bGwpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5hZGQoZHVtbXlFZGdlLCBwcmV2LCBlZGdlLnRhcmdldCk7XG5cbiAgdGhpcy5lZGdlVG9EdW1teU5vZGVzLnNldChlZGdlLCBkdW1teU5vZGVzKTtcblxuICAvLyByZW1vdmUgcmVhbCBlZGdlIGZyb20gZ3JhcGggbWFuYWdlciBpZiBpdCBpcyBpbnRlci1ncmFwaFxuICBpZiAoZWRnZS5pc0ludGVyR3JhcGgoKSkge1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZShlZGdlKTtcbiAgfVxuICAvLyBlbHNlLCByZW1vdmUgdGhlIGVkZ2UgZnJvbSB0aGUgY3VycmVudCBncmFwaFxuICBlbHNlIHtcbiAgICAgIGdyYXBoLnJlbW92ZShlZGdlKTtcbiAgICB9XG5cbiAgcmV0dXJuIGR1bW15Tm9kZXM7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgY3JlYXRlcyBiZW5kcG9pbnRzIGZvciBlZGdlcyBmcm9tIHRoZSBkdW1teSBub2Rlc1xyXG4gKiBhdCBsLWxldmVsLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuY3JlYXRlQmVuZHBvaW50c0Zyb21EdW1teU5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgZWRnZXMgPSBlZGdlcy5jb25jYXQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKSk7XG4gIGVkZ2VzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmVkZ2VUb0R1bW15Tm9kZXMua2V5cygpKSkuY29uY2F0KGVkZ2VzKTtcblxuICBmb3IgKHZhciBrID0gMDsgayA8IGVkZ2VzLmxlbmd0aDsgaysrKSB7XG4gICAgdmFyIGxFZGdlID0gZWRnZXNba107XG5cbiAgICBpZiAobEVkZ2UuYmVuZHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5nZXQobEVkZ2UpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGR1bW15Tm9kZSA9IHBhdGhbaV07XG4gICAgICAgIHZhciBwID0gbmV3IFBvaW50RChkdW1teU5vZGUuZ2V0Q2VudGVyWCgpLCBkdW1teU5vZGUuZ2V0Q2VudGVyWSgpKTtcblxuICAgICAgICAvLyB1cGRhdGUgYmVuZHBvaW50J3MgbG9jYXRpb24gYWNjb3JkaW5nIHRvIGR1bW15IG5vZGVcbiAgICAgICAgdmFyIGVicCA9IGxFZGdlLmJlbmRwb2ludHMuZ2V0KGkpO1xuICAgICAgICBlYnAueCA9IHAueDtcbiAgICAgICAgZWJwLnkgPSBwLnk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBkdW1teSBub2RlLCBkdW1teSBlZGdlcyBpbmNpZGVudCB3aXRoIHRoaXNcbiAgICAgICAgLy8gZHVtbXkgbm9kZSBpcyBhbHNvIHJlbW92ZWQgKHdpdGhpbiB0aGUgcmVtb3ZlIG1ldGhvZClcbiAgICAgICAgZHVtbXlOb2RlLmdldE93bmVyKCkucmVtb3ZlKGR1bW15Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0aGUgcmVhbCBlZGdlIHRvIGdyYXBoXG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5hZGQobEVkZ2UsIGxFZGdlLnNvdXJjZSwgbEVkZ2UudGFyZ2V0KTtcbiAgICB9XG4gIH1cbn07XG5cbkxheW91dC50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoc2xpZGVyVmFsdWUsIGRlZmF1bHRWYWx1ZSwgbWluRGl2LCBtYXhNdWwpIHtcbiAgaWYgKG1pbkRpdiAhPSB1bmRlZmluZWQgJiYgbWF4TXVsICE9IHVuZGVmaW5lZCkge1xuICAgIHZhciB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcblxuICAgIGlmIChzbGlkZXJWYWx1ZSA8PSA1MCkge1xuICAgICAgdmFyIG1pblZhbHVlID0gZGVmYXVsdFZhbHVlIC8gbWluRGl2O1xuICAgICAgdmFsdWUgLT0gKGRlZmF1bHRWYWx1ZSAtIG1pblZhbHVlKSAvIDUwICogKDUwIC0gc2xpZGVyVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF4VmFsdWUgPSBkZWZhdWx0VmFsdWUgKiBtYXhNdWw7XG4gICAgICB2YWx1ZSArPSAobWF4VmFsdWUgLSBkZWZhdWx0VmFsdWUpIC8gNTAgKiAoc2xpZGVyVmFsdWUgLSA1MCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBhLCBiO1xuXG4gICAgaWYgKHNsaWRlclZhbHVlIDw9IDUwKSB7XG4gICAgICBhID0gOS4wICogZGVmYXVsdFZhbHVlIC8gNTAwLjA7XG4gICAgICBiID0gZGVmYXVsdFZhbHVlIC8gMTAuMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IDkuMCAqIGRlZmF1bHRWYWx1ZSAvIDUwLjA7XG4gICAgICBiID0gLTggKiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBzbGlkZXJWYWx1ZSArIGI7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBmaW5kcyBhbmQgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiBub2RlcywgYXNzdW1pbmdcclxuICogdGhhdCB0aGUgZ2l2ZW4gbm9kZXMgZm9ybSBhIHRyZWUgaW4gdGhlbXNlbHZlcy5cclxuICovXG5MYXlvdXQuZmluZENlbnRlck9mVHJlZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbGlzdCA9IFtdO1xuICBsaXN0ID0gbGlzdC5jb25jYXQobm9kZXMpO1xuXG4gIHZhciByZW1vdmVkTm9kZXMgPSBbXTtcbiAgdmFyIHJlbWFpbmluZ0RlZ3JlZXMgPSBuZXcgTWFwKCk7XG4gIHZhciBmb3VuZENlbnRlciA9IGZhbHNlO1xuICB2YXIgY2VudGVyTm9kZSA9IG51bGw7XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09IDEgfHwgbGlzdC5sZW5ndGggPT0gMikge1xuICAgIGZvdW5kQ2VudGVyID0gdHJ1ZTtcbiAgICBjZW50ZXJOb2RlID0gbGlzdFswXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbGlzdFtpXTtcbiAgICB2YXIgZGVncmVlID0gbm9kZS5nZXROZWlnaGJvcnNMaXN0KCkuc2l6ZTtcbiAgICByZW1haW5pbmdEZWdyZWVzLnNldChub2RlLCBub2RlLmdldE5laWdoYm9yc0xpc3QoKS5zaXplKTtcblxuICAgIGlmIChkZWdyZWUgPT0gMSkge1xuICAgICAgcmVtb3ZlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRlbXBMaXN0ID0gW107XG4gIHRlbXBMaXN0ID0gdGVtcExpc3QuY29uY2F0KHJlbW92ZWROb2Rlcyk7XG5cbiAgd2hpbGUgKCFmb3VuZENlbnRlcikge1xuICAgIHZhciB0ZW1wTGlzdDIgPSBbXTtcbiAgICB0ZW1wTGlzdDIgPSB0ZW1wTGlzdDIuY29uY2F0KHRlbXBMaXN0KTtcbiAgICB0ZW1wTGlzdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGxpc3RbaV07XG5cbiAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihub2RlKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm91cnMgPSBub2RlLmdldE5laWdoYm9yc0xpc3QoKTtcblxuICAgICAgbmVpZ2hib3Vycy5mb3JFYWNoKGZ1bmN0aW9uIChuZWlnaGJvdXIpIHtcbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5pbmRleE9mKG5laWdoYm91cikgPCAwKSB7XG4gICAgICAgICAgdmFyIG90aGVyRGVncmVlID0gcmVtYWluaW5nRGVncmVlcy5nZXQobmVpZ2hib3VyKTtcbiAgICAgICAgICB2YXIgbmV3RGVncmVlID0gb3RoZXJEZWdyZWUgLSAxO1xuXG4gICAgICAgICAgaWYgKG5ld0RlZ3JlZSA9PSAxKSB7XG4gICAgICAgICAgICB0ZW1wTGlzdC5wdXNoKG5laWdoYm91cik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtYWluaW5nRGVncmVlcy5zZXQobmVpZ2hib3VyLCBuZXdEZWdyZWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXMuY29uY2F0KHRlbXBMaXN0KTtcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAxIHx8IGxpc3QubGVuZ3RoID09IDIpIHtcbiAgICAgIGZvdW5kQ2VudGVyID0gdHJ1ZTtcbiAgICAgIGNlbnRlck5vZGUgPSBsaXN0WzBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjZW50ZXJOb2RlO1xufTtcblxuLyoqXHJcbiAqIER1cmluZyB0aGUgY29hcnNlbmluZyBwcm9jZXNzLCB0aGlzIGxheW91dCBtYXkgYmUgcmVmZXJlbmNlZCBieSB0d28gZ3JhcGggbWFuYWdlcnNcclxuICogdGhpcyBzZXR0ZXIgZnVuY3Rpb24gZ3JhbnRzIGFjY2VzcyB0byBjaGFuZ2UgdGhlIGN1cnJlbnRseSBiZWluZyB1c2VkIGdyYXBoIG1hbmFnZXJcclxuICovXG5MYXlvdXQucHJvdG90eXBlLnNldEdyYXBoTWFuYWdlciA9IGZ1bmN0aW9uIChnbSkge1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUmFuZG9tU2VlZCgpIHt9XG4vLyBhZGFwdGVkIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTMwMzcyNVxuUmFuZG9tU2VlZC5zZWVkID0gMTtcblJhbmRvbVNlZWQueCA9IDA7XG5cblJhbmRvbVNlZWQubmV4dERvdWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgUmFuZG9tU2VlZC54ID0gTWF0aC5zaW4oUmFuZG9tU2VlZC5zZWVkKyspICogMTAwMDA7XG4gIHJldHVybiBSYW5kb21TZWVkLnggLSBNYXRoLmZsb29yKFJhbmRvbVNlZWQueCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbVNlZWQ7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybSh4LCB5KSB7XG4gIHRoaXMubHdvcmxkT3JnWCA9IDAuMDtcbiAgdGhpcy5sd29ybGRPcmdZID0gMC4wO1xuICB0aGlzLmxkZXZpY2VPcmdYID0gMC4wO1xuICB0aGlzLmxkZXZpY2VPcmdZID0gMC4wO1xuICB0aGlzLmx3b3JsZEV4dFggPSAxLjA7XG4gIHRoaXMubHdvcmxkRXh0WSA9IDEuMDtcbiAgdGhpcy5sZGV2aWNlRXh0WCA9IDEuMDtcbiAgdGhpcy5sZGV2aWNlRXh0WSA9IDEuMDtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRXb3JsZE9yZ1ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmx3b3JsZE9yZ1g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFdvcmxkT3JnWCA9IGZ1bmN0aW9uICh3b3gpIHtcbiAgdGhpcy5sd29ybGRPcmdYID0gd294O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRXb3JsZE9yZ1kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmx3b3JsZE9yZ1k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFdvcmxkT3JnWSA9IGZ1bmN0aW9uICh3b3kpIHtcbiAgdGhpcy5sd29ybGRPcmdZID0gd295O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRXb3JsZEV4dFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmx3b3JsZEV4dFg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFdvcmxkRXh0WCA9IGZ1bmN0aW9uICh3ZXgpIHtcbiAgdGhpcy5sd29ybGRFeHRYID0gd2V4O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRXb3JsZEV4dFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmx3b3JsZEV4dFk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFdvcmxkRXh0WSA9IGZ1bmN0aW9uICh3ZXkpIHtcbiAgdGhpcy5sd29ybGRFeHRZID0gd2V5O1xufTtcblxuLyogRGV2aWNlIHJlbGF0ZWQgKi9cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VPcmdYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlT3JnWDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlT3JnWCA9IGZ1bmN0aW9uIChkb3gpIHtcbiAgdGhpcy5sZGV2aWNlT3JnWCA9IGRveDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlT3JnWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZU9yZ1k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZU9yZ1kgPSBmdW5jdGlvbiAoZG95KSB7XG4gIHRoaXMubGRldmljZU9yZ1kgPSBkb3k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZUV4dFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VFeHRYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VFeHRYID0gZnVuY3Rpb24gKGRleCkge1xuICB0aGlzLmxkZXZpY2VFeHRYID0gZGV4O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VFeHRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlRXh0WTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlRXh0WSA9IGZ1bmN0aW9uIChkZXkpIHtcbiAgdGhpcy5sZGV2aWNlRXh0WSA9IGRleTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtWCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciB4RGV2aWNlID0gMC4wO1xuICB2YXIgd29ybGRFeHRYID0gdGhpcy5sd29ybGRFeHRYO1xuICBpZiAod29ybGRFeHRYICE9IDAuMCkge1xuICAgIHhEZXZpY2UgPSB0aGlzLmxkZXZpY2VPcmdYICsgKHggLSB0aGlzLmx3b3JsZE9yZ1gpICogdGhpcy5sZGV2aWNlRXh0WCAvIHdvcmxkRXh0WDtcbiAgfVxuXG4gIHJldHVybiB4RGV2aWNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS50cmFuc2Zvcm1ZID0gZnVuY3Rpb24gKHkpIHtcbiAgdmFyIHlEZXZpY2UgPSAwLjA7XG4gIHZhciB3b3JsZEV4dFkgPSB0aGlzLmx3b3JsZEV4dFk7XG4gIGlmICh3b3JsZEV4dFkgIT0gMC4wKSB7XG4gICAgeURldmljZSA9IHRoaXMubGRldmljZU9yZ1kgKyAoeSAtIHRoaXMubHdvcmxkT3JnWSkgKiB0aGlzLmxkZXZpY2VFeHRZIC8gd29ybGRFeHRZO1xuICB9XG5cbiAgcmV0dXJuIHlEZXZpY2U7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmludmVyc2VUcmFuc2Zvcm1YID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIHhXb3JsZCA9IDAuMDtcbiAgdmFyIGRldmljZUV4dFggPSB0aGlzLmxkZXZpY2VFeHRYO1xuICBpZiAoZGV2aWNlRXh0WCAhPSAwLjApIHtcbiAgICB4V29ybGQgPSB0aGlzLmx3b3JsZE9yZ1ggKyAoeCAtIHRoaXMubGRldmljZU9yZ1gpICogdGhpcy5sd29ybGRFeHRYIC8gZGV2aWNlRXh0WDtcbiAgfVxuXG4gIHJldHVybiB4V29ybGQ7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmludmVyc2VUcmFuc2Zvcm1ZID0gZnVuY3Rpb24gKHkpIHtcbiAgdmFyIHlXb3JsZCA9IDAuMDtcbiAgdmFyIGRldmljZUV4dFkgPSB0aGlzLmxkZXZpY2VFeHRZO1xuICBpZiAoZGV2aWNlRXh0WSAhPSAwLjApIHtcbiAgICB5V29ybGQgPSB0aGlzLmx3b3JsZE9yZ1kgKyAoeSAtIHRoaXMubGRldmljZU9yZ1kpICogdGhpcy5sd29ybGRFeHRZIC8gZGV2aWNlRXh0WTtcbiAgfVxuICByZXR1cm4geVdvcmxkO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbiAoaW5Qb2ludCkge1xuICB2YXIgb3V0UG9pbnQgPSBuZXcgUG9pbnREKHRoaXMuaW52ZXJzZVRyYW5zZm9ybVgoaW5Qb2ludC54KSwgdGhpcy5pbnZlcnNlVHJhbnNmb3JtWShpblBvaW50LnkpKTtcbiAgcmV0dXJuIG91dFBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIElNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuZnVuY3Rpb24gRkRMYXlvdXQoKSB7XG4gIExheW91dC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OO1xuICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG4gIHRoaXMuc3ByaW5nQ29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSDtcbiAgdGhpcy5yZXB1bHNpb25Db25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIO1xuICB0aGlzLmdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSDtcbiAgdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSDtcbiAgdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgdGhpcy5kaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlID0gMy4wICogRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwMDtcbiAgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTDtcbiAgdGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gIHRoaXMudG90YWxEaXNwbGFjZW1lbnQgPSAwLjA7XG4gIHRoaXMub2xkVG90YWxEaXNwbGFjZW1lbnQgPSAwLjA7XG4gIHRoaXMubWF4SXRlcmF0aW9ucyA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TO1xufVxuXG5GRExheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExheW91dC5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExheW91dCkge1xuICBGRExheW91dFtwcm9wXSA9IExheW91dFtwcm9wXTtcbn1cblxuRkRMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzLmNhbGwodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLnRvdGFsSXRlcmF0aW9ucyA9IDA7XG4gIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID0gMDtcblxuICB0aGlzLnVzZUZSR3JpZFZhcmlhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9SRVBVTFNJT05fUkFOR0VfQ0FMQ1VMQVRJT047XG5cbiAgdGhpcy5ncmlkID0gW107XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0lkZWFsRWRnZUxlbmd0aHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuICB2YXIgbGNhRGVwdGg7XG4gIHZhciBzb3VyY2U7XG4gIHZhciB0YXJnZXQ7XG4gIHZhciBzaXplT2ZTb3VyY2VJbkxjYTtcbiAgdmFyIHNpemVPZlRhcmdldEluTGNhO1xuXG4gIHZhciBhbGxFZGdlcyA9IHRoaXMuZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0QWxsRWRnZXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIGVkZ2UgPSBhbGxFZGdlc1tpXTtcblxuICAgIGVkZ2UuaWRlYWxMZW5ndGggPSB0aGlzLmlkZWFsRWRnZUxlbmd0aDtcblxuICAgIGlmIChlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgc291cmNlID0gZWRnZS5nZXRTb3VyY2UoKTtcbiAgICAgIHRhcmdldCA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgIHNpemVPZlNvdXJjZUluTGNhID0gZWRnZS5nZXRTb3VyY2VJbkxjYSgpLmdldEVzdGltYXRlZFNpemUoKTtcbiAgICAgIHNpemVPZlRhcmdldEluTGNhID0gZWRnZS5nZXRUYXJnZXRJbkxjYSgpLmdldEVzdGltYXRlZFNpemUoKTtcblxuICAgICAgaWYgKHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbikge1xuICAgICAgICBlZGdlLmlkZWFsTGVuZ3RoICs9IHNpemVPZlNvdXJjZUluTGNhICsgc2l6ZU9mVGFyZ2V0SW5MY2EgLSAyICogTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkU7XG4gICAgICB9XG5cbiAgICAgIGxjYURlcHRoID0gZWRnZS5nZXRMY2EoKS5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKTtcblxuICAgICAgZWRnZS5pZGVhbExlbmd0aCArPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICogRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiAqIChzb3VyY2UuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCkgKyB0YXJnZXQuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCkgLSAyICogbGNhRGVwdGgpO1xuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmluaXRTcHJpbmdFbWJlZGRlciA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG4gIGlmICh0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgaWYgKHMgPiBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KHRoaXMuY29vbGluZ0ZhY3RvciAqIEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IsIHRoaXMuY29vbGluZ0ZhY3RvciAtIChzIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAvIChGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpICogdGhpcy5jb29saW5nRmFjdG9yICogKDEgLSBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SKSk7XG4gICAgfVxuICAgIHRoaXMubWF4Tm9kZURpc3BsYWNlbWVudCA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocyA+IEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkge1xuICAgICAgdGhpcy5jb29saW5nRmFjdG9yID0gTWF0aC5tYXgoRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiwgMS4wIC0gKHMgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIC8gKEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgKiAoMSAtIEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb29saW5nRmFjdG9yID0gMS4wO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yID0gdGhpcy5jb29saW5nRmFjdG9yO1xuICAgIHRoaXMubWF4Tm9kZURpc3BsYWNlbWVudCA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVDtcbiAgfVxuXG4gIHRoaXMubWF4SXRlcmF0aW9ucyA9IE1hdGgubWF4KHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGggKiA1LCB0aGlzLm1heEl0ZXJhdGlvbnMpO1xuXG4gIHRoaXMudG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQgPSB0aGlzLmRpc3BsYWNlbWVudFRocmVzaG9sZFBlck5vZGUgKiB0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoO1xuXG4gIHRoaXMucmVwdWxzaW9uUmFuZ2UgPSB0aGlzLmNhbGNSZXB1bHNpb25SYW5nZSgpO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNTcHJpbmdGb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsRWRnZXMgPSB0aGlzLmdldEFsbEVkZ2VzKCk7XG4gIHZhciBlZGdlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZWRnZSA9IGxFZGdlc1tpXTtcblxuICAgIHRoaXMuY2FsY1NwcmluZ0ZvcmNlKGVkZ2UsIGVkZ2UuaWRlYWxMZW5ndGgpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvbkZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdyaWRVcGRhdGVBbGxvd2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICB2YXIgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGksIGo7XG4gIHZhciBub2RlQSwgbm9kZUI7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gIHZhciBwcm9jZXNzZWROb2RlU2V0O1xuXG4gIGlmICh0aGlzLnVzZUZSR3JpZFZhcmlhbnQpIHtcbiAgICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9PSAxICYmIGdyaWRVcGRhdGVBbGxvd2VkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzZWROb2RlU2V0ID0gbmV3IFNldCgpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBlYWNoIG5vZGVzIGFuZCBpdHMgc3Vycm91bmRpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlQSA9IGxOb2Rlc1tpXTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlKG5vZGVBLCBwcm9jZXNzZWROb2RlU2V0LCBncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSk7XG4gICAgICBwcm9jZXNzZWROb2RlU2V0LmFkZChub2RlQSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuXG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBub2RlQiA9IGxOb2Rlc1tqXTtcblxuICAgICAgICAvLyBJZiBib3RoIG5vZGVzIGFyZSBub3QgbWVtYmVycyBvZiB0aGUgc2FtZSBncmFwaCwgc2tpcC5cbiAgICAgICAgaWYgKG5vZGVBLmdldE93bmVyKCkgIT0gbm9kZUIuZ2V0T3duZXIoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2Uobm9kZUEsIG5vZGVCKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjR3Jhdml0YXRpb25hbEZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGU7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIHRoaXMuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZShub2RlKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLm1vdmVOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIG5vZGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIG5vZGUubW92ZSgpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1NwcmluZ0ZvcmNlID0gZnVuY3Rpb24gKGVkZ2UsIGlkZWFsTGVuZ3RoKSB7XG4gIHZhciBzb3VyY2VOb2RlID0gZWRnZS5nZXRTb3VyY2UoKTtcbiAgdmFyIHRhcmdldE5vZGUgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gIHZhciBsZW5ndGg7XG4gIHZhciBzcHJpbmdGb3JjZTtcbiAgdmFyIHNwcmluZ0ZvcmNlWDtcbiAgdmFyIHNwcmluZ0ZvcmNlWTtcblxuICAvLyBVcGRhdGUgZWRnZSBsZW5ndGhcbiAgaWYgKHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgJiYgc291cmNlTm9kZS5nZXRDaGlsZCgpID09IG51bGwgJiYgdGFyZ2V0Tm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICBlZGdlLnVwZGF0ZUxlbmd0aFNpbXBsZSgpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UudXBkYXRlTGVuZ3RoKCk7XG5cbiAgICBpZiAoZWRnZS5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsZW5ndGggPSBlZGdlLmdldExlbmd0aCgpO1xuXG4gIGlmIChsZW5ndGggPT0gMCkgcmV0dXJuO1xuXG4gIC8vIENhbGN1bGF0ZSBzcHJpbmcgZm9yY2VzXG4gIHNwcmluZ0ZvcmNlID0gdGhpcy5zcHJpbmdDb25zdGFudCAqIChsZW5ndGggLSBpZGVhbExlbmd0aCk7XG5cbiAgLy8gUHJvamVjdCBmb3JjZSBvbnRvIHggYW5kIHkgYXhlc1xuICBzcHJpbmdGb3JjZVggPSBzcHJpbmdGb3JjZSAqIChlZGdlLmxlbmd0aFggLyBsZW5ndGgpO1xuICBzcHJpbmdGb3JjZVkgPSBzcHJpbmdGb3JjZSAqIChlZGdlLmxlbmd0aFkgLyBsZW5ndGgpO1xuXG4gIC8vIEFwcGx5IGZvcmNlcyBvbiB0aGUgZW5kIG5vZGVzXG4gIHNvdXJjZU5vZGUuc3ByaW5nRm9yY2VYICs9IHNwcmluZ0ZvcmNlWDtcbiAgc291cmNlTm9kZS5zcHJpbmdGb3JjZVkgKz0gc3ByaW5nRm9yY2VZO1xuICB0YXJnZXROb2RlLnNwcmluZ0ZvcmNlWCAtPSBzcHJpbmdGb3JjZVg7XG4gIHRhcmdldE5vZGUuc3ByaW5nRm9yY2VZIC09IHNwcmluZ0ZvcmNlWTtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uRm9yY2UgPSBmdW5jdGlvbiAobm9kZUEsIG5vZGVCKSB7XG4gIHZhciByZWN0QSA9IG5vZGVBLmdldFJlY3QoKTtcbiAgdmFyIHJlY3RCID0gbm9kZUIuZ2V0UmVjdCgpO1xuICB2YXIgb3ZlcmxhcEFtb3VudCA9IG5ldyBBcnJheSgyKTtcbiAgdmFyIGNsaXBQb2ludHMgPSBuZXcgQXJyYXkoNCk7XG4gIHZhciBkaXN0YW5jZVg7XG4gIHZhciBkaXN0YW5jZVk7XG4gIHZhciBkaXN0YW5jZVNxdWFyZWQ7XG4gIHZhciBkaXN0YW5jZTtcbiAgdmFyIHJlcHVsc2lvbkZvcmNlO1xuICB2YXIgcmVwdWxzaW9uRm9yY2VYO1xuICB2YXIgcmVwdWxzaW9uRm9yY2VZO1xuXG4gIGlmIChyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkgLy8gdHdvIG5vZGVzIG92ZXJsYXBcbiAgICB7XG4gICAgICAvLyBjYWxjdWxhdGUgc2VwYXJhdGlvbiBhbW91bnQgaW4geCBhbmQgeSBkaXJlY3Rpb25zXG4gICAgICBJR2VvbWV0cnkuY2FsY1NlcGFyYXRpb25BbW91bnQocmVjdEEsIHJlY3RCLCBvdmVybGFwQW1vdW50LCBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMi4wKTtcblxuICAgICAgcmVwdWxzaW9uRm9yY2VYID0gMiAqIG92ZXJsYXBBbW91bnRbMF07XG4gICAgICByZXB1bHNpb25Gb3JjZVkgPSAyICogb3ZlcmxhcEFtb3VudFsxXTtcblxuICAgICAgdmFyIGNoaWxkcmVuQ29uc3RhbnQgPSBub2RlQS5ub09mQ2hpbGRyZW4gKiBub2RlQi5ub09mQ2hpbGRyZW4gLyAobm9kZUEubm9PZkNoaWxkcmVuICsgbm9kZUIubm9PZkNoaWxkcmVuKTtcblxuICAgICAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSB0d28gbm9kZXNcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWCAtPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VZIC09IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVk7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVggKz0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWSArPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VZO1xuICAgIH0gZWxzZSAvLyBubyBvdmVybGFwXG4gICAge1xuICAgICAgLy8gY2FsY3VsYXRlIGRpc3RhbmNlXG5cbiAgICAgIGlmICh0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzICYmIG5vZGVBLmdldENoaWxkKCkgPT0gbnVsbCAmJiBub2RlQi5nZXRDaGlsZCgpID09IG51bGwpIC8vIHNpbXBseSBiYXNlIHJlcHVsc2lvbiBvbiBkaXN0YW5jZSBvZiBub2RlIGNlbnRlcnNcbiAgICAgICAge1xuICAgICAgICAgIGRpc3RhbmNlWCA9IHJlY3RCLmdldENlbnRlclgoKSAtIHJlY3RBLmdldENlbnRlclgoKTtcbiAgICAgICAgICBkaXN0YW5jZVkgPSByZWN0Qi5nZXRDZW50ZXJZKCkgLSByZWN0QS5nZXRDZW50ZXJZKCk7XG4gICAgICAgIH0gZWxzZSAvLyB1c2UgY2xpcHBpbmcgcG9pbnRzXG4gICAgICAgIHtcbiAgICAgICAgICBJR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uKHJlY3RBLCByZWN0QiwgY2xpcFBvaW50cyk7XG5cbiAgICAgICAgICBkaXN0YW5jZVggPSBjbGlwUG9pbnRzWzJdIC0gY2xpcFBvaW50c1swXTtcbiAgICAgICAgICBkaXN0YW5jZVkgPSBjbGlwUG9pbnRzWzNdIC0gY2xpcFBvaW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBObyByZXB1bHNpb24gcmFuZ2UuIEZSIGdyaWQgdmFyaWFudCBzaG91bGQgdGFrZSBjYXJlIG9mIHRoaXMuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VYKSA8IEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCkge1xuICAgICAgICBkaXN0YW5jZVggPSBJTWF0aC5zaWduKGRpc3RhbmNlWCkgKiBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVkpIDwgRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUKSB7XG4gICAgICAgIGRpc3RhbmNlWSA9IElNYXRoLnNpZ24oZGlzdGFuY2VZKSAqIEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVDtcbiAgICAgIH1cblxuICAgICAgZGlzdGFuY2VTcXVhcmVkID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXVhcmVkKTtcblxuICAgICAgcmVwdWxzaW9uRm9yY2UgPSB0aGlzLnJlcHVsc2lvbkNvbnN0YW50ICogbm9kZUEubm9PZkNoaWxkcmVuICogbm9kZUIubm9PZkNoaWxkcmVuIC8gZGlzdGFuY2VTcXVhcmVkO1xuXG4gICAgICAvLyBQcm9qZWN0IGZvcmNlIG9udG8geCBhbmQgeSBheGVzXG4gICAgICByZXB1bHNpb25Gb3JjZVggPSByZXB1bHNpb25Gb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgICAgcmVwdWxzaW9uRm9yY2VZID0gcmVwdWxzaW9uRm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcblxuICAgICAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSB0d28gbm9kZXMgICAgXG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVggLT0gcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VZIC09IHJlcHVsc2lvbkZvcmNlWTtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWCArPSByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVkgKz0gcmVwdWxzaW9uRm9yY2VZO1xuICAgIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjR3Jhdml0YXRpb25hbEZvcmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIG93bmVyR3JhcGg7XG4gIHZhciBvd25lckNlbnRlclg7XG4gIHZhciBvd25lckNlbnRlclk7XG4gIHZhciBkaXN0YW5jZVg7XG4gIHZhciBkaXN0YW5jZVk7XG4gIHZhciBhYnNEaXN0YW5jZVg7XG4gIHZhciBhYnNEaXN0YW5jZVk7XG4gIHZhciBlc3RpbWF0ZWRTaXplO1xuICBvd25lckdyYXBoID0gbm9kZS5nZXRPd25lcigpO1xuXG4gIG93bmVyQ2VudGVyWCA9IChvd25lckdyYXBoLmdldFJpZ2h0KCkgKyBvd25lckdyYXBoLmdldExlZnQoKSkgLyAyO1xuICBvd25lckNlbnRlclkgPSAob3duZXJHcmFwaC5nZXRUb3AoKSArIG93bmVyR3JhcGguZ2V0Qm90dG9tKCkpIC8gMjtcbiAgZGlzdGFuY2VYID0gbm9kZS5nZXRDZW50ZXJYKCkgLSBvd25lckNlbnRlclg7XG4gIGRpc3RhbmNlWSA9IG5vZGUuZ2V0Q2VudGVyWSgpIC0gb3duZXJDZW50ZXJZO1xuICBhYnNEaXN0YW5jZVggPSBNYXRoLmFicyhkaXN0YW5jZVgpICsgbm9kZS5nZXRXaWR0aCgpIC8gMjtcbiAgYWJzRGlzdGFuY2VZID0gTWF0aC5hYnMoZGlzdGFuY2VZKSArIG5vZGUuZ2V0SGVpZ2h0KCkgLyAyO1xuXG4gIGlmIChub2RlLmdldE93bmVyKCkgPT0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKSAvLyBpbiB0aGUgcm9vdCBncmFwaFxuICAgIHtcbiAgICAgIGVzdGltYXRlZFNpemUgPSBvd25lckdyYXBoLmdldEVzdGltYXRlZFNpemUoKSAqIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yO1xuXG4gICAgICBpZiAoYWJzRGlzdGFuY2VYID4gZXN0aW1hdGVkU2l6ZSB8fCBhYnNEaXN0YW5jZVkgPiBlc3RpbWF0ZWRTaXplKSB7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVggPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVg7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVkgPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVk7XG4gICAgICB9XG4gICAgfSBlbHNlIC8vIGluc2lkZSBhIGNvbXBvdW5kXG4gICAge1xuICAgICAgZXN0aW1hdGVkU2l6ZSA9IG93bmVyR3JhcGguZ2V0RXN0aW1hdGVkU2l6ZSgpICogdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvcjtcblxuICAgICAgaWYgKGFic0Rpc3RhbmNlWCA+IGVzdGltYXRlZFNpemUgfHwgYWJzRGlzdGFuY2VZID4gZXN0aW1hdGVkU2l6ZSkge1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VYID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VYICogdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudDtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWSA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWSAqIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQ7XG4gICAgICB9XG4gICAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmlzQ29udmVyZ2VkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udmVyZ2VkO1xuICB2YXIgb3NjaWxhdGluZyA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyA+IHRoaXMubWF4SXRlcmF0aW9ucyAvIDMpIHtcbiAgICBvc2NpbGF0aW5nID0gTWF0aC5hYnModGhpcy50b3RhbERpc3BsYWNlbWVudCAtIHRoaXMub2xkVG90YWxEaXNwbGFjZW1lbnQpIDwgMjtcbiAgfVxuXG4gIGNvbnZlcmdlZCA9IHRoaXMudG90YWxEaXNwbGFjZW1lbnQgPCB0aGlzLnRvdGFsRGlzcGxhY2VtZW50VGhyZXNob2xkO1xuXG4gIHRoaXMub2xkVG90YWxEaXNwbGFjZW1lbnQgPSB0aGlzLnRvdGFsRGlzcGxhY2VtZW50O1xuXG4gIHJldHVybiBjb252ZXJnZWQgfHwgb3NjaWxhdGluZztcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQgJiYgIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICBpZiAodGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMgPT0gdGhpcy5hbmltYXRpb25QZXJpb2QpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zKys7XG4gICAgfVxuICB9XG59O1xuXG4vL1RoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiAod2VpZ2h0KSBmb3IgYWxsIG5vZGVzXG5GRExheW91dC5wcm90b3R5cGUuY2FsY05vT2ZDaGlsZHJlbkZvckFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZTtcbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIG5vZGUubm9PZkNoaWxkcmVuID0gbm9kZS5nZXROb09mQ2hpbGRyZW4oKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IEZSLUdyaWQgVmFyaWFudCBSZXB1bHNpb24gRm9yY2UgQ2FsY3VsYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjR3JpZCA9IGZ1bmN0aW9uIChncmFwaCkge1xuXG4gIHZhciBzaXplWCA9IDA7XG4gIHZhciBzaXplWSA9IDA7XG5cbiAgc2l6ZVggPSBwYXJzZUludChNYXRoLmNlaWwoKGdyYXBoLmdldFJpZ2h0KCkgLSBncmFwaC5nZXRMZWZ0KCkpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBzaXplWSA9IHBhcnNlSW50KE1hdGguY2VpbCgoZ3JhcGguZ2V0Qm90dG9tKCkgLSBncmFwaC5nZXRUb3AoKSkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG5cbiAgdmFyIGdyaWQgPSBuZXcgQXJyYXkoc2l6ZVgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVg7IGkrKykge1xuICAgIGdyaWRbaV0gPSBuZXcgQXJyYXkoc2l6ZVkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplWTsgaisrKSB7XG4gICAgICBncmlkW2ldW2pdID0gbmV3IEFycmF5KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdyaWQ7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuYWRkTm9kZVRvR3JpZCA9IGZ1bmN0aW9uICh2LCBsZWZ0LCB0b3ApIHtcblxuICB2YXIgc3RhcnRYID0gMDtcbiAgdmFyIGZpbmlzaFggPSAwO1xuICB2YXIgc3RhcnRZID0gMDtcbiAgdmFyIGZpbmlzaFkgPSAwO1xuXG4gIHN0YXJ0WCA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLnggLSBsZWZ0KSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgZmluaXNoWCA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLndpZHRoICsgdi5nZXRSZWN0KCkueCAtIGxlZnQpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBzdGFydFkgPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS55IC0gdG9wKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgZmluaXNoWSA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLmhlaWdodCArIHYuZ2V0UmVjdCgpLnkgLSB0b3ApIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydFg7IGkgPD0gZmluaXNoWDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IHN0YXJ0WTsgaiA8PSBmaW5pc2hZOyBqKyspIHtcbiAgICAgIHRoaXMuZ3JpZFtpXVtqXS5wdXNoKHYpO1xuICAgICAgdi5zZXRHcmlkQ29vcmRpbmF0ZXMoc3RhcnRYLCBmaW5pc2hYLCBzdGFydFksIGZpbmlzaFkpO1xuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLnVwZGF0ZUdyaWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICB2YXIgbm9kZUE7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG5cbiAgdGhpcy5ncmlkID0gdGhpcy5jYWxjR3JpZCh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpO1xuXG4gIC8vIHB1dCBhbGwgbm9kZXMgdG8gcHJvcGVyIGdyaWQgY2VsbHNcbiAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuICAgIHRoaXMuYWRkTm9kZVRvR3JpZChub2RlQSwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldExlZnQoKSwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldFRvcCgpKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGN1bGF0ZVJlcHVsc2lvbkZvcmNlT2ZBTm9kZSA9IGZ1bmN0aW9uIChub2RlQSwgcHJvY2Vzc2VkTm9kZVNldCwgZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpIHtcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9PSAxICYmIGdyaWRVcGRhdGVBbGxvd2VkIHx8IGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpIHtcbiAgICB2YXIgc3Vycm91bmRpbmcgPSBuZXcgU2V0KCk7XG4gICAgbm9kZUEuc3Vycm91bmRpbmcgPSBuZXcgQXJyYXkoKTtcbiAgICB2YXIgbm9kZUI7XG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQ7XG5cbiAgICBmb3IgKHZhciBpID0gbm9kZUEuc3RhcnRYIC0gMTsgaSA8IG5vZGVBLmZpbmlzaFggKyAyOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSBub2RlQS5zdGFydFkgLSAxOyBqIDwgbm9kZUEuZmluaXNoWSArIDI7IGorKykge1xuICAgICAgICBpZiAoIShpIDwgMCB8fCBqIDwgMCB8fCBpID49IGdyaWQubGVuZ3RoIHx8IGogPj0gZ3JpZFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBncmlkW2ldW2pdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBub2RlQiA9IGdyaWRbaV1bal1ba107XG5cbiAgICAgICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIG5vdCBtZW1iZXJzIG9mIHRoZSBzYW1lIGdyYXBoLCBcbiAgICAgICAgICAgIC8vIG9yIGJvdGggbm9kZXMgYXJlIHRoZSBzYW1lLCBza2lwLlxuICAgICAgICAgICAgaWYgKG5vZGVBLmdldE93bmVyKCkgIT0gbm9kZUIuZ2V0T3duZXIoKSB8fCBub2RlQSA9PSBub2RlQikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHJlcHVsc2lvbiBmb3JjZSBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBub2RlQSBhbmQgbm9kZUIgaGFzIGFscmVhZHkgYmVlbiBjYWxjdWxhdGVkXG4gICAgICAgICAgICBpZiAoIXByb2Nlc3NlZE5vZGVTZXQuaGFzKG5vZGVCKSAmJiAhc3Vycm91bmRpbmcuaGFzKG5vZGVCKSkge1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5hYnMobm9kZUEuZ2V0Q2VudGVyWCgpIC0gbm9kZUIuZ2V0Q2VudGVyWCgpKSAtIChub2RlQS5nZXRXaWR0aCgpIC8gMiArIG5vZGVCLmdldFdpZHRoKCkgLyAyKTtcbiAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlWSA9IE1hdGguYWJzKG5vZGVBLmdldENlbnRlclkoKSAtIG5vZGVCLmdldENlbnRlclkoKSkgLSAobm9kZUEuZ2V0SGVpZ2h0KCkgLyAyICsgbm9kZUIuZ2V0SGVpZ2h0KCkgLyAyKTtcblxuICAgICAgICAgICAgICAvLyBpZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBub2RlQSBhbmQgbm9kZUIgXG4gICAgICAgICAgICAgIC8vIGlzIGxlc3MgdGhlbiBjYWxjdWxhdGlvbiByYW5nZVxuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VYIDw9IHRoaXMucmVwdWxzaW9uUmFuZ2UgJiYgZGlzdGFuY2VZIDw9IHRoaXMucmVwdWxzaW9uUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAvL3RoZW4gYWRkIG5vZGVCIHRvIHN1cnJvdW5kaW5nIG9mIG5vZGVBXG4gICAgICAgICAgICAgICAgc3Vycm91bmRpbmcuYWRkKG5vZGVCKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGVBLnN1cnJvdW5kaW5nID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShzdXJyb3VuZGluZykpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBub2RlQS5zdXJyb3VuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuY2FsY1JlcHVsc2lvbkZvcmNlKG5vZGVBLCBub2RlQS5zdXJyb3VuZGluZ1tpXSk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAwLjA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5mdW5jdGlvbiBGRExheW91dEVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIExFZGdlLmNhbGwodGhpcywgc291cmNlLCB0YXJnZXQsIHZFZGdlKTtcbiAgdGhpcy5pZGVhbExlbmd0aCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG59XG5cbkZETGF5b3V0RWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExFZGdlLnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTEVkZ2UpIHtcbiAgRkRMYXlvdXRFZGdlW3Byb3BdID0gTEVkZ2VbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXRFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0Tm9kZShnbSwgbG9jLCBzaXplLCB2Tm9kZSkge1xuICAvLyBhbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciBpcyBoYW5kbGVkIGluc2lkZSBMTm9kZVxuICBMTm9kZS5jYWxsKHRoaXMsIGdtLCBsb2MsIHNpemUsIHZOb2RlKTtcbiAgLy9TcHJpbmcsIHJlcHVsc2lvbiBhbmQgZ3Jhdml0YXRpb25hbCBmb3JjZXMgYWN0aW5nIG9uIHRoaXMgbm9kZVxuICB0aGlzLnNwcmluZ0ZvcmNlWCA9IDA7XG4gIHRoaXMuc3ByaW5nRm9yY2VZID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVggPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVggPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZID0gMDtcbiAgLy9BbW91bnQgYnkgd2hpY2ggdGhpcyBub2RlIGlzIHRvIGJlIG1vdmVkIGluIHRoaXMgaXRlcmF0aW9uXG4gIHRoaXMuZGlzcGxhY2VtZW50WCA9IDA7XG4gIHRoaXMuZGlzcGxhY2VtZW50WSA9IDA7XG5cbiAgLy9TdGFydCBhbmQgZmluaXNoIGdyaWQgY29vcmRpbmF0ZXMgdGhhdCB0aGlzIG5vZGUgaXMgZmFsbGVuIGludG9cbiAgdGhpcy5zdGFydFggPSAwO1xuICB0aGlzLmZpbmlzaFggPSAwO1xuICB0aGlzLnN0YXJ0WSA9IDA7XG4gIHRoaXMuZmluaXNoWSA9IDA7XG5cbiAgLy9HZW9tZXRyaWMgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZVxuICB0aGlzLnN1cnJvdW5kaW5nID0gW107XG59XG5cbkZETGF5b3V0Tm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExOb2RlLnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTE5vZGUpIHtcbiAgRkRMYXlvdXROb2RlW3Byb3BdID0gTE5vZGVbcHJvcF07XG59XG5cbkZETGF5b3V0Tm9kZS5wcm90b3R5cGUuc2V0R3JpZENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKF9zdGFydFgsIF9maW5pc2hYLCBfc3RhcnRZLCBfZmluaXNoWSkge1xuICB0aGlzLnN0YXJ0WCA9IF9zdGFydFg7XG4gIHRoaXMuZmluaXNoWCA9IF9maW5pc2hYO1xuICB0aGlzLnN0YXJ0WSA9IF9zdGFydFk7XG4gIHRoaXMuZmluaXNoWSA9IF9maW5pc2hZO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dE5vZGU7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gRGltZW5zaW9uRCh3aWR0aCwgaGVpZ2h0KSB7XG4gIHRoaXMud2lkdGggPSAwO1xuICB0aGlzLmhlaWdodCA9IDA7XG4gIGlmICh3aWR0aCAhPT0gbnVsbCAmJiBoZWlnaHQgIT09IG51bGwpIHtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIH1cbn1cblxuRGltZW5zaW9uRC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoO1xufTtcblxuRGltZW5zaW9uRC5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xufTtcblxuRGltZW5zaW9uRC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oZWlnaHQ7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaW1lbnNpb25EO1xuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBVbmlxdWVJREdlbmVyZXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5mdW5jdGlvbiBIYXNoTWFwKCkge1xuICB0aGlzLm1hcCA9IHt9O1xuICB0aGlzLmtleXMgPSBbXTtcbn1cblxuSGFzaE1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQoa2V5KTtcbiAgaWYgKCF0aGlzLmNvbnRhaW5zKHRoZUlkKSkge1xuICAgIHRoaXMubWFwW3RoZUlkXSA9IHZhbHVlO1xuICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gIH1cbn07XG5cbkhhc2hNYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICByZXR1cm4gdGhpcy5tYXBba2V5XSAhPSBudWxsO1xufTtcblxuSGFzaE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICByZXR1cm4gdGhpcy5tYXBbdGhlSWRdO1xufTtcblxuSGFzaE1hcC5wcm90b3R5cGUua2V5U2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5rZXlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoTWFwO1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBVbmlxdWVJREdlbmVyZXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5mdW5jdGlvbiBIYXNoU2V0KCkge1xuICB0aGlzLnNldCA9IHt9O1xufVxuO1xuXG5IYXNoU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKG9iaik7XG4gIGlmICghdGhpcy5jb250YWlucyh0aGVJZCkpIHRoaXMuc2V0W3RoZUlkXSA9IG9iajtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgZGVsZXRlIHRoaXMuc2V0W1VuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKG9iaildO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2V0ID0ge307XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRoaXMuc2V0W1VuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKG9iaildID09IG9iajtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNldCkubGVuZ3RoO1xufTtcblxuLy9jb25jYXRzIHRoaXMuc2V0IHRvIHRoZSBnaXZlbiBsaXN0XG5IYXNoU2V0LnByb3RvdHlwZS5hZGRBbGxUbyA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zZXQpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0LnB1c2godGhpcy5zZXRba2V5c1tpXV0pO1xuICB9XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXQpLmxlbmd0aDtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gIHZhciBzID0gbGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIHYgPSBsaXN0W2ldO1xuICAgIHRoaXMuYWRkKHYpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hTZXQ7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBBIGNsYXNzaWMgUXVpY2tzb3J0IGFsZ29yaXRobSB3aXRoIEhvYXJlJ3MgcGFydGl0aW9uXG4gKiAtIFdvcmtzIGFsc28gb24gTGlua2VkTGlzdCBvYmplY3RzXG4gKlxuICogQ29weXJpZ2h0OiBpLVZpcyBSZXNlYXJjaCBHcm91cCwgQmlsa2VudCBVbml2ZXJzaXR5LCAyMDA3IC0gcHJlc2VudFxuICovXG5cbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBRdWlja3NvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVpY2tzb3J0KEEsIGNvbXBhcmVGdW5jdGlvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVpY2tzb3J0KTtcblxuICAgICAgICBpZiAoY29tcGFyZUZ1bmN0aW9uICE9PSBudWxsIHx8IGNvbXBhcmVGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB0aGlzLmNvbXBhcmVGdW5jdGlvbiA9IHRoaXMuX2RlZmF1bHRDb21wYXJlRnVuY3Rpb247XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBMaW5rZWRMaXN0KSBsZW5ndGggPSBBLnNpemUoKTtlbHNlIGxlbmd0aCA9IEEubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCAwLCBsZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUXVpY2tzb3J0LCBbe1xuICAgICAgICBrZXk6ICdfcXVpY2tzb3J0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9xdWlja3NvcnQoQSwgcCwgcikge1xuICAgICAgICAgICAgaWYgKHAgPCByKSB7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSB0aGlzLl9wYXJ0aXRpb24oQSwgcCwgcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVpY2tzb3J0KEEsIHAsIHEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCBxICsgMSwgcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19wYXJ0aXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnRpdGlvbihBLCBwLCByKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuX2dldChBLCBwKTtcbiAgICAgICAgICAgIHZhciBpID0gcDtcbiAgICAgICAgICAgIHZhciBqID0gcjtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29tcGFyZUZ1bmN0aW9uKHgsIHRoaXMuX2dldChBLCBqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH13aGlsZSAodGhpcy5jb21wYXJlRnVuY3Rpb24odGhpcy5fZ2V0KEEsIGkpLCB4KSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfWlmIChpIDwgaikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKEEsIGksIGopO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgcmV0dXJuIGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldChvYmplY3QsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTGlua2VkTGlzdCkgcmV0dXJuIG9iamVjdC5nZXRfb2JqZWN0X2F0KGluZGV4KTtlbHNlIHJldHVybiBvYmplY3RbaW5kZXhdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXQob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBMaW5rZWRMaXN0KSBvYmplY3Quc2V0X29iamVjdF9hdChpbmRleCwgdmFsdWUpO2Vsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfc3dhcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3dhcChBLCBpLCBqKSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMuX2dldChBLCBpKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChBLCBpLCB0aGlzLl9nZXQoQSwgaikpO1xuICAgICAgICAgICAgdGhpcy5fc2V0KEEsIGosIHRlbXApO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZGVmYXVsdENvbXBhcmVGdW5jdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVmYXVsdENvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiA+IGE7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUXVpY2tzb3J0O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1aWNrc29ydDtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqICAgTmVlZGxlbWFuLVd1bnNjaCBhbGdvcml0aG0gaXMgYW4gcHJvY2VkdXJlIHRvIGNvbXB1dGUgdGhlIG9wdGltYWwgZ2xvYmFsIGFsaWdubWVudCBvZiB0d28gc3RyaW5nXG4gKiAgIHNlcXVlbmNlcyBieSBTLkIuTmVlZGxlbWFuIGFuZCBDLkQuV3Vuc2NoICgxOTcwKS5cbiAqXG4gKiAgIEFzaWRlIGZyb20gdGhlIGlucHV0cywgeW91IGNhbiBhc3NpZ24gdGhlIHNjb3JlcyBmb3IsXG4gKiAgIC0gTWF0Y2g6IFRoZSB0d28gY2hhcmFjdGVycyBhdCB0aGUgY3VycmVudCBpbmRleCBhcmUgc2FtZS5cbiAqICAgLSBNaXNtYXRjaDogVGhlIHR3byBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IGluZGV4IGFyZSBkaWZmZXJlbnQuXG4gKiAgIC0gSW5zZXJ0aW9uL0RlbGV0aW9uKGdhcHMpOiBUaGUgYmVzdCBhbGlnbm1lbnQgaW52b2x2ZXMgb25lIGxldHRlciBhbGlnbmluZyB0byBhIGdhcCBpbiB0aGUgb3RoZXIgc3RyaW5nLlxuICovXG5cbnZhciBOZWVkbGVtYW5XdW5zY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmVlZGxlbWFuV3Vuc2NoKHNlcXVlbmNlMSwgc2VxdWVuY2UyKSB7XG4gICAgICAgIHZhciBtYXRjaF9zY29yZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICAgICAgdmFyIG1pc21hdGNoX3BlbmFsdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IC0xO1xuICAgICAgICB2YXIgZ2FwX3BlbmFsdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IC0xO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOZWVkbGVtYW5XdW5zY2gpO1xuXG4gICAgICAgIHRoaXMuc2VxdWVuY2UxID0gc2VxdWVuY2UxO1xuICAgICAgICB0aGlzLnNlcXVlbmNlMiA9IHNlcXVlbmNlMjtcbiAgICAgICAgdGhpcy5tYXRjaF9zY29yZSA9IG1hdGNoX3Njb3JlO1xuICAgICAgICB0aGlzLm1pc21hdGNoX3BlbmFsdHkgPSBtaXNtYXRjaF9wZW5hbHR5O1xuICAgICAgICB0aGlzLmdhcF9wZW5hbHR5ID0gZ2FwX3BlbmFsdHk7XG5cbiAgICAgICAgLy8gSnVzdCB0aGUgcmVtb3ZlIHJlZHVuZGFuY3lcbiAgICAgICAgdGhpcy5pTWF4ID0gc2VxdWVuY2UxLmxlbmd0aCArIDE7XG4gICAgICAgIHRoaXMuak1heCA9IHNlcXVlbmNlMi5sZW5ndGggKyAxO1xuXG4gICAgICAgIC8vIEdyaWQgbWF0cml4IG9mIHNjb3Jlc1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgQXJyYXkodGhpcy5pTWF4KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlNYXg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ncmlkW2ldID0gbmV3IEFycmF5KHRoaXMuak1heCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5qTWF4OyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbaV1bal0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2ViYWNrIG1hdHJpeCAoMkQgYXJyYXksIGVhY2ggY2VsbCBpcyBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlcyBmb3IgW2BEaWFnYCwgYFVwYCwgYExlZnRgXSBwb3NpdGlvbnMpXG4gICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZCA9IG5ldyBBcnJheSh0aGlzLmlNYXgpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5pTWF4OyBfaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbX2ldID0gbmV3IEFycmF5KHRoaXMuak1heCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCB0aGlzLmpNYXg7IF9qKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbX2ldW19qXSA9IFtudWxsLCBudWxsLCBudWxsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBhbGlnbmVkIHNlcXVlbmNlcyAocmV0dXJuIG11bHRpcGxlIHBvc3NpYmlsaXRpZXMpXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IFtdO1xuXG4gICAgICAgIC8vIEZpbmFsIGFsaWdubWVudCBzY29yZVxuICAgICAgICB0aGlzLnNjb3JlID0gLTE7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjb3JlcyBhbmQgdHJhY2ViYWNrc1xuICAgICAgICB0aGlzLmNvbXB1dGVHcmlkcygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhOZWVkbGVtYW5XdW5zY2gsIFt7XG4gICAgICAgIGtleTogXCJnZXRTY29yZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NvcmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29yZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldEFsaWdubWVudHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsaWdubWVudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFpbiBkeW5hbWljIHByb2dyYW1taW5nIHByb2NlZHVyZVxuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY29tcHV0ZUdyaWRzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlR3JpZHMoKSB7XG4gICAgICAgICAgICAvLyBGaWxsIGluIHRoZSBmaXJzdCByb3dcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgdGhpcy5qTWF4OyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbMF1bal0gPSB0aGlzLmdyaWRbMF1baiAtIDFdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbMF1bal0gPSBbZmFsc2UsIGZhbHNlLCB0cnVlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCBpbiB0aGUgZmlyc3QgY29sdW1uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaU1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW2ldWzBdID0gdGhpcy5ncmlkW2kgLSAxXVswXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW2ldWzBdID0gW2ZhbHNlLCB0cnVlLCBmYWxzZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGwgdGhlIHJlc3Qgb2YgdGhlIGdyaWRcbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDE7IF9pMiA8IHRoaXMuaU1heDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfajIgPSAxOyBfajIgPCB0aGlzLmpNYXg7IF9qMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1heCBzY29yZShzKSBhbW9uZyBbYERpYWdgLCBgVXBgLCBgTGVmdGBdXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWFnID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXF1ZW5jZTFbX2kyIC0gMV0gPT09IHRoaXMuc2VxdWVuY2UyW19qMiAtIDFdKSBkaWFnID0gdGhpcy5ncmlkW19pMiAtIDFdW19qMiAtIDFdICsgdGhpcy5tYXRjaF9zY29yZTtlbHNlIGRpYWcgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyIC0gMV0gKyB0aGlzLm1pc21hdGNoX3BlbmFsdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwID0gdGhpcy5ncmlkW19pMiAtIDFdW19qMl0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuZ3JpZFtfaTJdW19qMiAtIDFdICsgdGhpcy5nYXBfcGVuYWx0eTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBleGlzdHMgbXVsdGlwbGUgbWF4IHZhbHVlcywgY2FwdHVyZSB0aGVtIGZvciBtdWx0aXBsZSBwYXRoc1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4T2YgPSBbZGlhZywgdXAsIGxlZnRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuYXJyYXlBbGxNYXhJbmRleGVzKG1heE9mKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgR3JpZHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkW19pMl1bX2oyXSA9IG1heE9mW2luZGljZXNbMF1dO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbX2kyXVtfajJdID0gW2luZGljZXMuaW5jbHVkZXMoMCksIGluZGljZXMuaW5jbHVkZXMoMSksIGluZGljZXMuaW5jbHVkZXMoMildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsaWdubWVudCBzY29yZVxuICAgICAgICAgICAgdGhpcy5zY29yZSA9IHRoaXMuZ3JpZFt0aGlzLmlNYXggLSAxXVt0aGlzLmpNYXggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldHMgYWxsIHBvc3NpYmxlIHZhbGlkIHNlcXVlbmNlIGNvbWJpbmF0aW9uc1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYWxpZ25tZW50VHJhY2ViYWNrXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbGlnbm1lbnRUcmFjZWJhY2soKSB7XG4gICAgICAgICAgICB2YXIgaW5Qcm9jZXNzQWxpZ25tZW50cyA9IFtdO1xuXG4gICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFt0aGlzLnNlcXVlbmNlMS5sZW5ndGgsIHRoaXMuc2VxdWVuY2UyLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgc2VxMTogXCJcIixcbiAgICAgICAgICAgICAgICBzZXEyOiBcIlwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgd2hpbGUgKGluUHJvY2Vzc0FsaWdubWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGluUHJvY2Vzc0FsaWdubWVudHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSB0aGlzLnRyYWNlYmFja0dyaWRbY3VycmVudC5wb3NbMF1dW2N1cnJlbnQucG9zWzFdXTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdIC0gMSwgY3VycmVudC5wb3NbMV0gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTE6IHRoaXMuc2VxdWVuY2UxW2N1cnJlbnQucG9zWzBdIC0gMV0gKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiB0aGlzLnNlcXVlbmNlMltjdXJyZW50LnBvc1sxXSAtIDFdICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFtjdXJyZW50LnBvc1swXSAtIDEsIGN1cnJlbnQucG9zWzFdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTE6IHRoaXMuc2VxdWVuY2UxW2N1cnJlbnQucG9zWzBdIC0gMV0gKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiAnLScgKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdLCBjdXJyZW50LnBvc1sxXSAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogJy0nICsgY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMjogdGhpcy5zZXF1ZW5jZTJbY3VycmVudC5wb3NbMV0gLSAxXSArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wb3NbMF0gPT09IDAgJiYgY3VycmVudC5wb3NbMV0gPT09IDApIHRoaXMuYWxpZ25tZW50cy5wdXNoKHsgc2VxdWVuY2UxOiBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlMjogY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZWxwZXIgRnVuY3Rpb25zXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRBbGxJbmRleGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbGxJbmRleGVzKGFyciwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgoaSA9IGFyci5pbmRleE9mKHZhbCwgaSArIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFycmF5QWxsTWF4SW5kZXhlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJyYXlBbGxNYXhJbmRleGVzKGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxJbmRleGVzKGFycmF5LCBNYXRoLm1heC5hcHBseShudWxsLCBhcnJheSkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5lZWRsZW1hbld1bnNjaDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOZWVkbGVtYW5XdW5zY2g7XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGxheW91dEJhc2UgPSBmdW5jdGlvbiBsYXlvdXRCYXNlKCkge1xuICByZXR1cm47XG59O1xuXG5sYXlvdXRCYXNlLkZETGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5sYXlvdXRCYXNlLkZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbmxheW91dEJhc2UuRkRMYXlvdXRFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5sYXlvdXRCYXNlLkZETGF5b3V0Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xubGF5b3V0QmFzZS5EaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5sYXlvdXRCYXNlLkhhc2hNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbmxheW91dEJhc2UuSGFzaFNldCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xubGF5b3V0QmFzZS5JR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xubGF5b3V0QmFzZS5JTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5sYXlvdXRCYXNlLkludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbmxheW91dEJhc2UuUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbmxheW91dEJhc2UuUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbmxheW91dEJhc2UuUmFuZG9tU2VlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xubGF5b3V0QmFzZS5SZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5sYXlvdXRCYXNlLlRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xubGF5b3V0QmFzZS5VbmlxdWVJREdlbmVyZXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xubGF5b3V0QmFzZS5RdWlja3NvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbmxheW91dEJhc2UuTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xubGF5b3V0QmFzZS5MR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xubGF5b3V0QmFzZS5MR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xubGF5b3V0QmFzZS5MRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5sYXlvdXRCYXNlLkxHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xubGF5b3V0QmFzZS5MTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5sYXlvdXRCYXNlLkxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xubGF5b3V0QmFzZS5MYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xubGF5b3V0QmFzZS5OZWVkbGVtYW5XdW5zY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsYXlvdXRCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gIHRoaXMubGlzdGVuZXJzID0gW107XG59XG5cbnZhciBwID0gRW1pdHRlci5wcm90b3R5cGU7XG5cbnAuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIHRoaXMubGlzdGVuZXJzLnB1c2goe1xuICAgIGV2ZW50OiBldmVudCxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5wLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsID0gdGhpcy5saXN0ZW5lcnNbaV07XG5cbiAgICBpZiAobC5ldmVudCA9PT0gZXZlbnQgJiYgbC5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cbnAuZW1pdCA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGwgPSB0aGlzLmxpc3RlbmVyc1tpXTtcblxuICAgIGlmIChldmVudCA9PT0gbC5ldmVudCkge1xuICAgICAgbC5jYWxsYmFjayhkYXRhKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsInZhbHVlIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibiIsIl9fZXNNb2R1bGUiLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIkxheW91dENvbnN0YW50cyIsIlFVQUxJVFkiLCJERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQiLCJERUZBVUxUX0lOQ1JFTUVOVEFMIiwiREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUIiwiREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVCIsIkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRCIsIkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVMiLCJERUZBVUxUX0dSQVBIX01BUkdJTiIsIk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyIsIlNJTVBMRV9OT0RFX1NJWkUiLCJTSU1QTEVfTk9ERV9IQUxGX1NJWkUiLCJFTVBUWV9DT01QT1VORF9OT0RFX1NJWkUiLCJNSU5fRURHRV9MRU5HVEgiLCJXT1JMRF9CT1VOREFSWSIsIklOSVRJQUxfV09STERfQk9VTkRBUlkiLCJXT1JMRF9DRU5URVJfWCIsIldPUkxEX0NFTlRFUl9ZIiwiTEdyYXBoT2JqZWN0IiwiSUdlb21ldHJ5IiwiSU1hdGgiLCJMRWRnZSIsInNvdXJjZSIsInRhcmdldCIsInZFZGdlIiwiaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0IiwidkdyYXBoT2JqZWN0IiwiYmVuZHBvaW50cyIsImNyZWF0ZSIsInByb3AiLCJnZXRTb3VyY2UiLCJnZXRUYXJnZXQiLCJpc0ludGVyR3JhcGgiLCJnZXRMZW5ndGgiLCJsZW5ndGgiLCJnZXRCZW5kcG9pbnRzIiwiZ2V0TGNhIiwibGNhIiwiZ2V0U291cmNlSW5MY2EiLCJzb3VyY2VJbkxjYSIsImdldFRhcmdldEluTGNhIiwidGFyZ2V0SW5MY2EiLCJnZXRPdGhlckVuZCIsIm5vZGUiLCJnZXRPdGhlckVuZEluR3JhcGgiLCJncmFwaCIsIm90aGVyRW5kIiwiZ2V0R3JhcGhNYW5hZ2VyIiwiZ2V0Um9vdCIsImdldE93bmVyIiwiZ2V0UGFyZW50IiwidXBkYXRlTGVuZ3RoIiwiY2xpcFBvaW50Q29vcmRpbmF0ZXMiLCJBcnJheSIsImdldEludGVyc2VjdGlvbiIsImdldFJlY3QiLCJsZW5ndGhYIiwibGVuZ3RoWSIsIk1hdGgiLCJhYnMiLCJzaWduIiwic3FydCIsInVwZGF0ZUxlbmd0aFNpbXBsZSIsImdldENlbnRlclgiLCJnZXRDZW50ZXJZIiwiSW50ZWdlciIsIlJlY3RhbmdsZUQiLCJSYW5kb21TZWVkIiwiUG9pbnREIiwiTE5vZGUiLCJnbSIsImxvYyIsInNpemUiLCJ2Tm9kZSIsImdyYXBoTWFuYWdlciIsImVzdGltYXRlZFNpemUiLCJNSU5fVkFMVUUiLCJpbmNsdXNpb25UcmVlRGVwdGgiLCJNQVhfVkFMVUUiLCJlZGdlcyIsInJlY3QiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0RWRnZXMiLCJnZXRDaGlsZCIsImNoaWxkIiwib3duZXIiLCJnZXRXaWR0aCIsInNldFdpZHRoIiwiZ2V0SGVpZ2h0Iiwic2V0SGVpZ2h0IiwiZ2V0Q2VudGVyIiwiZ2V0TG9jYXRpb24iLCJnZXREaWFnb25hbCIsImdldEhhbGZUaGVEaWFnb25hbCIsInNldFJlY3QiLCJ1cHBlckxlZnQiLCJkaW1lbnNpb24iLCJzZXRDZW50ZXIiLCJjeCIsImN5Iiwic2V0TG9jYXRpb24iLCJtb3ZlQnkiLCJkeCIsImR5IiwiZ2V0RWRnZUxpc3RUb05vZGUiLCJ0byIsImVkZ2VMaXN0IiwiZWRnZSIsInNlbGYiLCJmb3JFYWNoIiwicHVzaCIsImdldEVkZ2VzQmV0d2VlbiIsIm90aGVyIiwiZ2V0TmVpZ2hib3JzTGlzdCIsIm5laWdoYm9ycyIsIlNldCIsImFkZCIsIndpdGhDaGlsZHJlbiIsIndpdGhOZWlnaGJvcnNMaXN0IiwiY2hpbGROb2RlIiwiY2hpbGRyZW4iLCJub2RlcyIsImdldE5vZGVzIiwiZ2V0Tm9PZkNoaWxkcmVuIiwibm9PZkNoaWxkcmVuIiwiZ2V0RXN0aW1hdGVkU2l6ZSIsImNhbGNFc3RpbWF0ZWRTaXplIiwic2NhdHRlciIsInJhbmRvbUNlbnRlclgiLCJyYW5kb21DZW50ZXJZIiwibWluWCIsIm1heFgiLCJuZXh0RG91YmxlIiwibWluWSIsIm1heFkiLCJ1cGRhdGVCb3VuZHMiLCJjaGlsZEdyYXBoIiwiZ2V0TGVmdCIsImdldFRvcCIsImdldFJpZ2h0IiwiZ2V0Qm90dG9tIiwibGFiZWxXaWR0aCIsImxhYmVsSGVpZ2h0IiwibGFiZWxQb3MiLCJnZXRJbmNsdXNpb25UcmVlRGVwdGgiLCJ0cmFuc2Zvcm0iLCJ0cmFucyIsImxlZnQiLCJ0b3AiLCJsZWZ0VG9wIiwidkxlZnRUb3AiLCJpbnZlcnNlVHJhbnNmb3JtUG9pbnQiLCJnZXRYIiwiZ2V0WSIsInNldFgiLCJzZXRZIiwiZ2V0RGlmZmVyZW5jZSIsInB0IiwiRGltZW5zaW9uRCIsImdldENvcHkiLCJ0cmFuc2xhdGUiLCJkaW0iLCJMR3JhcGhNYW5hZ2VyIiwiUG9pbnQiLCJMaW5rZWRMaXN0IiwiTEdyYXBoIiwicGFyZW50Iiwib2JqMiIsInZHcmFwaCIsIm1hcmdpbiIsImlzQ29ubmVjdGVkIiwiTGF5b3V0IiwicmlnaHQiLCJib3R0b20iLCJvYmoxIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJuZXdOb2RlIiwiaW5kZXhPZiIsIm5ld0VkZ2UiLCJyZW1vdmUiLCJvYmoiLCJlZGdlc1RvQmVSZW1vdmVkIiwic2xpY2UiLCJpbmRleCIsInNwbGljZSIsInNvdXJjZUluZGV4IiwidGFyZ2V0SW5kZXgiLCJ1cGRhdGVMZWZ0VG9wIiwibm9kZVRvcCIsIm5vZGVMZWZ0IiwibE5vZGUiLCJwYWRkaW5nTGVmdCIsInVuZGVmaW5lZCIsInJlY3Vyc2l2ZSIsIm5vZGVSaWdodCIsIm5vZGVCb3R0b20iLCJib3VuZGluZ1JlY3QiLCJjYWxjdWxhdGVCb3VuZHMiLCJ1cGRhdGVDb25uZWN0ZWQiLCJxdWV1ZSIsInZpc2l0ZWQiLCJjdXJyZW50Tm9kZSIsIm5laWdoYm9yRWRnZXMiLCJjdXJyZW50TmVpZ2hib3IiLCJjaGlsZHJlbk9mTm9kZSIsInNoaWZ0IiwibmVpZ2hib3JFZGdlIiwiaGFzIiwiY2hpbGRyZW5PZk5laWdoYm9yIiwibm9PZlZpc2l0ZWRJblRoaXNHcmFwaCIsInZpc2l0ZWROb2RlIiwibGF5b3V0IiwiZ3JhcGhzIiwiYWRkUm9vdCIsIm5ncmFwaCIsIm5ld0dyYXBoIiwibm5vZGUiLCJzZXRSb290R3JhcGgiLCJyb290R3JhcGgiLCJwYXJlbnROb2RlIiwic291cmNlR3JhcGgiLCJ0YXJnZXRHcmFwaCIsImxPYmoiLCJjb25jYXQiLCJub2Rlc1RvQmVSZW1vdmVkIiwiZ2V0R3JhcGhzIiwiZ2V0QWxsTm9kZXMiLCJhbGxOb2RlcyIsIm5vZGVMaXN0IiwicmVzZXRBbGxOb2RlcyIsInJlc2V0QWxsRWRnZXMiLCJhbGxFZGdlcyIsInJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24iLCJhbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImdldEFsbEVkZ2VzIiwiZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24iLCJzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImdldExheW91dCIsImlzT25lQW5jZXN0b3JPZk90aGVyIiwiZmlyc3ROb2RlIiwic2Vjb25kTm9kZSIsIm93bmVyR3JhcGgiLCJjYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzIiwic291cmNlQW5jZXN0b3JHcmFwaCIsInRhcmdldEFuY2VzdG9yR3JhcGgiLCJjYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJmaXJzdE93bmVyR3JhcGgiLCJzZWNvbmRPd25lckdyYXBoIiwiY2FsY0luY2x1c2lvblRyZWVEZXB0aHMiLCJkZXB0aCIsImluY2x1ZGVzSW52YWxpZEVkZ2UiLCJGRExheW91dENvbnN0YW50cyIsIk1BWF9JVEVSQVRJT05TIiwiREVGQVVMVF9FREdFX0xFTkdUSCIsIkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIIiwiREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEgiLCJERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEgiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEgiLCJERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsIkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OIiwiREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OIiwiREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCIsIkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IiLCJBREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQiLCJBREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQiLCJNQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUwiLCJNQVhfTk9ERV9ESVNQTEFDRU1FTlQiLCJNSU5fUkVQVUxTSU9OX0RJU1QiLCJDT05WRVJHRU5DRV9DSEVDS19QRVJJT0QiLCJQRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SIiwiR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QiLCJjYWxjU2VwYXJhdGlvbkFtb3VudCIsInJlY3RBIiwicmVjdEIiLCJvdmVybGFwQW1vdW50Iiwic2VwYXJhdGlvbkJ1ZmZlciIsImludGVyc2VjdHMiLCJkaXJlY3Rpb25zIiwiZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMiLCJtaW4iLCJtYXgiLCJzbG9wZSIsIm1vdmVCeVkiLCJtb3ZlQnlYIiwiZ2V0SW50ZXJzZWN0aW9uMiIsInJlc3VsdCIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInRvcExlZnRBeCIsInRvcExlZnRBeSIsInRvcFJpZ2h0QXgiLCJib3R0b21MZWZ0QXgiLCJib3R0b21MZWZ0QXkiLCJib3R0b21SaWdodEF4IiwiaGFsZldpZHRoQSIsImdldFdpZHRoSGFsZiIsImhhbGZIZWlnaHRBIiwiZ2V0SGVpZ2h0SGFsZiIsInRvcExlZnRCeCIsInRvcExlZnRCeSIsInRvcFJpZ2h0QngiLCJib3R0b21MZWZ0QngiLCJib3R0b21MZWZ0QnkiLCJib3R0b21SaWdodEJ4IiwiaGFsZldpZHRoQiIsImhhbGZIZWlnaHRCIiwiY2xpcFBvaW50QUZvdW5kIiwiY2xpcFBvaW50QkZvdW5kIiwic2xvcGVBIiwic2xvcGVCIiwic2xvcGVQcmltZSIsImNhcmRpbmFsRGlyZWN0aW9uQSIsImNhcmRpbmFsRGlyZWN0aW9uQiIsInRlbXBQb2ludEF4IiwidGVtcFBvaW50QXkiLCJ0ZW1wUG9pbnRCeCIsInRlbXBQb2ludEJ5IiwiZ2V0Q2FyZGluYWxEaXJlY3Rpb24iLCJsaW5lIiwiczEiLCJzMiIsImYxIiwiZjIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJ4NCIsInk0IiwiYTEiLCJhMiIsImIxIiwiYjIiLCJjMSIsImMyIiwiZGVub20iLCJhbmdsZU9mVmVjdG9yIiwiQ3giLCJDeSIsIk54IiwiTnkiLCJDX2FuZ2xlIiwiYXRhbiIsIlBJIiwiVFdPX1BJIiwiT05FX0FORF9IQUxGX1BJIiwiSEFMRl9QSSIsImRvSW50ZXJzZWN0IiwicDEiLCJwMiIsInAzIiwicDQiLCJhIiwiYiIsInEiLCJyIiwiZGV0IiwibGFtYmRhIiwiZ2FtbWEiLCJUSFJFRV9QSSIsImZsb29yIiwiY2VpbCIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJ3cml0YWJsZSIsImtleSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJUeXBlRXJyb3IiLCJub2RlRnJvbSIsIm5leHQiLCJwcmV2IiwibGlzdCIsImhlYWQiLCJ0YWlsIiwiX3JlbW92ZSIsInZhbHMiLCJfdGhpcyIsInYiLCJpbnNlcnRCZWZvcmUiLCJ2YWwiLCJvdGhlck5vZGUiLCJpbnNlcnRBZnRlciIsImluc2VydE5vZGVCZWZvcmUiLCJpbnNlcnROb2RlQWZ0ZXIiLCJ1bnNoaWZ0IiwicG9wIiwicG9wTm9kZSIsInNoaWZ0Tm9kZSIsImdldF9vYmplY3RfYXQiLCJjdXJyZW50Iiwic2V0X29iamVjdF9hdCIsImNvbnN0cnVjdG9yIiwicGFyc2VJbnQiLCJtb3ZlIiwiZXF1YWxzIiwidG9TdHJpbmciLCJnZXRNaW5YIiwiZ2V0TWF4WCIsImdldE1pblkiLCJnZXRNYXhZIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiVW5pcXVlSURHZW5lcmV0b3IiLCJsYXN0SUQiLCJjcmVhdGVJRCIsImlzUHJpbWl0aXZlIiwidW5pcXVlSUQiLCJnZXRTdHJpbmciLCJpZCIsImFyZyIsInR5cGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJpc0FycmF5IiwiYXJyMiIsImZyb20iLCJUcmFuc2Zvcm0iLCJFbWl0dGVyIiwiaXNSZW1vdGVVc2UiLCJsYXlvdXRRdWFsaXR5IiwiY3JlYXRlQmVuZHNBc05lZWRlZCIsImluY3JlbWVudGFsIiwiYW5pbWF0aW9uT25MYXlvdXQiLCJhbmltYXRpb25EdXJpbmdMYXlvdXQiLCJhbmltYXRpb25QZXJpb2QiLCJ1bmlmb3JtTGVhZk5vZGVTaXplcyIsImVkZ2VUb0R1bW15Tm9kZXMiLCJNYXAiLCJpc0xheW91dEZpbmlzaGVkIiwiaXNTdWJMYXlvdXQiLCJSQU5ET01fU0VFRCIsIm5ld0dyYXBoTWFuYWdlciIsImNoZWNrTGF5b3V0U3VjY2VzcyIsInJ1bkxheW91dCIsInRpbGluZ1ByZUxheW91dCIsImluaXRQYXJhbWV0ZXJzIiwiaXNMYXlvdXRTdWNjZXNzZnVsbCIsIkFOSU1BVEUiLCJkb1Bvc3RMYXlvdXQiLCJ0aWxpbmdQb3N0TGF5b3V0IiwidXBkYXRlIiwidXBkYXRlMiIsImNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcyIsIm5ld0xlZnRUb3AiLCJzZXRXb3JsZE9yZ1giLCJzZXRXb3JsZE9yZ1kiLCJzZXREZXZpY2VPcmdYIiwic2V0RGV2aWNlT3JnWSIsInBvc2l0aW9uTm9kZXNSYW5kb21seSIsImdldEZsYXRGb3Jlc3QiLCJmbGF0Rm9yZXN0IiwiaXNGb3Jlc3QiLCJpc0ZsYXQiLCJ0b0JlVmlzaXRlZCIsInBhcmVudHMiLCJ1blByb2Nlc3NlZE5vZGVzIiwic2V0IiwidGVtcCIsImNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzIiwiZHVtbXlOb2RlcyIsImR1bW15Tm9kZSIsIkRpbWVuc2lvbiIsImR1bW15RWRnZSIsImtleXMiLCJrIiwibEVkZ2UiLCJwYXRoIiwiZWJwIiwic2xpZGVyVmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJtaW5EaXYiLCJtYXhNdWwiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiZmluZENlbnRlck9mVHJlZSIsInJlbW92ZWROb2RlcyIsInJlbWFpbmluZ0RlZ3JlZXMiLCJmb3VuZENlbnRlciIsImNlbnRlck5vZGUiLCJkZWdyZWUiLCJ0ZW1wTGlzdCIsInRlbXBMaXN0MiIsIm5laWdoYm91cnMiLCJuZWlnaGJvdXIiLCJvdGhlckRlZ3JlZSIsIm5ld0RlZ3JlZSIsInNldEdyYXBoTWFuYWdlciIsInNlZWQiLCJzaW4iLCJsd29ybGRPcmdYIiwibHdvcmxkT3JnWSIsImxkZXZpY2VPcmdYIiwibGRldmljZU9yZ1kiLCJsd29ybGRFeHRYIiwibHdvcmxkRXh0WSIsImxkZXZpY2VFeHRYIiwibGRldmljZUV4dFkiLCJnZXRXb3JsZE9yZ1giLCJ3b3giLCJnZXRXb3JsZE9yZ1kiLCJ3b3kiLCJnZXRXb3JsZEV4dFgiLCJzZXRXb3JsZEV4dFgiLCJ3ZXgiLCJnZXRXb3JsZEV4dFkiLCJzZXRXb3JsZEV4dFkiLCJ3ZXkiLCJnZXREZXZpY2VPcmdYIiwiZG94IiwiZ2V0RGV2aWNlT3JnWSIsImRveSIsImdldERldmljZUV4dFgiLCJzZXREZXZpY2VFeHRYIiwiZGV4IiwiZ2V0RGV2aWNlRXh0WSIsInNldERldmljZUV4dFkiLCJkZXkiLCJ0cmFuc2Zvcm1YIiwieERldmljZSIsIndvcmxkRXh0WCIsInRyYW5zZm9ybVkiLCJ5RGV2aWNlIiwid29ybGRFeHRZIiwiaW52ZXJzZVRyYW5zZm9ybVgiLCJ4V29ybGQiLCJkZXZpY2VFeHRYIiwiaW52ZXJzZVRyYW5zZm9ybVkiLCJ5V29ybGQiLCJkZXZpY2VFeHRZIiwiaW5Qb2ludCIsIm91dFBvaW50IiwiRkRMYXlvdXQiLCJ1c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uIiwiaWRlYWxFZGdlTGVuZ3RoIiwic3ByaW5nQ29uc3RhbnQiLCJyZXB1bHNpb25Db25zdGFudCIsImdyYXZpdHlDb25zdGFudCIsImNvbXBvdW5kR3Jhdml0eUNvbnN0YW50IiwiZ3Jhdml0eVJhbmdlRmFjdG9yIiwiY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IiLCJkaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlIiwiY29vbGluZ0ZhY3RvciIsImluaXRpYWxDb29saW5nRmFjdG9yIiwidG90YWxEaXNwbGFjZW1lbnQiLCJvbGRUb3RhbERpc3BsYWNlbWVudCIsIm1heEl0ZXJhdGlvbnMiLCJhcmd1bWVudHMiLCJ0b3RhbEl0ZXJhdGlvbnMiLCJub3RBbmltYXRlZEl0ZXJhdGlvbnMiLCJ1c2VGUkdyaWRWYXJpYW50IiwiZ3JpZCIsImNhbGNJZGVhbEVkZ2VMZW5ndGhzIiwibGNhRGVwdGgiLCJzaXplT2ZTb3VyY2VJbkxjYSIsInNpemVPZlRhcmdldEluTGNhIiwiaWRlYWxMZW5ndGgiLCJpbml0U3ByaW5nRW1iZWRkZXIiLCJtYXhOb2RlRGlzcGxhY2VtZW50IiwidG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQiLCJyZXB1bHNpb25SYW5nZSIsImNhbGNSZXB1bHNpb25SYW5nZSIsImNhbGNTcHJpbmdGb3JjZXMiLCJsRWRnZXMiLCJjYWxjU3ByaW5nRm9yY2UiLCJjYWxjUmVwdWxzaW9uRm9yY2VzIiwiZ3JpZFVwZGF0ZUFsbG93ZWQiLCJmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlIiwiaiIsIm5vZGVBIiwibm9kZUIiLCJsTm9kZXMiLCJwcm9jZXNzZWROb2RlU2V0IiwidXBkYXRlR3JpZCIsImNhbGN1bGF0ZVJlcHVsc2lvbkZvcmNlT2ZBTm9kZSIsImNhbGNSZXB1bHNpb25Gb3JjZSIsImNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzIiwiY2FsY0dyYXZpdGF0aW9uYWxGb3JjZSIsIm1vdmVOb2RlcyIsInNwcmluZ0ZvcmNlIiwic3ByaW5nRm9yY2VYIiwic3ByaW5nRm9yY2VZIiwiY2xpcFBvaW50cyIsImRpc3RhbmNlWCIsImRpc3RhbmNlWSIsImRpc3RhbmNlU3F1YXJlZCIsImRpc3RhbmNlIiwicmVwdWxzaW9uRm9yY2UiLCJyZXB1bHNpb25Gb3JjZVgiLCJyZXB1bHNpb25Gb3JjZVkiLCJjaGlsZHJlbkNvbnN0YW50Iiwib3duZXJDZW50ZXJYIiwib3duZXJDZW50ZXJZIiwiYWJzRGlzdGFuY2VYIiwiYWJzRGlzdGFuY2VZIiwiZ3Jhdml0YXRpb25Gb3JjZVgiLCJncmF2aXRhdGlvbkZvcmNlWSIsImlzQ29udmVyZ2VkIiwiY29udmVyZ2VkIiwib3NjaWxhdGluZyIsImFuaW1hdGUiLCJjYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMiLCJjYWxjR3JpZCIsInNpemVYIiwic2l6ZVkiLCJhZGROb2RlVG9HcmlkIiwic3RhcnRYIiwiZmluaXNoWCIsInN0YXJ0WSIsImZpbmlzaFkiLCJzZXRHcmlkQ29vcmRpbmF0ZXMiLCJzdXJyb3VuZGluZyIsIkZETGF5b3V0RWRnZSIsIkZETGF5b3V0Tm9kZSIsImRpc3BsYWNlbWVudFgiLCJkaXNwbGFjZW1lbnRZIiwiX3N0YXJ0WCIsIl9maW5pc2hYIiwiX3N0YXJ0WSIsIl9maW5pc2hZIiwiSGFzaE1hcCIsIm1hcCIsInB1dCIsInRoZUlkIiwiY29udGFpbnMiLCJrZXlTZXQiLCJIYXNoU2V0IiwiY2xlYXIiLCJpc0VtcHR5IiwiYWRkQWxsVG8iLCJhZGRBbGwiLCJRdWlja3NvcnQiLCJBIiwiY29tcGFyZUZ1bmN0aW9uIiwiX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24iLCJfcXVpY2tzb3J0IiwiX3BhcnRpdGlvbiIsIl9nZXQiLCJfc3dhcCIsIl9zZXQiLCJOZWVkbGVtYW5XdW5zY2giLCJzZXF1ZW5jZTEiLCJzZXF1ZW5jZTIiLCJtYXRjaF9zY29yZSIsIm1pc21hdGNoX3BlbmFsdHkiLCJnYXBfcGVuYWx0eSIsImlNYXgiLCJqTWF4IiwidHJhY2ViYWNrR3JpZCIsIl9pIiwiX2oiLCJhbGlnbm1lbnRzIiwic2NvcmUiLCJjb21wdXRlR3JpZHMiLCJnZXRTY29yZSIsImdldEFsaWdubWVudHMiLCJfaTIiLCJfajIiLCJkaWFnIiwidXAiLCJtYXhPZiIsImluZGljZXMiLCJhcnJheUFsbE1heEluZGV4ZXMiLCJpbmNsdWRlcyIsImFsaWdubWVudFRyYWNlYmFjayIsImluUHJvY2Vzc0FsaWdubWVudHMiLCJwb3MiLCJzZXExIiwic2VxMiIsImdldEFsbEluZGV4ZXMiLCJpbmRleGVzIiwiYXJyYXkiLCJhcHBseSIsImxheW91dEJhc2UiLCJsaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsImV2ZW50IiwiY2FsbGJhY2siLCJyZW1vdmVMaXN0ZW5lciIsImVtaXQiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/layout-base/layout-base.js\n");

/***/ })

};
;